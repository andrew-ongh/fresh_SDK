<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___d_e_v_i_c_e_s.html">DEVICES</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>I2C Controller.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hw__i2c_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__i2c_8h.html">hw_i2c.h</a></td></tr>
<tr class="memdesc:hw__i2c_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of API for the I2C Low Level Driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__config.html">i2c_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C configuration.  <a href="structi2c__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab2c8ab2a4f1438202f08aa4e60ef0914"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab2c8ab2a4f1438202f08aa4e60ef0914"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab2c8ab2a4f1438202f08aa4e60ef0914">I2C_FIFO_DEPTH</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:gab2c8ab2a4f1438202f08aa4e60ef0914"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX/RX FIFO depth. <br /></td></tr>
<tr class="separator:gab2c8ab2a4f1438202f08aa4e60ef0914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc0311455ca8686015d5c0a7751c9d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gacdc0311455ca8686015d5c0a7751c9d1">I2C_SETUP</a>(id,  seq)</td></tr>
<tr class="memdesc:gacdc0311455ca8686015d5c0a7751c9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to perform controller setup.  <a href="#gacdc0311455ca8686015d5c0a7751c9d1">More...</a><br /></td></tr>
<tr class="separator:gacdc0311455ca8686015d5c0a7751c9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb92f2c77d6f2cc99cc1943783d174d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb92f2c77d6f2cc99cc1943783d174d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabb92f2c77d6f2cc99cc1943783d174d2">HW_I2C1</a>&#160;&#160;&#160;((void *)I2C_BASE)</td></tr>
<tr class="memdesc:gabb92f2c77d6f2cc99cc1943783d174d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C controller instance. <br /></td></tr>
<tr class="separator:gabb92f2c77d6f2cc99cc1943783d174d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf101cb30b8b19337faa1130b230b79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:gadaf101cb30b8b19337faa1130b230b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561070559a39fe8aa62f839207c5e5b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga561070559a39fe8aa62f839207c5e5b7">HW_I2C_F_WAIT_FOR_STOP</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:ga561070559a39fe8aa62f839207c5e5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeccd5262bded02079206c0fed157b02e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:gaeccd5262bded02079206c0fed157b02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0805a21fb0272d1ba210f1b8406d9d6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0805a21fb0272d1ba210f1b8406d9d6b">HW_I2C_REG_SETF</a>(id,  reg,  field,  val)</td></tr>
<tr class="memdesc:ga0805a21fb0272d1ba210f1b8406d9d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a value to an I2C register field.  <a href="#ga0805a21fb0272d1ba210f1b8406d9d6b">More...</a><br /></td></tr>
<tr class="separator:ga0805a21fb0272d1ba210f1b8406d9d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf98ed2c050989a781b95443ca34ac61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gacf98ed2c050989a781b95443ca34ac61">HW_I2C_REG_GETF</a>(id,  reg,  field)&#160;&#160;&#160;((IBA(id)-&gt;reg##_REG &amp; (I2C_##reg##_REG_##field##_Msk)) &gt;&gt; (I2C_##reg##_REG_##field##_Pos))</td></tr>
<tr class="memdesc:gacf98ed2c050989a781b95443ca34ac61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an I2C register field.  <a href="#gacf98ed2c050989a781b95443ca34ac61">More...</a><br /></td></tr>
<tr class="separator:gacf98ed2c050989a781b95443ca34ac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga07fb0d97fcc29f7d55b1846927d7ad18"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga07fb0d97fcc29f7d55b1846927d7ad18">hw_i2c_interrupt_cb</a>) (HW_I2C_ID id, uint16_t mask)</td></tr>
<tr class="memdesc:ga07fb0d97fcc29f7d55b1846927d7ad18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback fired on interrupt from I2C controller.  <a href="#ga07fb0d97fcc29f7d55b1846927d7ad18">More...</a><br /></td></tr>
<tr class="separator:ga07fb0d97fcc29f7d55b1846927d7ad18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93c52dfb507e72c87250e55aeacd7fa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>) (HW_I2C_ID id, void *cb_data, uint16_t len, bool success)</td></tr>
<tr class="memdesc:gaa93c52dfb507e72c87250e55aeacd7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback fired upon completion of read or write in non-blocking mode (FIFO or DMA)  <a href="#gaa93c52dfb507e72c87250e55aeacd7fa">More...</a><br /></td></tr>
<tr class="separator:gaa93c52dfb507e72c87250e55aeacd7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98460606fa72baa2d9850adb16b2f836"><td class="memItemLeft" align="right" valign="top">typedef DEPRECATED void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga98460606fa72baa2d9850adb16b2f836">hw_i2c_write_handler_cb</a>) (HW_I2C_ID id, void *cb_data, uint16_t len, bool success)</td></tr>
<tr class="memdesc:ga98460606fa72baa2d9850adb16b2f836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback fired on write complete in non-blocking mode.  <a href="#ga98460606fa72baa2d9850adb16b2f836">More...</a><br /></td></tr>
<tr class="separator:ga98460606fa72baa2d9850adb16b2f836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b3971a2fad1ecf0c9c617746ce6a3f6"><td class="memItemLeft" align="right" valign="top">typedef DEPRECATED void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3b3971a2fad1ecf0c9c617746ce6a3f6">hw_i2c_read_handler_cb</a>) (HW_I2C_ID id, void *cb_data, uint16_t len, bool success)</td></tr>
<tr class="memdesc:ga3b3971a2fad1ecf0c9c617746ce6a3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback fired on read complete in non-blocking mode.  <a href="#ga3b3971a2fad1ecf0c9c617746ce6a3f6">More...</a><br /></td></tr>
<tr class="separator:ga3b3971a2fad1ecf0c9c617746ce6a3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b531343651246138ece5034039dd912"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1b531343651246138ece5034039dd912">hw_i2c_dma_completed_handler_cb</a>) (HW_I2C_ID id, void *cb_data, uint16_t len)</td></tr>
<tr class="memdesc:ga1b531343651246138ece5034039dd912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback fired on DMA operation completed.  <a href="#ga1b531343651246138ece5034039dd912">More...</a><br /></td></tr>
<tr class="separator:ga1b531343651246138ece5034039dd912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf953d4d6f6b9465dcc65d369b4bcb2bd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a>) (HW_I2C_ID id, <a class="el" href="group___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">HW_I2C_EVENT</a> event)</td></tr>
<tr class="memdesc:gaf953d4d6f6b9465dcc65d369b4bcb2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback fired on event when in slave role.  <a href="#gaf953d4d6f6b9465dcc65d369b4bcb2bd">More...</a><br /></td></tr>
<tr class="separator:gaf953d4d6f6b9465dcc65d369b4bcb2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf7ef8a80c9c6e53c3edf28cc5bf2007e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eae82067c1b8c3ff8ebc74186a9c0ea898">HW_I2C_ABORT_NONE</a> = 0, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea339c3cf6463507009210a912d59643fe">HW_I2C_ABORT_7B_ADDR_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_7B_ADDR_NOACK_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eadcf4555266b2cf92da1855d4074188a1">HW_I2C_ABORT_10B_ADDR1_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_10ADDR1_NOACK_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf8e8a6cca5c2eea4f3cf52908d764fc3">HW_I2C_ABORT_10B_ADDR2_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_10ADDR2_NOACK_Msk, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea89ed5978c4fe2387710c2bb37741eeda">HW_I2C_ABORT_TX_DATA_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_TXDATA_NOACK_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eab2998a68ea7a4125b36ee1f7535c1e35">HW_I2C_ABORT_GENERAL_CALL_NO_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_GCALL_NOACK_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eacba5b0d9fea9fef11005edcf89189979">HW_I2C_ABORT_GENERAL_CALL_READ</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_GCALL_READ_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaead3321ef58dce6a681f2060dd3884de">HW_I2C_ABORT_START_BYTE_ACK</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_SBYTE_ACKDET_Msk, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea193c3b94ff14a9ddb921b9fbfbc07983">HW_I2C_ABORT_10B_READ_NO_RESTART</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_10B_RD_NORSTRT_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eabd08dc012bed51af07820d453f45dd2e">HW_I2C_ABORT_MASTER_DISABLED</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_MASTER_DIS_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf37422d631a97547825d6b2106f20b5b">HW_I2C_ABORT_ARBITRATION_LOST</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ARB_LOST_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf579d26d06ff5b00ddd0061070fbbdc2">HW_I2C_ABORT_SLAVE_FLUSH_TX_FIFO</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_SLVFLUSH_TXFIFO_Msk, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea1dc300a69352c4a42cd130a030ad4624">HW_I2C_ABORT_SLAVE_ARBITRATION_LOST</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_SLV_ARBLOST_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea1fe3909020f346dc4aba68abd07e9498">HW_I2C_ABORT_SLAVE_IN_TX</a> = I2C_I2C_TX_ABRT_SOURCE_REG_ABRT_SLVRD_INTX_Msk, 
<a class="el" href="group___i2_c.html#ggaf7ef8a80c9c6e53c3edf28cc5bf2007eada4e3b7ea6a617303cff16354cb9ead1">HW_I2C_ABORT_SW_ERROR</a>
<br />
 }</td></tr>
<tr class="memdesc:gaf7ef8a80c9c6e53c3edf28cc5bf2007e"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C abort source.  <a href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">More...</a><br /></td></tr>
<tr class="separator:gaf7ef8a80c9c6e53c3edf28cc5bf2007e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cbcaaa7663a2cbba9418cdb5aab66d9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">HW_I2C_SPEED</a> { <a class="el" href="group___i2_c.html#gga4cbcaaa7663a2cbba9418cdb5aab66d9ae56e52ba2b3aaceccff7e09c8b59c93e">HW_I2C_SPEED_STANDARD</a> = 0, 
<a class="el" href="group___i2_c.html#gga4cbcaaa7663a2cbba9418cdb5aab66d9a57993addaedcd03090ab60a2b7759f36">HW_I2C_SPEED_FAST</a>
 }</td></tr>
<tr class="memdesc:ga4cbcaaa7663a2cbba9418cdb5aab66d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C interface speed.  <a href="group___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">More...</a><br /></td></tr>
<tr class="separator:ga4cbcaaa7663a2cbba9418cdb5aab66d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7ffb060052bb9ac0c167835afcc910"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">HW_I2C_MODE</a> { <a class="el" href="group___i2_c.html#ggadf7ffb060052bb9ac0c167835afcc910a70929eedc6ae4fba724cc57c4ece19e6">HW_I2C_MODE_MASTER</a> = 0, 
<a class="el" href="group___i2_c.html#ggadf7ffb060052bb9ac0c167835afcc910adf9acb461b0239156a18bbe5280bf4d4">HW_I2C_MODE_SLAVE</a>
 }</td></tr>
<tr class="memdesc:gadf7ffb060052bb9ac0c167835afcc910"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C role.  <a href="group___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">More...</a><br /></td></tr>
<tr class="separator:gadf7ffb060052bb9ac0c167835afcc910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4b473a8fcb034aaabd8d2c7cf9c6bd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> { <a class="el" href="group___i2_c.html#gga8c4b473a8fcb034aaabd8d2c7cf9c6bdae223953fbec142796f36014e08490afb">HW_I2C_ADDRESSING_7B</a> = 0, 
<a class="el" href="group___i2_c.html#gga8c4b473a8fcb034aaabd8d2c7cf9c6bdab40023bfb7104ee30683a2377246892e">HW_I2C_ADDRESSING_10B</a>
 }</td></tr>
<tr class="memdesc:ga8c4b473a8fcb034aaabd8d2c7cf9c6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C addressing mode.  <a href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">More...</a><br /></td></tr>
<tr class="separator:ga8c4b473a8fcb034aaabd8d2c7cf9c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f970897e2e55be317fcae7f01bdf1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">HW_I2C_EVENT</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1fac5b1bfd3ab06735b76bbdd7e731afacb">HW_I2C_EVENT_READ_REQUEST</a> = 0, 
<a class="el" href="group___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1fae3a61cfca95b35f79a38ded155f8d896">HW_I2C_EVENT_DATA_READY</a>, 
<a class="el" href="group___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1fa5ff2bf612fd676b74c4477d65cb4644b">HW_I2C_EVENT_TX_ABORT</a>, 
<a class="el" href="group___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1fa556ed33f8390ad37fbe8505db1fd45ae">HW_I2C_EVENT_RX_OVERFLOW</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#gga67f970897e2e55be317fcae7f01bdf1faf1ab08c136ac9364cf922be55da999fa">HW_I2C_EVENT_INVALID</a>
<br />
 }</td></tr>
<tr class="memdesc:ga67f970897e2e55be317fcae7f01bdf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback events when working as slave.  <a href="group___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">More...</a><br /></td></tr>
<tr class="separator:ga67f970897e2e55be317fcae7f01bdf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab067c78f6839084ba44ddd5ffa375a4c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab067c78f6839084ba44ddd5ffa375a4c">HW_I2C_INT</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca61baec49ed26f10abe66c8d0132ea189">HW_I2C_INT_RX_UNDERFLOW</a> = I2C_I2C_INTR_STAT_REG_R_RX_UNDER_Msk, 
<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4cafcd7b0583a6b99d8854fa2909ec90c4c">HW_I2C_INT_RX_OVERFLOW</a> = I2C_I2C_INTR_STAT_REG_R_RX_OVER_Msk, 
<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca8acaa4d17886b481f05246d3d4ae818e">HW_I2C_INT_RX_FULL</a> = I2C_I2C_INTR_STAT_REG_R_RX_FULL_Msk, 
<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca543a0b0fb421fb098f3ccc80d42af4c2">HW_I2C_INT_TX_OVERFLOW</a> = I2C_I2C_INTR_STAT_REG_R_TX_OVER_Msk, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4cacdeff6bd5f88c566caefda8ba7d7f237">HW_I2C_INT_TX_EMPTY</a> = I2C_I2C_INTR_STAT_REG_R_TX_EMPTY_Msk, 
<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca39b828d633959d80010b47553d42948c">HW_I2C_INT_READ_REQUEST</a> = I2C_I2C_INTR_STAT_REG_R_RD_REQ_Msk, 
<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4caca667f9f8631fd98f1f0a11fc4f0c868">HW_I2C_INT_TX_ABORT</a> = I2C_I2C_INTR_STAT_REG_R_TX_ABRT_Msk, 
<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca24025187688fc359ddc30f95b538097e">HW_I2C_INT_RX_DONE</a> = I2C_I2C_INTR_STAT_REG_R_RX_DONE_Msk, 
<br />
&#160;&#160;<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca191c65c506005d2c2a1c28bfc99797a5">HW_I2C_INT_ACTIVITY</a> = I2C_I2C_INTR_STAT_REG_R_ACTIVITY_Msk, 
<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4caa20a13e8d583e0c25a109cf3fd5e5d3a">HW_I2C_INT_STOP_DETECTED</a> = I2C_I2C_INTR_STAT_REG_R_STOP_DET_Msk, 
<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4caf4c788f651f281694564881e03e1f450">HW_I2C_INT_START_DETECTED</a> = I2C_I2C_INTR_STAT_REG_R_START_DET_Msk, 
<a class="el" href="group___i2_c.html#ggab067c78f6839084ba44ddd5ffa375a4ca57b24b5967091179674f5cfc437eb127">HW_I2C_INT_GENERAL_CALL</a> = I2C_I2C_INTR_STAT_REG_R_GEN_CALL_Msk
<br />
 }</td></tr>
<tr class="memdesc:gab067c78f6839084ba44ddd5ffa375a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C interrupt source.  <a href="group___i2_c.html#gab067c78f6839084ba44ddd5ffa375a4c">More...</a><br /></td></tr>
<tr class="separator:gab067c78f6839084ba44ddd5ffa375a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f022606a4d9ca1dab3e377d0dbac6fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f022606a4d9ca1dab3e377d0dbac6fb"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5f022606a4d9ca1dab3e377d0dbac6fb">HW_I2C_DMA_TRANSFER</a> </td></tr>
<tr class="memdesc:ga5f022606a4d9ca1dab3e377d0dbac6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA transfer type. <br /></td></tr>
<tr class="separator:ga5f022606a4d9ca1dab3e377d0dbac6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae7c11da98b9e2a0b2ce5ac6e3d63d6bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae7c11da98b9e2a0b2ce5ac6e3d63d6bd">hw_i2c_init</a> (HW_I2C_ID id, const <a class="el" href="structi2c__config.html">i2c_config</a> *cfg)</td></tr>
<tr class="memdesc:gae7c11da98b9e2a0b2ce5ac6e3d63d6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize I2C controller.  <a href="#gae7c11da98b9e2a0b2ce5ac6e3d63d6bd">More...</a><br /></td></tr>
<tr class="separator:gae7c11da98b9e2a0b2ce5ac6e3d63d6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0281ad670c33606aa8c43f1de28674"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1b0281ad670c33606aa8c43f1de28674">hw_i2c_configure</a> (HW_I2C_ID id, const <a class="el" href="structi2c__config.html">i2c_config</a> *cfg)</td></tr>
<tr class="memdesc:ga1b0281ad670c33606aa8c43f1de28674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure I2C controller.  <a href="#ga1b0281ad670c33606aa8c43f1de28674">More...</a><br /></td></tr>
<tr class="separator:ga1b0281ad670c33606aa8c43f1de28674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82a011a3f9d9dc66c9aeacf33b9b6956"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga82a011a3f9d9dc66c9aeacf33b9b6956">hw_i2c_enable</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga82a011a3f9d9dc66c9aeacf33b9b6956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable I2C controller.  <a href="#ga82a011a3f9d9dc66c9aeacf33b9b6956">More...</a><br /></td></tr>
<tr class="separator:ga82a011a3f9d9dc66c9aeacf33b9b6956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80479ba4cd73e3d97aa89e5cd00a89ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga80479ba4cd73e3d97aa89e5cd00a89ba">hw_i2c_disable</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga80479ba4cd73e3d97aa89e5cd00a89ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable I2C controller.  <a href="#ga80479ba4cd73e3d97aa89e5cd00a89ba">More...</a><br /></td></tr>
<tr class="separator:ga80479ba4cd73e3d97aa89e5cd00a89ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2d7f4cfef97ba3d146947ebf68e7dc"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1b2d7f4cfef97ba3d146947ebf68e7dc">hw_i2c_get_enable_status</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga1b2d7f4cfef97ba3d146947ebf68e7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C Controller Enable status.  <a href="#ga1b2d7f4cfef97ba3d146947ebf68e7dc">More...</a><br /></td></tr>
<tr class="separator:ga1b2d7f4cfef97ba3d146947ebf68e7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5944b69ca4fc9f378ca3c3f7f6740c80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5944b69ca4fc9f378ca3c3f7f6740c80">hw_i2c_register_int</a> (HW_I2C_ID id, <a class="el" href="group___i2_c.html#ga07fb0d97fcc29f7d55b1846927d7ad18">hw_i2c_interrupt_cb</a> cb, uint16_t mask)</td></tr>
<tr class="memdesc:ga5944b69ca4fc9f378ca3c3f7f6740c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register interrupt handler.  <a href="#ga5944b69ca4fc9f378ca3c3f7f6740c80">More...</a><br /></td></tr>
<tr class="separator:ga5944b69ca4fc9f378ca3c3f7f6740c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe2293421ca1305ff40efe8e0f3ff6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5fe2293421ca1305ff40efe8e0f3ff6b">hw_i2c_unregister_int</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga5fe2293421ca1305ff40efe8e0f3ff6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister interrupt handler.  <a href="#ga5fe2293421ca1305ff40efe8e0f3ff6b">More...</a><br /></td></tr>
<tr class="separator:ga5fe2293421ca1305ff40efe8e0f3ff6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc4ec9c80147b1c5b07b07374ea4165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabdc4ec9c80147b1c5b07b07374ea4165">hw_i2c_set_int_mask</a> (HW_I2C_ID id, uint16_t mask)</td></tr>
<tr class="memdesc:gabdc4ec9c80147b1c5b07b07374ea4165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bitmask of requested interrupt events.  <a href="#gabdc4ec9c80147b1c5b07b07374ea4165">More...</a><br /></td></tr>
<tr class="separator:gabdc4ec9c80147b1c5b07b07374ea4165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64869198710650bdfb5d0e0a268a2d8f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga64869198710650bdfb5d0e0a268a2d8f">hw_i2c_get_int_mask</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga64869198710650bdfb5d0e0a268a2d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current bitmask of requested interrupt events.  <a href="#ga64869198710650bdfb5d0e0a268a2d8f">More...</a><br /></td></tr>
<tr class="separator:ga64869198710650bdfb5d0e0a268a2d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf63bba29c86dfdcaa5a5b4dab4ca578c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf63bba29c86dfdcaa5a5b4dab4ca578c">hw_i2c_set_mode</a> (HW_I2C_ID id, <a class="el" href="group___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">HW_I2C_MODE</a> mode)</td></tr>
<tr class="memdesc:gaf63bba29c86dfdcaa5a5b4dab4ca578c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C controller mode.  <a href="#gaf63bba29c86dfdcaa5a5b4dab4ca578c">More...</a><br /></td></tr>
<tr class="separator:gaf63bba29c86dfdcaa5a5b4dab4ca578c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bdfaf9ff07fac66bbb55ba01610c563"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9bdfaf9ff07fac66bbb55ba01610c563">hw_i2c_set_speed</a> (HW_I2C_ID id, <a class="el" href="group___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">HW_I2C_SPEED</a> speed)</td></tr>
<tr class="memdesc:ga9bdfaf9ff07fac66bbb55ba01610c563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C interface bus speed.  <a href="#ga9bdfaf9ff07fac66bbb55ba01610c563">More...</a><br /></td></tr>
<tr class="separator:ga9bdfaf9ff07fac66bbb55ba01610c563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432451bec181e842e71e662bed4de2f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga432451bec181e842e71e662bed4de2f9">hw_i2c_set_restart_enabled</a> (HW_I2C_ID id, bool enabled)</td></tr>
<tr class="memdesc:ga432451bec181e842e71e662bed4de2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether RESTART conditions may be sent when acting as master.  <a href="#ga432451bec181e842e71e662bed4de2f9">More...</a><br /></td></tr>
<tr class="separator:ga432451bec181e842e71e662bed4de2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab978e1a7e0fee3b0fbfbd2981cfe8f69"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab978e1a7e0fee3b0fbfbd2981cfe8f69">hw_i2c_set_general_call_enabled</a> (HW_I2C_ID id, bool enabled)</td></tr>
<tr class="memdesc:gab978e1a7e0fee3b0fbfbd2981cfe8f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether General Call should be used to address slaves.  <a href="#gab978e1a7e0fee3b0fbfbd2981cfe8f69">More...</a><br /></td></tr>
<tr class="separator:gab978e1a7e0fee3b0fbfbd2981cfe8f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0388ddeca3fec983be641d07b391fed6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0388ddeca3fec983be641d07b391fed6">hw_i2c_set_target_addressing_mode</a> (HW_I2C_ID id, <a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> addr_mode)</td></tr>
<tr class="memdesc:ga0388ddeca3fec983be641d07b391fed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target slave addressing mode in master mode.  <a href="#ga0388ddeca3fec983be641d07b391fed6">More...</a><br /></td></tr>
<tr class="separator:ga0388ddeca3fec983be641d07b391fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46869820e9e4693e008fdbe7d5a759ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga46869820e9e4693e008fdbe7d5a759ab">hw_i2c_set_target_address</a> (HW_I2C_ID id, uint16_t address)</td></tr>
<tr class="memdesc:ga46869820e9e4693e008fdbe7d5a759ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target slave address in master mode.  <a href="#ga46869820e9e4693e008fdbe7d5a759ab">More...</a><br /></td></tr>
<tr class="separator:ga46869820e9e4693e008fdbe7d5a759ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50c9ac1702377a447d4419cf6cf62ad2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga50c9ac1702377a447d4419cf6cf62ad2">hw_i2c_set_slave_addressing_mode</a> (HW_I2C_ID id, <a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> addr_mode)</td></tr>
<tr class="memdesc:ga50c9ac1702377a447d4419cf6cf62ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slave addressing mode in slave mode.  <a href="#ga50c9ac1702377a447d4419cf6cf62ad2">More...</a><br /></td></tr>
<tr class="separator:ga50c9ac1702377a447d4419cf6cf62ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc372939f7490beb7fd188ee7d6e94a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5dc372939f7490beb7fd188ee7d6e94a">hw_i2c_set_slave_address</a> (HW_I2C_ID id, uint16_t address)</td></tr>
<tr class="memdesc:ga5dc372939f7490beb7fd188ee7d6e94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slave address in slave mode.  <a href="#ga5dc372939f7490beb7fd188ee7d6e94a">More...</a><br /></td></tr>
<tr class="separator:ga5dc372939f7490beb7fd188ee7d6e94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6120c8fbc93ec93b13d997b050527953"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga6120c8fbc93ec93b13d997b050527953">hw_i2c_set_general_call_ack_enabled</a> (HW_I2C_ID id, bool ack)</td></tr>
<tr class="memdesc:ga6120c8fbc93ec93b13d997b050527953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set support for general call acknowledgment.  <a href="#ga6120c8fbc93ec93b13d997b050527953">More...</a><br /></td></tr>
<tr class="separator:ga6120c8fbc93ec93b13d997b050527953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a29630b78ef7e94a3392bde6e15ca08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2a29630b78ef7e94a3392bde6e15ca08">hw_i2c_setup_master</a> (HW_I2C_ID id, <a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> addr_mode, uint16_t address)</td></tr>
<tr class="memdesc:ga2a29630b78ef7e94a3392bde6e15ca08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup controller for operation in master mode.  <a href="#ga2a29630b78ef7e94a3392bde6e15ca08">More...</a><br /></td></tr>
<tr class="separator:ga2a29630b78ef7e94a3392bde6e15ca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e9a3a4c278669d66a31a0abd444812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga93e9a3a4c278669d66a31a0abd444812">hw_i2c_set_slave_callback</a> (HW_I2C_ID id, <a class="el" href="group___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a> cb)</td></tr>
<tr class="memdesc:ga93e9a3a4c278669d66a31a0abd444812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup callback function for operation in slave mode.  <a href="#ga93e9a3a4c278669d66a31a0abd444812">More...</a><br /></td></tr>
<tr class="separator:ga93e9a3a4c278669d66a31a0abd444812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0490c49ca963197c4121a4340f4f868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa0490c49ca963197c4121a4340f4f868">hw_i2c_register_slave_dma_read_callback</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaa0490c49ca963197c4121a4340f4f868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register proper handling for DMA read in slave mode.  <a href="#gaa0490c49ca963197c4121a4340f4f868">More...</a><br /></td></tr>
<tr class="separator:gaa0490c49ca963197c4121a4340f4f868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb7542e60f661193ed1fc82df545586"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabfb7542e60f661193ed1fc82df545586">hw_i2c_setup_slave</a> (HW_I2C_ID id, <a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a> addr_mode, uint16_t address, <a class="el" href="group___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a> cb)</td></tr>
<tr class="memdesc:gabfb7542e60f661193ed1fc82df545586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup controller for operation in slave mode.  <a href="#gabfb7542e60f661193ed1fc82df545586">More...</a><br /></td></tr>
<tr class="separator:gabfb7542e60f661193ed1fc82df545586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30441771da1c28b94ae8431a4d78679"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf30441771da1c28b94ae8431a4d78679">hw_i2c_is_master_busy</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaf30441771da1c28b94ae8431a4d78679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if controller is busy when operating in master mode.  <a href="#gaf30441771da1c28b94ae8431a4d78679">More...</a><br /></td></tr>
<tr class="separator:gaf30441771da1c28b94ae8431a4d78679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b4bcc19e9ba40ea7cd2e997dba614d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga24b4bcc19e9ba40ea7cd2e997dba614d">hw_i2c_is_slave_busy</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga24b4bcc19e9ba40ea7cd2e997dba614d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if controller is busy when operating in slave mode.  <a href="#ga24b4bcc19e9ba40ea7cd2e997dba614d">More...</a><br /></td></tr>
<tr class="separator:ga24b4bcc19e9ba40ea7cd2e997dba614d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa999239bcb461c572e0ac814b25498"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2aa999239bcb461c572e0ac814b25498">hw_i2c_controler_is_busy</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga2aa999239bcb461c572e0ac814b25498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check controller activity.  <a href="#ga2aa999239bcb461c572e0ac814b25498">More...</a><br /></td></tr>
<tr class="separator:ga2aa999239bcb461c572e0ac814b25498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed369fc01e203de3f7ced1b2fa38d8e0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaed369fc01e203de3f7ced1b2fa38d8e0">hw_i2c_is_tx_fifo_empty</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaed369fc01e203de3f7ced1b2fa38d8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TX FIFO queue is empty.  <a href="#gaed369fc01e203de3f7ced1b2fa38d8e0">More...</a><br /></td></tr>
<tr class="separator:gaed369fc01e203de3f7ced1b2fa38d8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eedecd2ed65bbd89dacf12fa0d7d7b7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0eedecd2ed65bbd89dacf12fa0d7d7b7">hw_i2c_is_tx_fifo_not_full</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga0eedecd2ed65bbd89dacf12fa0d7d7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TX FIFO is not full.  <a href="#ga0eedecd2ed65bbd89dacf12fa0d7d7b7">More...</a><br /></td></tr>
<tr class="separator:ga0eedecd2ed65bbd89dacf12fa0d7d7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5a7915513efaa3e52692fa8f4bf6c9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaef5a7915513efaa3e52692fa8f4bf6c9">hw_i2c_is_rx_fifo_full</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaef5a7915513efaa3e52692fa8f4bf6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if RX FIFO queue is full.  <a href="#gaef5a7915513efaa3e52692fa8f4bf6c9">More...</a><br /></td></tr>
<tr class="separator:gaef5a7915513efaa3e52692fa8f4bf6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab88fcd552fac7c8308072d8ced16d32e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab88fcd552fac7c8308072d8ced16d32e">hw_i2c_is_rx_fifo_not_empty</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gab88fcd552fac7c8308072d8ced16d32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if RX FIFO is not empty.  <a href="#gab88fcd552fac7c8308072d8ced16d32e">More...</a><br /></td></tr>
<tr class="separator:gab88fcd552fac7c8308072d8ced16d32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad33312aeb9c615b1d8f47f5d9afa9433"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad33312aeb9c615b1d8f47f5d9afa9433">hw_i2c_write_byte</a> (HW_I2C_ID id, uint8_t byte)</td></tr>
<tr class="memdesc:gad33312aeb9c615b1d8f47f5d9afa9433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write single byte into TX FIFO.  <a href="#gad33312aeb9c615b1d8f47f5d9afa9433">More...</a><br /></td></tr>
<tr class="separator:gad33312aeb9c615b1d8f47f5d9afa9433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa38e4a5363f57d5503e2207401f6e6c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa38e4a5363f57d5503e2207401f6e6c0">hw_i2c_write_buffer</a> (HW_I2C_ID id, const uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, bool wait_for_stop)</td></tr>
<tr class="memdesc:gaa38e4a5363f57d5503e2207401f6e6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes on I2C bus.  <a href="#gaa38e4a5363f57d5503e2207401f6e6c0">More...</a><br /></td></tr>
<tr class="separator:gaa38e4a5363f57d5503e2207401f6e6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e5e57db2f2b5eafe39c3efc2a752f09"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2e5e57db2f2b5eafe39c3efc2a752f09">hw_i2c_write_buffer_sync</a> (HW_I2C_ID id, const uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> *abrt_code, uint32_t flags)</td></tr>
<tr class="memdesc:ga2e5e57db2f2b5eafe39c3efc2a752f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes to I2C slave synchronously.  <a href="#ga2e5e57db2f2b5eafe39c3efc2a752f09">More...</a><br /></td></tr>
<tr class="separator:ga2e5e57db2f2b5eafe39c3efc2a752f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f644c258dfd1dd0c3c5df464733d21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf4f644c258dfd1dd0c3c5df464733d21">hw_i2c_write_buffer_async</a> (HW_I2C_ID id, const uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:gaf4f644c258dfd1dd0c3c5df464733d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes to I2C slave asynchronously.  <a href="#gaf4f644c258dfd1dd0c3c5df464733d21">More...</a><br /></td></tr>
<tr class="separator:gaf4f644c258dfd1dd0c3c5df464733d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f29f4ad9944c9965e0a1b14d0d8f037"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0f29f4ad9944c9965e0a1b14d0d8f037">hw_i2c_read_byte_trigger</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga0f29f4ad9944c9965e0a1b14d0d8f037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate reading from I2C bus.  <a href="#ga0f29f4ad9944c9965e0a1b14d0d8f037">More...</a><br /></td></tr>
<tr class="separator:ga0f29f4ad9944c9965e0a1b14d0d8f037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f288da9f5113c3484de597bd18d0fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gae9f288da9f5113c3484de597bd18d0fb">hw_i2c_read_buffer</a> (HW_I2C_ID id, uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:gae9f288da9f5113c3484de597bd18d0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C bus.  <a href="#gae9f288da9f5113c3484de597bd18d0fb">More...</a><br /></td></tr>
<tr class="separator:gae9f288da9f5113c3484de597bd18d0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18b3a881d304cb070b22d5b5eda821c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa18b3a881d304cb070b22d5b5eda821c">hw_i2c_read_buffer_sync</a> (HW_I2C_ID id, uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> *abrt_code, uint32_t flags)</td></tr>
<tr class="memdesc:gaa18b3a881d304cb070b22d5b5eda821c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C slave synchronously.  <a href="#gaa18b3a881d304cb070b22d5b5eda821c">More...</a><br /></td></tr>
<tr class="separator:gaa18b3a881d304cb070b22d5b5eda821c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7bb04ff5cdba25f0a1b4076cb36f44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaad7bb04ff5cdba25f0a1b4076cb36f44">hw_i2c_read_buffer_async</a> (HW_I2C_ID id, uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:gaad7bb04ff5cdba25f0a1b4076cb36f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C slave asynchronously.  <a href="#gaad7bb04ff5cdba25f0a1b4076cb36f44">More...</a><br /></td></tr>
<tr class="separator:gaad7bb04ff5cdba25f0a1b4076cb36f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427b041327ec43abc52c7f6d74a739e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga427b041327ec43abc52c7f6d74a739e7">hw_i2c_write_then_read_async</a> (HW_I2C_ID id, const uint8_t *w_data, uint16_t w_len, uint8_t *r_data, uint16_t r_len, <a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, uint32_t flags)</td></tr>
<tr class="memdesc:ga427b041327ec43abc52c7f6d74a739e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write then read multiple bytes from I2C slave.  <a href="#ga427b041327ec43abc52c7f6d74a739e7">More...</a><br /></td></tr>
<tr class="separator:ga427b041327ec43abc52c7f6d74a739e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec0396e8e97ff60ea65a1b21f719a537"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaec0396e8e97ff60ea65a1b21f719a537">hw_i2c_read_byte</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaec0396e8e97ff60ea65a1b21f719a537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read single byte from RX FIFO.  <a href="#gaec0396e8e97ff60ea65a1b21f719a537">More...</a><br /></td></tr>
<tr class="separator:gaec0396e8e97ff60ea65a1b21f719a537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa004bd22bf58af31d9e6b2844c619aa0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaa004bd22bf58af31d9e6b2844c619aa0">hw_i2c_set_tx_fifo_threshold</a> (HW_I2C_ID id, uint8_t level)</td></tr>
<tr class="memdesc:gaa004bd22bf58af31d9e6b2844c619aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set threshold level on TX FIFO.  <a href="#gaa004bd22bf58af31d9e6b2844c619aa0">More...</a><br /></td></tr>
<tr class="separator:gaa004bd22bf58af31d9e6b2844c619aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad72171cb0442961ea902e37e7c5e4939"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad72171cb0442961ea902e37e7c5e4939">hw_i2c_set_rx_fifo_threshold</a> (HW_I2C_ID id, uint8_t level)</td></tr>
<tr class="memdesc:gad72171cb0442961ea902e37e7c5e4939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set threshold level on RX FIFO.  <a href="#gad72171cb0442961ea902e37e7c5e4939">More...</a><br /></td></tr>
<tr class="separator:gad72171cb0442961ea902e37e7c5e4939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga466a102e5faae601ed763b2ad79a1054"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga466a102e5faae601ed763b2ad79a1054">hw_i2c_get_tx_fifo_threshold</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga466a102e5faae601ed763b2ad79a1054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get threshold level on TX FIFO.  <a href="#ga466a102e5faae601ed763b2ad79a1054">More...</a><br /></td></tr>
<tr class="separator:ga466a102e5faae601ed763b2ad79a1054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd810391f18cd9f6103192c2b908858"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7cd810391f18cd9f6103192c2b908858">hw_i2c_get_rx_fifo_threshold</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga7cd810391f18cd9f6103192c2b908858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get threshold level on RX FIFO.  <a href="#ga7cd810391f18cd9f6103192c2b908858">More...</a><br /></td></tr>
<tr class="separator:ga7cd810391f18cd9f6103192c2b908858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eab0a9f3549687d1f4d7125f9843f1e"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0eab0a9f3549687d1f4d7125f9843f1e">hw_i2c_get_tx_fifo_level</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga0eab0a9f3549687d1f4d7125f9843f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes in TX FIFO.  <a href="#ga0eab0a9f3549687d1f4d7125f9843f1e">More...</a><br /></td></tr>
<tr class="separator:ga0eab0a9f3549687d1f4d7125f9843f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29025b52ee8315af67aac0b045cdd38f"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga29025b52ee8315af67aac0b045cdd38f">hw_i2c_get_rx_fifo_level</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga29025b52ee8315af67aac0b045cdd38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes in RX FIFO.  <a href="#ga29025b52ee8315af67aac0b045cdd38f">More...</a><br /></td></tr>
<tr class="separator:ga29025b52ee8315af67aac0b045cdd38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0656fb244146d46bd16747cf5e15f165"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga0656fb244146d46bd16747cf5e15f165">hw_i2c_get_int_state</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga0656fb244146d46bd16747cf5e15f165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interrupt state.  <a href="#ga0656fb244146d46bd16747cf5e15f165">More...</a><br /></td></tr>
<tr class="separator:ga0656fb244146d46bd16747cf5e15f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab03bd7ca04a701f33b66aa2b3b0d7a22"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gab03bd7ca04a701f33b66aa2b3b0d7a22">hw_i2c_get_raw_int_state</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gab03bd7ca04a701f33b66aa2b3b0d7a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get raw interrupt state.  <a href="#gab03bd7ca04a701f33b66aa2b3b0d7a22">More...</a><br /></td></tr>
<tr class="separator:gab03bd7ca04a701f33b66aa2b3b0d7a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b14e79a8d165eff8fb2cc847c65ce9e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga2b14e79a8d165eff8fb2cc847c65ce9e">hw_i2c_reset_int_all</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga2b14e79a8d165eff8fb2cc847c65ce9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all interrupt state.  <a href="#ga2b14e79a8d165eff8fb2cc847c65ce9e">More...</a><br /></td></tr>
<tr class="separator:ga2b14e79a8d165eff8fb2cc847c65ce9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf267935b7ff3c074066d10bd99713d8e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaf267935b7ff3c074066d10bd99713d8e">hw_i2c_reset_int_rx_underflow</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaf267935b7ff3c074066d10bd99713d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset RX_UNDERFLOW interrupt state.  <a href="#gaf267935b7ff3c074066d10bd99713d8e">More...</a><br /></td></tr>
<tr class="separator:gaf267935b7ff3c074066d10bd99713d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a57b8e5380c9f8f985a2a0ae5dbe59"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad6a57b8e5380c9f8f985a2a0ae5dbe59">hw_i2c_reset_int_rx_overflow</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gad6a57b8e5380c9f8f985a2a0ae5dbe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset RX_OVERFLOW interrupt state.  <a href="#gad6a57b8e5380c9f8f985a2a0ae5dbe59">More...</a><br /></td></tr>
<tr class="separator:gad6a57b8e5380c9f8f985a2a0ae5dbe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d29f713ecbf5783068b684a5c04ba2d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga5d29f713ecbf5783068b684a5c04ba2d">hw_i2c_reset_int_tx_overflow</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga5d29f713ecbf5783068b684a5c04ba2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset TX_OVERFLOW interrupt state.  <a href="#ga5d29f713ecbf5783068b684a5c04ba2d">More...</a><br /></td></tr>
<tr class="separator:ga5d29f713ecbf5783068b684a5c04ba2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44ea69864b0a6970d63b99380bf8f93"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac44ea69864b0a6970d63b99380bf8f93">hw_i2c_reset_int_read_request</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gac44ea69864b0a6970d63b99380bf8f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset READ_REQUEST interrupt state.  <a href="#gac44ea69864b0a6970d63b99380bf8f93">More...</a><br /></td></tr>
<tr class="separator:gac44ea69864b0a6970d63b99380bf8f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaed3a9d4978c2a8ee2e1d168b04a395"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gaeaed3a9d4978c2a8ee2e1d168b04a395">hw_i2c_reset_int_tx_abort</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaeaed3a9d4978c2a8ee2e1d168b04a395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset TX_ABORT interrupt state.  <a href="#gaeaed3a9d4978c2a8ee2e1d168b04a395">More...</a><br /></td></tr>
<tr class="separator:gaeaed3a9d4978c2a8ee2e1d168b04a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b2168342e046d55f8b211750b46cd81"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3b2168342e046d55f8b211750b46cd81">hw_i2c_reset_int_rx_done</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga3b2168342e046d55f8b211750b46cd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset RX_DONE interrupt state.  <a href="#ga3b2168342e046d55f8b211750b46cd81">More...</a><br /></td></tr>
<tr class="separator:ga3b2168342e046d55f8b211750b46cd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8b73acdd1ebd33d8a411baa011585d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7c8b73acdd1ebd33d8a411baa011585d">hw_i2c_reset_int_activity</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga7c8b73acdd1ebd33d8a411baa011585d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset ACTIVITY interrupt state.  <a href="#ga7c8b73acdd1ebd33d8a411baa011585d">More...</a><br /></td></tr>
<tr class="separator:ga7c8b73acdd1ebd33d8a411baa011585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72179055fb2e83647d1e833e92e83fc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga72179055fb2e83647d1e833e92e83fc1">hw_i2c_reset_int_start_detected</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga72179055fb2e83647d1e833e92e83fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset START_DETECTED interrupt state.  <a href="#ga72179055fb2e83647d1e833e92e83fc1">More...</a><br /></td></tr>
<tr class="separator:ga72179055fb2e83647d1e833e92e83fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ccb81694bfda61b3ba34aa7de8c87a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga3ccb81694bfda61b3ba34aa7de8c87a0">hw_i2c_reset_int_stop_detected</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga3ccb81694bfda61b3ba34aa7de8c87a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset STOP_DETECTED interrupt state.  <a href="#ga3ccb81694bfda61b3ba34aa7de8c87a0">More...</a><br /></td></tr>
<tr class="separator:ga3ccb81694bfda61b3ba34aa7de8c87a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24002178f107bb8ea8073a989b4158d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga24002178f107bb8ea8073a989b4158d3">hw_i2c_reset_int_gen_call</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga24002178f107bb8ea8073a989b4158d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset GENERAL_CALL interrupt state.  <a href="#ga24002178f107bb8ea8073a989b4158d3">More...</a><br /></td></tr>
<tr class="separator:ga24002178f107bb8ea8073a989b4158d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5ab1ac4f1e9e9ef313584b2a4043af"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga4b5ab1ac4f1e9e9ef313584b2a4043af">hw_i2c_get_abort_source</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga4b5ab1ac4f1e9e9ef313584b2a4043af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get abort source.  <a href="#ga4b5ab1ac4f1e9e9ef313584b2a4043af">More...</a><br /></td></tr>
<tr class="separator:ga4b5ab1ac4f1e9e9ef313584b2a4043af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ad999bd228aadca0aa05bb7f88814a5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga7ad999bd228aadca0aa05bb7f88814a5">hw_i2c_reset_abort_source</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:ga7ad999bd228aadca0aa05bb7f88814a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset abort source.  <a href="#ga7ad999bd228aadca0aa05bb7f88814a5">More...</a><br /></td></tr>
<tr class="separator:ga7ad999bd228aadca0aa05bb7f88814a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cc0a3c9911609ace89d8f278442a1b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6">hw_i2c_prepare_dma</a> (HW_I2C_ID id, uint8_t channel, uint16_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga5f022606a4d9ca1dab3e377d0dbac6fb">HW_I2C_DMA_TRANSFER</a> type, <a class="el" href="group___i2_c.html#ga1b531343651246138ece5034039dd912">hw_i2c_dma_completed_handler_cb</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:ga9cc0a3c9911609ace89d8f278442a1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares I2C DMA for transfer.  <a href="#ga9cc0a3c9911609ace89d8f278442a1b6">More...</a><br /></td></tr>
<tr class="separator:ga9cc0a3c9911609ace89d8f278442a1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14ca4479b9fafc7e6e90031fbf74951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gac14ca4479b9fafc7e6e90031fbf74951">hw_i2c_prepare_dma_ex</a> (HW_I2C_ID id, uint8_t channel, uint16_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga5f022606a4d9ca1dab3e377d0dbac6fb">HW_I2C_DMA_TRANSFER</a> type, <a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, bool notify_on_stop)</td></tr>
<tr class="memdesc:gac14ca4479b9fafc7e6e90031fbf74951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares I2C DMA for transfer (extended functionality)  <a href="#gac14ca4479b9fafc7e6e90031fbf74951">More...</a><br /></td></tr>
<tr class="separator:gac14ca4479b9fafc7e6e90031fbf74951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb617be9d4503854630dc6e6d545027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027">hw_i2c_dma_start</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gacfb617be9d4503854630dc6e6d545027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts DMA transfer.  <a href="#gacfb617be9d4503854630dc6e6d545027">More...</a><br /></td></tr>
<tr class="separator:gacfb617be9d4503854630dc6e6d545027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b47244f07da9a3da184003e5e43347b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga8b47244f07da9a3da184003e5e43347b">hw_i2c_write_buffer_dma</a> (HW_I2C_ID id, uint8_t channel, const uint16_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga1b531343651246138ece5034039dd912">hw_i2c_dma_completed_handler_cb</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:ga8b47244f07da9a3da184003e5e43347b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes on I2C bus using DMA.  <a href="#ga8b47244f07da9a3da184003e5e43347b">More...</a><br /></td></tr>
<tr class="separator:ga8b47244f07da9a3da184003e5e43347b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee56452f33bef51f845407353618174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#ga1ee56452f33bef51f845407353618174">hw_i2c_write_buffer_dma_ex</a> (HW_I2C_ID id, uint8_t channel, const uint16_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data, bool notify_on_stop)</td></tr>
<tr class="memdesc:ga1ee56452f33bef51f845407353618174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write multiple bytes on I2C bus using DMA (extended functionality)  <a href="#ga1ee56452f33bef51f845407353618174">More...</a><br /></td></tr>
<tr class="separator:ga1ee56452f33bef51f845407353618174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc6642b4873773299ad47e0d2cdba72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gabdc6642b4873773299ad47e0d2cdba72">hw_i2c_read_buffer_dma</a> (HW_I2C_ID id, uint8_t channel, uint16_t *data, uint16_t len, <a class="el" href="group___i2_c.html#ga1b531343651246138ece5034039dd912">hw_i2c_dma_completed_handler_cb</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:gabdc6642b4873773299ad47e0d2cdba72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C bus.  <a href="#gabdc6642b4873773299ad47e0d2cdba72">More...</a><br /></td></tr>
<tr class="separator:gabdc6642b4873773299ad47e0d2cdba72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad042df8d06ed54c7b3b0e50f802ec94f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c.html#gad042df8d06ed54c7b3b0e50f802ec94f">hw_i2c_read_buffer_dma_ex</a> (HW_I2C_ID id, uint8_t channel, uint8_t *data, uint16_t len, <a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a> cb, void *cb_data)</td></tr>
<tr class="memdesc:gad042df8d06ed54c7b3b0e50f802ec94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple bytes from I2C bus using DMA (extended functionality)  <a href="#gad042df8d06ed54c7b3b0e50f802ec94f">More...</a><br /></td></tr>
<tr class="separator:gad042df8d06ed54c7b3b0e50f802ec94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>I2C Controller. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaeccd5262bded02079206c0fed157b02e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_F_ADD_STOP&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add stop condition after read or write </p>

</div>
</div>
<a class="anchor" id="gadaf101cb30b8b19337faa1130b230b79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_F_NONE&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No special command for the operation </p>

</div>
</div>
<a class="anchor" id="ga561070559a39fe8aa62f839207c5e5b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_F_WAIT_FOR_STOP&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operation will wait until stop condition occurs </p>

</div>
</div>
<a class="anchor" id="gacf98ed2c050989a781b95443ca34ac61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_REG_GETF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((IBA(id)-&gt;reg##_REG &amp; (I2C_##reg##_REG_##field##_Msk)) &gt;&gt; (I2C_##reg##_REG_##field##_Pos))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of an I2C register field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>the I2C register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>the I2C register field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>HW_SPI_SET_RFIELD </dd></dl>

</div>
</div>
<a class="anchor" id="ga0805a21fb0272d1ba210f1b8406d9d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_I2C_REG_SETF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">IBA(<span class="keywordtype">id</span>)-&gt;reg##_REG = ((IBA(<span class="keywordtype">id</span>)-&gt;reg##_REG &amp; ~(I2C_##reg##_REG_##field##_Msk)) | \</div>
<div class="line">        ((I2C_##reg##_REG_##field##_Msk) &amp; ((val) &lt;&lt; (I2C_##reg##_REG_##field##_Pos))))</div>
</div><!-- fragment -->
<p>Write a value to an I2C register field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>the I2C register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>the I2C register field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gacf98ed2c050989a781b95443ca34ac61" title="Get the value of an I2C register field. ">HW_I2C_REG_GETF</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacdc0311455ca8686015d5c0a7751c9d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SETUP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">seq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                         <a class="code" href="group___i2_c.html#ga80479ba4cd73e3d97aa89e5cd00a89ba">\</a></div>
<div class="line"><a class="code" href="group___i2_c.html#ga80479ba4cd73e3d97aa89e5cd00a89ba">                hw_i2c_disable</a>(<span class="keywordtype">id</span>);  \</div>
<div class="line">                seq;                 <a class="code" href="group___i2_c.html#ga82a011a3f9d9dc66c9aeacf33b9b6956">\</a></div>
<div class="line"><a class="code" href="group___i2_c.html#ga82a011a3f9d9dc66c9aeacf33b9b6956">                hw_i2c_enable</a>(<span class="keywordtype">id</span>);   \</div>
<div class="line">        } <span class="keywordflow">while</span> (0);</div>
<div class="ttc" id="group___i2_c_html_ga82a011a3f9d9dc66c9aeacf33b9b6956"><div class="ttname"><a href="group___i2_c.html#ga82a011a3f9d9dc66c9aeacf33b9b6956">hw_i2c_enable</a></div><div class="ttdeci">static void hw_i2c_enable(HW_I2C_ID id)</div><div class="ttdoc">Enable I2C controller. </div><div class="ttdef"><b>Definition:</b> hw_i2c.h:325</div></div>
<div class="ttc" id="group___i2_c_html_ga80479ba4cd73e3d97aa89e5cd00a89ba"><div class="ttname"><a href="group___i2_c.html#ga80479ba4cd73e3d97aa89e5cd00a89ba">hw_i2c_disable</a></div><div class="ttdeci">static void hw_i2c_disable(HW_I2C_ID id)</div><div class="ttdoc">Disable I2C controller. </div><div class="ttdef"><b>Definition:</b> hw_i2c.h:336</div></div>
</div><!-- fragment -->
<p>Wrapper to perform controller setup. </p>
<p>Controller will be disabled, then any code given as <code>seq</code> is executed and controller is enabled again. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaa93c52dfb507e72c87250e55aeacd7fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_i2c_complete_cb) (HW_I2C_ID id, void *cb_data, uint16_t len, bool success)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback fired upon completion of read or write in non-blocking mode (FIFO or DMA) </p>
<p>This is a common callback type, which can be used with all non-deprecated API</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data passed by user along with callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes transferred. In case of write failure this number is equal to the number of bytes written to I2C TX FIFO until the failure occurred. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">success</td><td>operation status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b531343651246138ece5034039dd912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_i2c_dma_completed_handler_cb) (HW_I2C_ID id, void *cb_data, uint16_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback fired on DMA operation completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>user data passed to <a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a>, <a class="el" href="group___i2_c.html#ga8b47244f07da9a3da184003e5e43347b" title="Write multiple bytes on I2C bus using DMA. ">hw_i2c_write_buffer_dma()</a> or <a class="el" href="group___i2_c.html#gabdc6642b4873773299ad47e0d2cdba72" title="Read multiple bytes from I2C bus. ">hw_i2c_read_buffer_dma()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of data in buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>it is used by deprecated API, consider switching to API that uses <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa" title="Callback fired upon completion of read or write in non-blocking mode (FIFO or DMA) ...">hw_i2c_complete_cb</a></dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf953d4d6f6b9465dcc65d369b4bcb2bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_i2c_event_cb) (HW_I2C_ID id, <a class="el" href="group___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">HW_I2C_EVENT</a> event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback fired on event when in slave role. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>event identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga07fb0d97fcc29f7d55b1846927d7ad18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hw_i2c_interrupt_cb) (HW_I2C_ID id, uint16_t mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback fired on interrupt from I2C controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>interrupt events mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b3971a2fad1ecf0c9c617746ce6a3f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DEPRECATED void(* hw_i2c_read_handler_cb) (HW_I2C_ID id, void *cb_data, uint16_t len, bool success)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback fired on read complete in non-blocking mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>user data passed to <a class="el" href="group___i2_c.html#gae9f288da9f5113c3484de597bd18d0fb" title="Read multiple bytes from I2C bus. ">hw_i2c_read_buffer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of data in buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">success</td><td>operation status</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>consider switching to <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa" title="Callback fired upon completion of read or write in non-blocking mode (FIFO or DMA) ...">hw_i2c_complete_cb</a>, which has the same prototype</dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga98460606fa72baa2d9850adb16b2f836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DEPRECATED void(* hw_i2c_write_handler_cb) (HW_I2C_ID id, void *cb_data, uint16_t len, bool success)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback fired on write complete in non-blocking mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>user data passed to <a class="el" href="group___i2_c.html#gaa38e4a5363f57d5503e2207401f6e6c0" title="Write multiple bytes on I2C bus. ">hw_i2c_write_buffer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of data in buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">success</td><td>operation status</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>consider switching to <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa" title="Callback fired upon completion of read or write in non-blocking mode (FIFO or DMA) ...">hw_i2c_complete_cb</a>, which has the same prototype</dd></dl>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaf7ef8a80c9c6e53c3edf28cc5bf2007e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C abort source. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eae82067c1b8c3ff8ebc74186a9c0ea898"></a>HW_I2C_ABORT_NONE&#160;</td><td class="fielddoc">
<p>no abort occured </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea339c3cf6463507009210a912d59643fe"></a>HW_I2C_ABORT_7B_ADDR_NO_ACK&#160;</td><td class="fielddoc">
<p>address byte of 7-bit address was not acknowledged by any slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eadcf4555266b2cf92da1855d4074188a1"></a>HW_I2C_ABORT_10B_ADDR1_NO_ACK&#160;</td><td class="fielddoc">
<p>1st address byte of the 10-bit address was not acknowledged by any slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf8e8a6cca5c2eea4f3cf52908d764fc3"></a>HW_I2C_ABORT_10B_ADDR2_NO_ACK&#160;</td><td class="fielddoc">
<p>2nd address byte of the 10-bit address was not acknowledged by any slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea89ed5978c4fe2387710c2bb37741eeda"></a>HW_I2C_ABORT_TX_DATA_NO_ACK&#160;</td><td class="fielddoc">
<p>data were not acknowledged by slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eab2998a68ea7a4125b36ee1f7535c1e35"></a>HW_I2C_ABORT_GENERAL_CALL_NO_ACK&#160;</td><td class="fielddoc">
<p>General Call sent but no slave acknowledged </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eacba5b0d9fea9fef11005edcf89189979"></a>HW_I2C_ABORT_GENERAL_CALL_READ&#160;</td><td class="fielddoc">
<p>trying to read from bus after General Call </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaead3321ef58dce6a681f2060dd3884de"></a>HW_I2C_ABORT_START_BYTE_ACK&#160;</td><td class="fielddoc">
<p>START condition acknowledged by slave </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea193c3b94ff14a9ddb921b9fbfbc07983"></a>HW_I2C_ABORT_10B_READ_NO_RESTART&#160;</td><td class="fielddoc">
<p>read command in 10-bit addressing mode with RESTART disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eabd08dc012bed51af07820d453f45dd2e"></a>HW_I2C_ABORT_MASTER_DISABLED&#160;</td><td class="fielddoc">
<p>master operation initiated with master mode disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf37422d631a97547825d6b2106f20b5b"></a>HW_I2C_ABORT_ARBITRATION_LOST&#160;</td><td class="fielddoc">
<p>bus arbitration lost </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eaf579d26d06ff5b00ddd0061070fbbdc2"></a>HW_I2C_ABORT_SLAVE_FLUSH_TX_FIFO&#160;</td><td class="fielddoc">
<p>(slave mode) request for data with data already in TX FIFO - used to flush data in TX FIFO </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea1dc300a69352c4a42cd130a030ad4624"></a>HW_I2C_ABORT_SLAVE_ARBITRATION_LOST&#160;</td><td class="fielddoc">
<p>(slave mode) bus lost when transmitting to master </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007ea1fe3909020f346dc4aba68abd07e9498"></a>HW_I2C_ABORT_SLAVE_IN_TX&#160;</td><td class="fielddoc">
<p>(slave mode) request for data replied with read request </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf7ef8a80c9c6e53c3edf28cc5bf2007eada4e3b7ea6a617303cff16354cb9ead1"></a>HW_I2C_ABORT_SW_ERROR&#160;</td><td class="fielddoc">
<p>abort due to software error </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8c4b473a8fcb034aaabd8d2c7cf9c6bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C addressing mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga8c4b473a8fcb034aaabd8d2c7cf9c6bdae223953fbec142796f36014e08490afb"></a>HW_I2C_ADDRESSING_7B&#160;</td><td class="fielddoc">
<p>7-bit addressing </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8c4b473a8fcb034aaabd8d2c7cf9c6bdab40023bfb7104ee30683a2377246892e"></a>HW_I2C_ADDRESSING_10B&#160;</td><td class="fielddoc">
<p>10-bit addressing </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga67f970897e2e55be317fcae7f01bdf1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga67f970897e2e55be317fcae7f01bdf1f">HW_I2C_EVENT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback events when working as slave. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1fac5b1bfd3ab06735b76bbdd7e731afacb"></a>HW_I2C_EVENT_READ_REQUEST&#160;</td><td class="fielddoc">
<p>Data read request from master </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1fae3a61cfca95b35f79a38ded155f8d896"></a>HW_I2C_EVENT_DATA_READY&#160;</td><td class="fielddoc">
<p>Data written by master </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1fa5ff2bf612fd676b74c4477d65cb4644b"></a>HW_I2C_EVENT_TX_ABORT&#160;</td><td class="fielddoc">
<p>TX FIFO abort </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1fa556ed33f8390ad37fbe8505db1fd45ae"></a>HW_I2C_EVENT_RX_OVERFLOW&#160;</td><td class="fielddoc">
<p>RX FIFO overflow, some data are lost </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga67f970897e2e55be317fcae7f01bdf1faf1ab08c136ac9364cf922be55da999fa"></a>HW_I2C_EVENT_INVALID&#160;</td><td class="fielddoc">
<p>Invalid event </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab067c78f6839084ba44ddd5ffa375a4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gab067c78f6839084ba44ddd5ffa375a4c">HW_I2C_INT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C interrupt source. </p>
<p>Can be used as bitmask. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca61baec49ed26f10abe66c8d0132ea189"></a>HW_I2C_INT_RX_UNDERFLOW&#160;</td><td class="fielddoc">
<p>attempt to read from empty RX FIFO has been made </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4cafcd7b0583a6b99d8854fa2909ec90c4c"></a>HW_I2C_INT_RX_OVERFLOW&#160;</td><td class="fielddoc">
<p>RX FIFO is full but new data are incoming and being discarded </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca8acaa4d17886b481f05246d3d4ae818e"></a>HW_I2C_INT_RX_FULL&#160;</td><td class="fielddoc">
<p>RX FIFO level is equal or above threshold set by <a class="el" href="group___i2_c.html#gad72171cb0442961ea902e37e7c5e4939" title="Set threshold level on RX FIFO. ">hw_i2c_set_rx_fifo_threshold()</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca543a0b0fb421fb098f3ccc80d42af4c2"></a>HW_I2C_INT_TX_OVERFLOW&#160;</td><td class="fielddoc">
<p>attempt to write to TX FIFO which is already full </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4cacdeff6bd5f88c566caefda8ba7d7f237"></a>HW_I2C_INT_TX_EMPTY&#160;</td><td class="fielddoc">
<p>TX FIFO level is equal or below threshold set by <a class="el" href="group___i2_c.html#gaa004bd22bf58af31d9e6b2844c619aa0" title="Set threshold level on TX FIFO. ">hw_i2c_set_tx_fifo_threshold()</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca39b828d633959d80010b47553d42948c"></a>HW_I2C_INT_READ_REQUEST&#160;</td><td class="fielddoc">
<p>(slave only) I2C master attempts to read data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4caca667f9f8631fd98f1f0a11fc4f0c868"></a>HW_I2C_INT_TX_ABORT&#160;</td><td class="fielddoc">
<p>TX cannot be completed </p><dl class="section see"><dt>See also</dt><dd>hw_get_abort_source() </dd>
<dd>
<a class="el" href="group___i2_c.html#ga7ad999bd228aadca0aa05bb7f88814a5" title="Reset abort source. ">hw_i2c_reset_abort_source()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca24025187688fc359ddc30f95b538097e"></a>HW_I2C_INT_RX_DONE&#160;</td><td class="fielddoc">
<p>(slave only) I2C master did not acknowledge transmitted byte </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca191c65c506005d2c2a1c28bfc99797a5"></a>HW_I2C_INT_ACTIVITY&#160;</td><td class="fielddoc">
<p>any I2C activity occurred </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4caa20a13e8d583e0c25a109cf3fd5e5d3a"></a>HW_I2C_INT_STOP_DETECTED&#160;</td><td class="fielddoc">
<p>STOP condition occurred </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4caf4c788f651f281694564881e03e1f450"></a>HW_I2C_INT_START_DETECTED&#160;</td><td class="fielddoc">
<p>START/RESTART condition occurred </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggab067c78f6839084ba44ddd5ffa375a4ca57b24b5967091179674f5cfc437eb127"></a>HW_I2C_INT_GENERAL_CALL&#160;</td><td class="fielddoc">
<p>(slave only) General Call address received </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gadf7ffb060052bb9ac0c167835afcc910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">HW_I2C_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C role. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadf7ffb060052bb9ac0c167835afcc910a70929eedc6ae4fba724cc57c4ece19e6"></a>HW_I2C_MODE_MASTER&#160;</td><td class="fielddoc">
<p>master role </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadf7ffb060052bb9ac0c167835afcc910adf9acb461b0239156a18bbe5280bf4d4"></a>HW_I2C_MODE_SLAVE&#160;</td><td class="fielddoc">
<p>slave role </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4cbcaaa7663a2cbba9418cdb5aab66d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">HW_I2C_SPEED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C interface speed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4cbcaaa7663a2cbba9418cdb5aab66d9ae56e52ba2b3aaceccff7e09c8b59c93e"></a>HW_I2C_SPEED_STANDARD&#160;</td><td class="fielddoc">
<p>100kb/s </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4cbcaaa7663a2cbba9418cdb5aab66d9a57993addaedcd03090ab60a2b7759f36"></a>HW_I2C_SPEED_FAST&#160;</td><td class="fielddoc">
<p>400kb/s </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1b0281ad670c33606aa8c43f1de28674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_configure </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi2c__config.html">i2c_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure I2C controller. </p>
<p>Shortcut to configure most common I2C controller parameters. If <code>cfg</code> is NULL, this function does nothing.</p>
<dl class="section note"><dt>Note</dt><dd>Even with <code>cfg</code> set to NULL, I2C clock (SCL) will be configured using default values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2aa999239bcb461c572e0ac814b25498"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hw_i2c_controler_is_busy </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check controller activity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>busy status </dd></dl>

</div>
</div>
<a class="anchor" id="ga80479ba4cd73e3d97aa89e5cd00a89ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_disable </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable I2C controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacfb617be9d4503854630dc6e6d545027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_dma_start </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts DMA transfer. </p>
<p>Should be called once I2C DMA is setup using <a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a>. Once started, DMA transfer will only finish once previously specified number of bytes is read or written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga82a011a3f9d9dc66c9aeacf33b9b6956"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_enable </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable I2C controller. </p>
<p><a class="el" href="group___i2_c.html#gae7c11da98b9e2a0b2ce5ac6e3d63d6bd" title="Initialize I2C controller. ">hw_i2c_init()</a> shall be called before enabling I2C controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b5ab1ac4f1e9e9ef313584b2a4043af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t hw_i2c_get_abort_source </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get abort source. </p>
<p>This can be used to retrieve source of TX_ABORT interrupt. TX FIFO is flushed and remains in this state until cleared using <a class="el" href="group___i2_c.html#ga7ad999bd228aadca0aa05bb7f88814a5" title="Reset abort source. ">hw_i2c_reset_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>abort source bitmask</dd></dl>
<dl class="section see"><dt>See also</dt><dd>I2C_ABORT_SOURCE </dd>
<dd>
<a class="el" href="group___i2_c.html#ga7ad999bd228aadca0aa05bb7f88814a5" title="Reset abort source. ">hw_i2c_reset_abort_source</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b2d7f4cfef97ba3d146947ebf68e7dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t hw_i2c_get_enable_status </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get I2C Controller Enable status. </p>
<dl class="section return"><dt>Returns</dt><dd>The contents of the I2C_ENABLE_STATUS_REG </dd></dl>

</div>
</div>
<a class="anchor" id="ga64869198710650bdfb5d0e0a268a2d8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t hw_i2c_get_int_mask </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current bitmask of requested interrupt events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>current bitmask</dd></dl>
<dl class="section see"><dt>See also</dt><dd>I2C_INT </dd></dl>

</div>
</div>
<a class="anchor" id="ga0656fb244146d46bd16747cf5e15f165"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t hw_i2c_get_int_state </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get interrupt state. </p>
<p>Interrupt state returned includes only interrupts which are not masked. For raw interrupt status use <a class="el" href="group___i2_c.html#gab03bd7ca04a701f33b66aa2b3b0d7a22" title="Get raw interrupt state. ">hw_i2c_get_raw_int_state()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interrupt state bitmask</dd></dl>
<dl class="section see"><dt>See also</dt><dd>I2C_INT </dd>
<dd>
<a class="el" href="group___i2_c.html#gab03bd7ca04a701f33b66aa2b3b0d7a22" title="Get raw interrupt state. ">hw_i2c_get_raw_int_state</a> </dd>
<dd>
hw_i2c_set_intr_mask </dd></dl>

</div>
</div>
<a class="anchor" id="gab03bd7ca04a701f33b66aa2b3b0d7a22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t hw_i2c_get_raw_int_state </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get raw interrupt state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interrupt state bitmask</dd></dl>
<dl class="section see"><dt>See also</dt><dd>I2C_INT </dd>
<dd>
<a class="el" href="group___i2_c.html#ga0656fb244146d46bd16747cf5e15f165" title="Get interrupt state. ">hw_i2c_get_int_state</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga29025b52ee8315af67aac0b045cdd38f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_i2c_get_rx_fifo_level </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of bytes in RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ga7cd810391f18cd9f6103192c2b908858"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_i2c_get_rx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get threshold level on RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0eab0a9f3549687d1f4d7125f9843f1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_i2c_get_tx_fifo_level </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of bytes in TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ga466a102e5faae601ed763b2ad79a1054"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_i2c_get_tx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get threshold level on TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae7c11da98b9e2a0b2ce5ac6e3d63d6bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_init </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi2c__config.html">i2c_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize I2C controller. </p>
<p>I2C controller is disabled, clock and interrupt for I2C component are enabled, all interrupts are masked though. <code>cfg</code> can be NULL if no configuration should be performed.</p>
<dl class="section note"><dt>Note</dt><dd>Even with <code>cfg</code> set to NULL, I2C clock (SCL) will be configured using default values.</dd>
<dd>
The I2C clock source is set to DIVN (16MHz, regardless of PLL or XTAL16M being used).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf30441771da1c28b94ae8431a4d78679"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hw_i2c_is_master_busy </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if controller is busy when operating in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>busy status </dd></dl>

</div>
</div>
<a class="anchor" id="gaef5a7915513efaa3e52692fa8f4bf6c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hw_i2c_is_rx_fifo_full </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if RX FIFO queue is full. </p>
<p>This function should be used to check if RX FIFO is filled, i.e. subsequent data read will be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RX FIFO full status </dd></dl>

</div>
</div>
<a class="anchor" id="gab88fcd552fac7c8308072d8ced16d32e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hw_i2c_is_rx_fifo_not_empty </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if RX FIFO is not empty. </p>
<p>This function should be used to check if there are any data received in RX FIFO</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RX FIFO not empty status </dd></dl>

</div>
</div>
<a class="anchor" id="ga24b4bcc19e9ba40ea7cd2e997dba614d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hw_i2c_is_slave_busy </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if controller is busy when operating in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>busy status </dd></dl>

</div>
</div>
<a class="anchor" id="gaed369fc01e203de3f7ced1b2fa38d8e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hw_i2c_is_tx_fifo_empty </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if TX FIFO queue is empty. </p>
<p>This function should be used to check if all data written to TX FIFO were transmitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TX FIFO empty status </dd></dl>

</div>
</div>
<a class="anchor" id="ga0eedecd2ed65bbd89dacf12fa0d7d7b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hw_i2c_is_tx_fifo_not_full </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if TX FIFO is not full. </p>
<p>This function should be used to check if data can be written to TX FIFO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TX FIFO not full status </dd></dl>

</div>
</div>
<a class="anchor" id="ga9cc0a3c9911609ace89d8f278442a1b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_prepare_dma </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5f022606a4d9ca1dab3e377d0dbac6fb">HW_I2C_DMA_TRANSFER</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga1b531343651246138ece5034039dd912">hw_i2c_dma_completed_handler_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares I2C DMA for transfer. </p>
<p>Use <a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start()</a> to start actual data transfer.</p>
<p><code>channel</code> specifies either of channels in RX/TX pair used for transfer, i.e. channel=0|1 means channels 0 and 1 will be used, channel=2|3 means channels 2 and 3 will be used and so on. Once DMA is prepared, no other application should make changes to either of channels.</p>
<p><code>data</code> buffer elements are 16-bit wide, this high byte should be 0 for writing and discarded when reading.</p>
<p>Callback is fired once DMA transfer between buffer and RX/TX FIFOs is completed which means that there could still be activity on I2C bus. Application can check when transfer is completed using other means, i.e. STOP_DETECTED interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>buffer to read from or write to, depends on <code>type</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of transfer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for DMA transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac14ca4479b9fafc7e6e90031fbf74951"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_prepare_dma_ex </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga5f022606a4d9ca1dab3e377d0dbac6fb">HW_I2C_DMA_TRANSFER</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify_on_stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares I2C DMA for transfer (extended functionality) </p>
<p>This "extended functionality" variant of <a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a> adds the <code>notify_on_stop</code> parameter.</p>
<p>Use <a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start()</a> to start actual data transfer.</p>
<p><code>channel</code> specifies either of channels in RX/TX pair used for transfer, i.e. channel=0|1 means channels 0 and 1 will be used, channel=2|3 means channels 2 and 3 will be used and so on. Once DMA is prepared, no other application should make changes to either of channels.</p>
<p><code>data</code> buffer elements are 16-bit wide, this high byte should be 0 for writing and discarded when reading.</p>
<p>Callback is fired once DMA transfer between buffer and RX/TX FIFOs is completed which means that there could still be activity on I2C bus. Application can check when transfer is completed using other means, i.e. STOP_DETECTED interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>buffer to read from or write to, depends on <code>type</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of transfer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for DMA transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify_on_stop</td><td>indicate whether <code>cb</code> should be called when STOP is generated, or as soon as DMA finishes (like hw_i2c_prepare_dma)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae9f288da9f5113c3484de597bd18d0fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hw_i2c_read_buffer </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C bus. </p>
<p>This function will read multiple bytes from bus taking care of RX FIFO control. If callback is given, it works in non-blocking mode, otherwise it's a blocking call. Complete buffer has to be filled in order for call to complete. Failures should be checked and cleared by the caller.</p>
<p>This function changes interrupt handler status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Buffer for read data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function for non-blocking mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if <code>cb</code> is not NULL, this function registers an internal interrupt handler, which overrides any previously installed handler</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is deprecated. Consider using <a class="el" href="group___i2_c.html#gaa18b3a881d304cb070b22d5b5eda821c" title="Read multiple bytes from I2C slave synchronously. ">hw_i2c_read_buffer_sync()</a> or <a class="el" href="group___i2_c.html#gaad7bb04ff5cdba25f0a1b4076cb36f44" title="Read multiple bytes from I2C slave asynchronously. ">hw_i2c_read_buffer_async()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="gaad7bb04ff5cdba25f0a1b4076cb36f44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hw_i2c_read_buffer_async </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C slave asynchronously. </p>
<p>This function will read multiple bytes from bus taking care of RX FIFO control. This call is non-blocking and specified callback is fired upon completion, with the operation status. The operation completes when the complete buffer is filled, or in case of a failure. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___i2_c.html#ga4b5ab1ac4f1e9e9ef313584b2a4043af" title="Get abort source. ">hw_i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of the buffer where data are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be fired upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Must always be <a class="el" href="group___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function registers an internal interrupt handler, which overrides any previously installed handler.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga5944b69ca4fc9f378ca3c3f7f6740c80" title="Register interrupt handler. ">hw_i2c_register_int</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabdc6642b4873773299ad47e0d2cdba72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_read_buffer_dma </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga1b531343651246138ece5034039dd912">hw_i2c_dma_completed_handler_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C bus. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a> and <a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start()</a>. This can be used only in master role.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>buffer to put data read from I2C bus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for DMA transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad042df8d06ed54c7b3b0e50f802ec94f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_read_buffer_dma_ex </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C bus using DMA (extended functionality) </p>
<p>This "extended functionality" variant of <a class="el" href="group___i2_c.html#gae9f288da9f5113c3484de597bd18d0fb" title="Read multiple bytes from I2C bus. ">hw_i2c_read_buffer()</a> uses the common callback type, which provides a way to signal whether the read finished successfully.</p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#gac14ca4479b9fafc7e6e90031fbf74951" title="Prepares I2C DMA for transfer (extended functionality) ">hw_i2c_prepare_dma_ex()</a> and <a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>buffer to put data read from I2C bus </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for DMA transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gac14ca4479b9fafc7e6e90031fbf74951" title="Prepares I2C DMA for transfer (extended functionality) ">hw_i2c_prepare_dma_ex</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#gae9f288da9f5113c3484de597bd18d0fb" title="Read multiple bytes from I2C bus. ">hw_i2c_read_buffer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa18b3a881d304cb070b22d5b5eda821c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hw_i2c_read_buffer_sync </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> *&#160;</td>
          <td class="paramname"><em>abrt_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read multiple bytes from I2C slave synchronously. </p>
<p>This function will read multiple bytes from bus taking care of RX FIFO control. This call blocks until the operation completes. The operation completes when the complete buffer is filled, or in case of a failure. Failures are cleared by the function before returning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Address of the buffer where data are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">abrt_code</td><td>If not NULL, the status of the operation based on <a class="el" href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e" title="I2C abort source. ">HW_I2C_ABORT_SOURCE</a> enumeration will be stored here </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Must always be <a class="el" href="group___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode. </dd></dl>

</div>
</div>
<a class="anchor" id="gaec0396e8e97ff60ea65a1b21f719a537"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_i2c_read_byte </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read single byte from RX FIFO. </p>
<p>It is caller's responsibility to ensure there is data to read in RX FIFO before calling this function by checking either <a class="el" href="group___i2_c.html#ga29025b52ee8315af67aac0b045cdd38f" title="Get number of bytes in RX FIFO. ">hw_i2c_get_rx_fifo_level()</a> or hw_i2c_rx_fifo_not_empty().</p>
<p>This function can be used in both master and slave modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>read byte</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga29025b52ee8315af67aac0b045cdd38f" title="Get number of bytes in RX FIFO. ">hw_i2c_get_rx_fifo_level</a> </dd>
<dd>
hw_i2c_rx_fifo_not_empty </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f29f4ad9944c9965e0a1b14d0d8f037"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_read_byte_trigger </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiate reading from I2C bus. </p>
<p>No data is read via this call, only START/RESTART condition is generated on bus if required. Actual data is read by controller and put in RX FIFO which can be read using <a class="el" href="group___i2_c.html#gaec0396e8e97ff60ea65a1b21f719a537" title="Read single byte from RX FIFO. ">hw_i2c_read_byte()</a>.</p>
<p>This function should be only used when operating in master mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaec0396e8e97ff60ea65a1b21f719a537" title="Read single byte from RX FIFO. ">hw_i2c_read_byte</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5944b69ca4fc9f378ca3c3f7f6740c80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_register_int </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga07fb0d97fcc29f7d55b1846927d7ad18">hw_i2c_interrupt_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register interrupt handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>initial bitmask of requested interrupt events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gabdc4ec9c80147b1c5b07b07374ea4165" title="Set bitmask of requested interrupt events. ">hw_i2c_set_int_mask</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0490c49ca963197c4121a4340f4f868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_register_slave_dma_read_callback </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register proper handling for DMA read in slave mode. </p>
<p>This function must be called after DMA has been setup for reading in slave mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gad042df8d06ed54c7b3b0e50f802ec94f" title="Read multiple bytes from I2C bus using DMA (extended functionality) ">hw_i2c_read_buffer_dma_ex</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#gac14ca4479b9fafc7e6e90031fbf74951" title="Prepares I2C DMA for transfer (extended functionality) ">hw_i2c_prepare_dma_ex</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ad999bd228aadca0aa05bb7f88814a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_abort_source </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset abort source. </p>
<p>This clears TX_ABORT interrupt status and unlocks TX FIFO.</p>
<dl class="section note"><dt>Note</dt><dd>this is an alias for <a class="el" href="group___i2_c.html#gaeaed3a9d4978c2a8ee2e1d168b04a395" title="Reset TX_ABORT interrupt state. ">hw_i2c_reset_int_tx_abort()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>I2C_ABORT_SOURCE </dd>
<dd>
<a class="el" href="group___i2_c.html#gaeaed3a9d4978c2a8ee2e1d168b04a395" title="Reset TX_ABORT interrupt state. ">hw_i2c_reset_int_tx_abort</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c8b73acdd1ebd33d8a411baa011585d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_activity </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset ACTIVITY interrupt state. </p>
<p>Should be used to reset ACTIVITY interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b14e79a8d165eff8fb2cc847c65ce9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_all </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all interrupt state. </p>
<p>This does reset all interrupts which can be reset by software and TX_ABORT status.</p>
<dl class="section warning"><dt>Warning</dt><dd>Although this also clears TX_ABORT it does not reset flushed state on TX FIFO. This has </dd>
<dd>
to be cleared manually using <a class="el" href="group___i2_c.html#ga7ad999bd228aadca0aa05bb7f88814a5" title="Reset abort source. ">hw_i2c_reset_abort_source()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga7ad999bd228aadca0aa05bb7f88814a5" title="Reset abort source. ">hw_i2c_reset_abort_source</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga24002178f107bb8ea8073a989b4158d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_gen_call </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset GENERAL_CALL interrupt state. </p>
<p>Should be used to reset GENERAL_CALL interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac44ea69864b0a6970d63b99380bf8f93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_read_request </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset READ_REQUEST interrupt state. </p>
<p>Should be used to reset READ_REQUEST interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b2168342e046d55f8b211750b46cd81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_rx_done </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset RX_DONE interrupt state. </p>
<p>Should be used to reset RX_DONE interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad6a57b8e5380c9f8f985a2a0ae5dbe59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_rx_overflow </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset RX_OVERFLOW interrupt state. </p>
<p>Should be used to reset RX_OVERFLOW interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf267935b7ff3c074066d10bd99713d8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_rx_underflow </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset RX_UNDERFLOW interrupt state. </p>
<p>Should be used to reset RX_UNDERFLOW interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga72179055fb2e83647d1e833e92e83fc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_start_detected </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset START_DETECTED interrupt state. </p>
<p>Should be used to reset START_DETECTED interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3ccb81694bfda61b3ba34aa7de8c87a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_stop_detected </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset STOP_DETECTED interrupt state. </p>
<p>Should be used to reset STOP_DETECTED interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeaed3a9d4978c2a8ee2e1d168b04a395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_tx_abort </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset TX_ABORT interrupt state. </p>
<p>Should be used to reset TX_ABORT interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5d29f713ecbf5783068b684a5c04ba2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_reset_int_tx_overflow </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset TX_OVERFLOW interrupt state. </p>
<p>Should be used to reset TX_OVERFLOW interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6120c8fbc93ec93b13d997b050527953"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_general_call_ack_enabled </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set support for general call acknowledgment. </p>
<p>When enabled, controller will send ACK for general call address. This applies only to controller working in slave mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ack</td><td>acknowledgment status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab978e1a7e0fee3b0fbfbd2981cfe8f69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_general_call_enabled </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether General Call should be used to address slaves. </p>
<p>Can only be changed when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>General Call status to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabdc4ec9c80147b1c5b07b07374ea4165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_set_int_mask </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bitmask of requested interrupt events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>bitmask of requested interrupt events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>I2C_INT </dd></dl>

</div>
</div>
<a class="anchor" id="gaf63bba29c86dfdcaa5a5b4dab4ca578c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_mode </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gadf7ffb060052bb9ac0c167835afcc910">HW_I2C_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set I2C controller mode. </p>
<p>Can be only set when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga432451bec181e842e71e662bed4de2f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_restart_enabled </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether RESTART conditions may be sent when acting as master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>RESTART status to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad72171cb0442961ea902e37e7c5e4939"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_rx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set threshold level on RX FIFO. </p>
<p>An interrupt will be generated once number of entries in RX FIFO is greater than <code>level</code>. This cannot be set to value greater than HW_I2C_FIFO_DEPTH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5dc372939f7490beb7fd188ee7d6e94a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_slave_address </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set slave address in slave mode. </p>
<p>Can be only set when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga50c9ac1702377a447d4419cf6cf62ad2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_slave_addressing_mode </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set slave addressing mode in slave mode. </p>
<p>Can be only set when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga93e9a3a4c278669d66a31a0abd444812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_set_slave_callback </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup callback function for operation in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for events </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9bdfaf9ff07fac66bbb55ba01610c563"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_speed </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga4cbcaaa7663a2cbba9418cdb5aab66d9">HW_I2C_SPEED</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set I2C interface bus speed. </p>
<p>Can be only set when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>speed to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga46869820e9e4693e008fdbe7d5a759ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_target_address </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set target slave address in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0388ddeca3fec983be641d07b391fed6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_target_addressing_mode </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set target slave addressing mode in master mode. </p>
<p>Can only be changed when controller is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa004bd22bf58af31d9e6b2844c619aa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_set_tx_fifo_threshold </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set threshold level on TX FIFO. </p>
<p>An interrupt will be generated once number of entries in TX FIFO is less or equal to <code>level</code>. This cannot be set to value greater than HW_I2C_FIFO_DEPTH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2a29630b78ef7e94a3392bde6e15ca08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_setup_master </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup controller for operation in master mode. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#gaf63bba29c86dfdcaa5a5b4dab4ca578c" title="Set I2C controller mode. ">hw_i2c_set_mode()</a>, <a class="el" href="group___i2_c.html#ga0388ddeca3fec983be641d07b391fed6" title="Set target slave addressing mode in master mode. ">hw_i2c_set_target_addressing_mode()</a> and <a class="el" href="group___i2_c.html#ga46869820e9e4693e008fdbe7d5a759ab" title="Set target slave address in master mode. ">hw_i2c_set_target_address()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>target slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfb7542e60f661193ed1fc82df545586"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_setup_slave </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga8c4b473a8fcb034aaabd8d2c7cf9c6bd">HW_I2C_ADDRESSING</a>&#160;</td>
          <td class="paramname"><em>addr_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaf953d4d6f6b9465dcc65d369b4bcb2bd">hw_i2c_event_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup controller for operation in slave mode. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#gaf63bba29c86dfdcaa5a5b4dab4ca578c" title="Set I2C controller mode. ">hw_i2c_set_mode()</a>, <a class="el" href="group___i2_c.html#ga50c9ac1702377a447d4419cf6cf62ad2" title="Set slave addressing mode in slave mode. ">hw_i2c_set_slave_addressing_mode()</a> and <a class="el" href="group___i2_c.html#ga5dc372939f7490beb7fd188ee7d6e94a" title="Set slave address in slave mode. ">hw_i2c_set_slave_address()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>mode of addressing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>slave address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gaf63bba29c86dfdcaa5a5b4dab4ca578c" title="Set I2C controller mode. ">hw_i2c_set_mode</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#ga50c9ac1702377a447d4419cf6cf62ad2" title="Set slave addressing mode in slave mode. ">hw_i2c_set_slave_addressing_mode</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#ga5dc372939f7490beb7fd188ee7d6e94a" title="Set slave address in slave mode. ">hw_i2c_set_slave_address</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fe2293421ca1305ff40efe8e0f3ff6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_unregister_int </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister interrupt handler. </p>
<p>This function disables all I2C interrupts by masking them. In addition it clears any pending ones on the ARM core. The status of RAW_INTR_STAT_REG remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa38e4a5363f57d5503e2207401f6e6c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hw_i2c_write_buffer </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_for_stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes on I2C bus. </p>
<p>Writes array of data to a slave device on the I2C bus via TX FIFO. Without <code>cb</code> specified this call is blocking and the return value indicates whether the operation was successful or not. Otherwise call is non-blocking and specified callback is fired upon completion, with the operation status. Failures after blocking calls should be checked and cleared by the caller.</p>
<p>This function should be only used when operating in master mode.</p>
<p>This function changes interrupt handler status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for non-blocking mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_for_stop</td><td>true if <code>cb</code> should be execute after all data was transmitted and stop condition was detected false if callback should be fired as soon as last byte is written to TX FIFO. This allows providing of the next buffer to write in single transmission without generating additional stop/start conditions, however it could hide transmission failures if used for the last buffer, since a Tx failure may occur after writing the last byte to the Tx FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if <code>cb</code> is not NULL, this function registers an internal interrupt handler, which overrides any previously installed handler</dd>
<dd>
When calling the blocking verion under an OS, it is possible to have a Tx FIFO underrun which results in a STOP sequence, due to OS pre-emption.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is depricated. Consider using <a class="el" href="group___i2_c.html#ga2e5e57db2f2b5eafe39c3efc2a752f09" title="Write multiple bytes to I2C slave synchronously. ">hw_i2c_write_buffer_sync()</a> or <a class="el" href="group___i2_c.html#gaf4f644c258dfd1dd0c3c5df464733d21" title="Write multiple bytes to I2C slave asynchronously. ">hw_i2c_write_buffer_async()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4f644c258dfd1dd0c3c5df464733d21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hw_i2c_write_buffer_async </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes to I2C slave asynchronously. </p>
<p>Writes array of data to a slave device on the I2C bus via the TX FIFO. This call is non-blocking and specified callback is fired upon completion, with the operation status. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___i2_c.html#ga4b5ab1ac4f1e9e9ef313584b2a4043af" title="Get abort source. ">hw_i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be fired upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 The cb will be fired as soon as the last byte of data is written to the Tx FIFO. Possible Tx failure after this point must be checked by the caller. This flag can be used for consequtive calls where the transmission can resume without stop/start conditions in between.</p>
<p class="endtd"><a class="el" href="group___i2_c.html#ga561070559a39fe8aa62f839207c5e5b7">HW_I2C_F_WAIT_FOR_STOP</a><br />
 The function will return only after all bytes have been transmitted and a STOP condition has been generated. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function registers an internal interrupt handler, which overrides any previously installed handler.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga5944b69ca4fc9f378ca3c3f7f6740c80" title="Register interrupt handler. ">hw_i2c_register_int</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b47244f07da9a3da184003e5e43347b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_write_buffer_dma </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#ga1b531343651246138ece5034039dd912">hw_i2c_dma_completed_handler_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes on I2C bus using DMA. </p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma()</a> and <a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>buffer to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for DMA transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga9cc0a3c9911609ace89d8f278442a1b6" title="Prepares I2C DMA for transfer. ">hw_i2c_prepare_dma</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ee56452f33bef51f845407353618174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_i2c_write_buffer_dma_ex </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>notify_on_stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes on I2C bus using DMA (extended functionality) </p>
<p>This "extended functionality" variant of <a class="el" href="group___i2_c.html#gaa38e4a5363f57d5503e2207401f6e6c0" title="Write multiple bytes on I2C bus. ">hw_i2c_write_buffer()</a> adds the <code>notify_on_stop</code> parameter and uses the common callback type, which provides a way to signal whether the write finished successfully.</p>
<p>Shortcut for calling <a class="el" href="group___i2_c.html#gac14ca4479b9fafc7e6e90031fbf74951" title="Prepares I2C DMA for transfer (extended functionality) ">hw_i2c_prepare_dma_ex()</a> and <a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>DMA channel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>buffer to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of <code>buffer</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback for DMA transfer completed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>data to pass to <code>cb</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify_on_stop</td><td>indicate whether <code>cb</code> should be called when STOP is generated, or as soon as DMA finishes (like hw_i2c_prepare_dma)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#gac14ca4479b9fafc7e6e90031fbf74951" title="Prepares I2C DMA for transfer (extended functionality) ">hw_i2c_prepare_dma_ex</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#gacfb617be9d4503854630dc6e6d545027" title="Starts DMA transfer. ">hw_i2c_dma_start</a> </dd>
<dd>
<a class="el" href="group___i2_c.html#gaa38e4a5363f57d5503e2207401f6e6c0" title="Write multiple bytes on I2C bus. ">hw_i2c_write_buffer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e5e57db2f2b5eafe39c3efc2a752f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hw_i2c_write_buffer_sync </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> *&#160;</td>
          <td class="paramname"><em>abrt_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write multiple bytes to I2C slave synchronously. </p>
<p>Writes array of data to a slave device on the I2C bus via the TX FIFO. This call blocks until the operation completes. In case of failure the function stores the Tx error code to the abrt_code parameter -if provided- and clears the Tx Abort register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">abrt_code</td><td>If not NULL, the status of the operation based on <a class="el" href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e" title="I2C abort source. ">HW_I2C_ABORT_SOURCE</a> enumeration will be stored here </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Possible values for flags are: <p class="starttd"><a class="el" href="group___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a><br />
 The function will return as soon as the last byte of data is written to the Tx FIFO. Possible Tx failure after this point must be checked by the caller. This flag can be used for consequtive calls where the transmission can resume without stop/start conditions in between.</p>
<p><a class="el" href="group___i2_c.html#ga561070559a39fe8aa62f839207c5e5b7">HW_I2C_F_WAIT_FOR_STOP</a><br />
 The function will return only after all bytes have been transmitted and a STOP condition has been generated.</p>
<p class="endtd"><a class="el" href="group___i2_c.html#gaeccd5262bded02079206c0fed157b02e">HW_I2C_F_ADD_STOP</a><br />
 Stop condition will be added at the end of the whole transmission </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written to the Tx FIFO. It is strongly recommended to check the value of abrt_code to make sure that the number of bytes returned were actually transmitted to the I2C bus.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When calling this function under an OS, it is possible to have a Tx FIFO underrun which results in a STOP sequence, due to OS pre-emption. </dd></dl>

</div>
</div>
<a class="anchor" id="gad33312aeb9c615b1d8f47f5d9afa9433"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_i2c_write_byte </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write single byte into TX FIFO. </p>
<p>It is caller's responsibility to ensure there is free space in TX FIFO before calling this function - either <a class="el" href="group___i2_c.html#ga0eedecd2ed65bbd89dacf12fa0d7d7b7" title="Check if TX FIFO is not full. ">hw_i2c_is_tx_fifo_not_full()</a> or <a class="el" href="group___i2_c.html#ga0eab0a9f3549687d1f4d7125f9843f1e" title="Get number of bytes in TX FIFO. ">hw_i2c_get_tx_fifo_level()</a> can be used for this purpose.</p>
<p>This function can be used in both master and slave modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byte</td><td>data to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check for errors during transmission. Use <a class="el" href="group___i2_c.html#ga2e5e57db2f2b5eafe39c3efc2a752f09" title="Write multiple bytes to I2C slave synchronously. ">hw_i2c_write_buffer_sync()</a> or <a class="el" href="group___i2_c.html#gaf4f644c258dfd1dd0c3c5df464733d21" title="Write multiple bytes to I2C slave asynchronously. ">hw_i2c_write_buffer_async()</a> instead </dd></dl>

</div>
</div>
<a class="anchor" id="ga427b041327ec43abc52c7f6d74a739e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hw_i2c_write_then_read_async </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>w_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>r_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>r_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c.html#gaa93c52dfb507e72c87250e55aeacd7fa">hw_i2c_complete_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write then read multiple bytes from I2C slave. </p>
<p>This function allows to perform typical I2C transaction. This call is non-blocking and specified callback is fired upon completion, with the operation status. In case of failure the failure cause must be read from the cb by calling <a class="el" href="group___i2_c.html#ga4b5ab1ac4f1e9e9ef313584b2a4043af" title="Get abort source. ">hw_i2c_get_abort_source()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C controller </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_data</td><td>Address of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_len</td><td>Length of the buffer containing the data to write </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">r_data</td><td>Address of the buffer where data will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_len</td><td>Length of the buffer where data will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be fired upon completion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data to pass to cb </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Must always be <a class="el" href="group___i2_c.html#gadaf101cb30b8b19337faa1130b230b79">HW_I2C_F_NONE</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, -1 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used only when operating in master mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function registers an internal interrupt handler, which overrides any previously installed handler.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c.html#ga5944b69ca4fc9f378ca3c3f7f6740c80" title="Register interrupt handler. ">hw_i2c_register_int</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:06 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
