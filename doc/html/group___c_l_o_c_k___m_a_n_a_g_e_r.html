<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: CLOCK_MANAGER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CLOCK_MANAGER<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___s_y_s_t_e_m.html">SYSTEM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Clock Manager.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:sys__clock__mgr_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sys__clock__mgr_8h.html">sys_clock_mgr.h</a></td></tr>
<tr class="memdesc:sys__clock__mgr_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock Manager header file. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad4e7df8e63e272869fcc340ece7b4d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gad4e7df8e63e272869fcc340ece7b4d79">cm_sys_clk_init</a> (<a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:gad4e7df8e63e272869fcc340ece7b4d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize clocks after power-up.  <a href="#gad4e7df8e63e272869fcc340ece7b4d79">More...</a><br /></td></tr>
<tr class="separator:gad4e7df8e63e272869fcc340ece7b4d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8fc572086438bcf501c91494587a12d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa8fc572086438bcf501c91494587a12d">cm_sys_clk_set</a> (<a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> type)</td></tr>
<tr class="memdesc:gaa8fc572086438bcf501c91494587a12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system clock.  <a href="#gaa8fc572086438bcf501c91494587a12d">More...</a><br /></td></tr>
<tr class="separator:gaa8fc572086438bcf501c91494587a12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a489811442df40533f748695d6494d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae7a489811442df40533f748695d6494d">cm_cpu_clk_set</a> (<a class="el" href="group___c_p_m.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> clk)</td></tr>
<tr class="memdesc:gae7a489811442df40533f748695d6494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CPU clock.  <a href="#gae7a489811442df40533f748695d6494d">More...</a><br /></td></tr>
<tr class="separator:gae7a489811442df40533f748695d6494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2b9916351647b5968fcf98ef23e32d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gac2b9916351647b5968fcf98ef23e32d7">cm_cpu_clk_set_fromISR</a> (<a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> a, <a class="el" href="group___c_p_m.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> b)</td></tr>
<tr class="memdesc:gac2b9916351647b5968fcf98ef23e32d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system and the AHB bus clock (interrupt safe version).  <a href="#gac2b9916351647b5968fcf98ef23e32d7">More...</a><br /></td></tr>
<tr class="separator:gac2b9916351647b5968fcf98ef23e32d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c7649939d439045d58fec27c4b48c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2">cm_apb_set_clock_divider</a> (<a class="el" href="group___c_p_m.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> div)</td></tr>
<tr class="memdesc:gaa4c7649939d439045d58fec27c4b48c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the divider of the AMBA Peripheral Bus clock.  <a href="#gaa4c7649939d439045d58fec27c4b48c2">More...</a><br /></td></tr>
<tr class="separator:gaa4c7649939d439045d58fec27c4b48c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b18ecfc74a372db8f75ba23c974126"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126">cm_ahb_set_clock_divider</a> (<a class="el" href="group___c_p_m.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> div)</td></tr>
<tr class="memdesc:ga44b18ecfc74a372db8f75ba23c974126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the divider of the AMBA High speed Bus clock.  <a href="#ga44b18ecfc74a372db8f75ba23c974126">More...</a><br /></td></tr>
<tr class="separator:ga44b18ecfc74a372db8f75ba23c974126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec75427c454e4476752fa28d8147b47e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaec75427c454e4476752fa28d8147b47e">cm_sys_clk_get</a> (void)</td></tr>
<tr class="memdesc:gaec75427c454e4476752fa28d8147b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sys_clk that the system uses at that moment.  <a href="#gaec75427c454e4476752fa28d8147b47e">More...</a><br /></td></tr>
<tr class="separator:gaec75427c454e4476752fa28d8147b47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c573992fb1d59dd642ee3ef12177ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae7c573992fb1d59dd642ee3ef12177ae">cm_sys_clk_get_fromISR</a> (void)</td></tr>
<tr class="memdesc:gae7c573992fb1d59dd642ee3ef12177ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sys_clk that the system uses at that moment (interrupt safe version).  <a href="#gae7c573992fb1d59dd642ee3ef12177ae">More...</a><br /></td></tr>
<tr class="separator:gae7c573992fb1d59dd642ee3ef12177ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c46e80c972a2214a394c62b9c60bc22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_p_m.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1c46e80c972a2214a394c62b9c60bc22">cm_apb_get_clock_divider</a> (void)</td></tr>
<tr class="memdesc:ga1c46e80c972a2214a394c62b9c60bc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AMBA Peripheral Bus clock divider.  <a href="#ga1c46e80c972a2214a394c62b9c60bc22">More...</a><br /></td></tr>
<tr class="separator:ga1c46e80c972a2214a394c62b9c60bc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d1da04afaf8e01457910c6174edeb5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_p_m.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga2d1da04afaf8e01457910c6174edeb5a">cm_apb_get_clock_divider_fromISR</a> (void)</td></tr>
<tr class="memdesc:ga2d1da04afaf8e01457910c6174edeb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AMBA Peripheral Bus clock divider (interrupt safe).  <a href="#ga2d1da04afaf8e01457910c6174edeb5a">More...</a><br /></td></tr>
<tr class="separator:ga2d1da04afaf8e01457910c6174edeb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_p_m.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga462965cf64536f7d5d6f9c72b5f3e4e9">cm_ahb_get_clock_divider</a> (void)</td></tr>
<tr class="memdesc:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AMBA High speed Bus clock divider.  <a href="#ga462965cf64536f7d5d6f9c72b5f3e4e9">More...</a><br /></td></tr>
<tr class="separator:ga462965cf64536f7d5d6f9c72b5f3e4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90243443fec827d02b4c608da8c83790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_p_m.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga90243443fec827d02b4c608da8c83790">cm_ahb_get_clock_divider_fromISR</a> (void)</td></tr>
<tr class="memdesc:ga90243443fec827d02b4c608da8c83790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AMBA High speed Bus clock divider (interrupt safe).  <a href="#ga90243443fec827d02b4c608da8c83790">More...</a><br /></td></tr>
<tr class="separator:ga90243443fec827d02b4c608da8c83790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c2817b0b31bec83ce2d4245766a300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_p_m.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga60c2817b0b31bec83ce2d4245766a300">cm_cpu_clk_get</a> (void)</td></tr>
<tr class="memdesc:ga60c2817b0b31bec83ce2d4245766a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CPU clock frequency.  <a href="#ga60c2817b0b31bec83ce2d4245766a300">More...</a><br /></td></tr>
<tr class="separator:ga60c2817b0b31bec83ce2d4245766a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b31d79dea86dfba84b3a6dbd56bd9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_p_m.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga7b31d79dea86dfba84b3a6dbd56bd9c9">cm_cpu_clk_get_fromISR</a> (void)</td></tr>
<tr class="memdesc:ga7b31d79dea86dfba84b3a6dbd56bd9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CPU clock frequency (interrupt safe).  <a href="#ga7b31d79dea86dfba84b3a6dbd56bd9c9">More...</a><br /></td></tr>
<tr class="separator:ga7b31d79dea86dfba84b3a6dbd56bd9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b96b631a34f1e2c30a9213f300d3798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga8b96b631a34f1e2c30a9213f300d3798">cm_calibrate_rc32k</a> (void)</td></tr>
<tr class="memdesc:ga8b96b631a34f1e2c30a9213f300d3798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrate RC32K.  <a href="#ga8b96b631a34f1e2c30a9213f300d3798">More...</a><br /></td></tr>
<tr class="separator:ga8b96b631a34f1e2c30a9213f300d3798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0dcedf100d5d1dac0770a9f623cb359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf0dcedf100d5d1dac0770a9f623cb359">cm_calibrate_rcx_start</a> (void)</td></tr>
<tr class="memdesc:gaf0dcedf100d5d1dac0770a9f623cb359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start RCX calibration.  <a href="#gaf0dcedf100d5d1dac0770a9f623cb359">More...</a><br /></td></tr>
<tr class="separator:gaf0dcedf100d5d1dac0770a9f623cb359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a393e70f97e41f4e4b93341c7de135"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gac4a393e70f97e41f4e4b93341c7de135">cm_calibrate_rcx_update</a> (void)</td></tr>
<tr class="memdesc:gac4a393e70f97e41f4e4b93341c7de135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RCX calibration results and update environment variables.  <a href="#gac4a393e70f97e41f4e4b93341c7de135">More...</a><br /></td></tr>
<tr class="separator:gac4a393e70f97e41f4e4b93341c7de135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae884fa4c86df75b1cb87f591b9417e2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gae884fa4c86df75b1cb87f591b9417e2b">cm_rcx_us_2_lpcycles</a> (uint32_t usec)</td></tr>
<tr class="memdesc:gae884fa4c86df75b1cb87f591b9417e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts usec to RCX cycles.  <a href="#gae884fa4c86df75b1cb87f591b9417e2b">More...</a><br /></td></tr>
<tr class="separator:gae884fa4c86df75b1cb87f591b9417e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga64bbd9cd49b18ce46a71fa41ae287587">cm_rcx_us_2_lpcycles_low_acc</a> (uint32_t usec)</td></tr>
<tr class="memdesc:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts time to RCX cycles.  <a href="#ga64bbd9cd49b18ce46a71fa41ae287587">More...</a><br /></td></tr>
<tr class="separator:ga64bbd9cd49b18ce46a71fa41ae287587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf283b84d1c7b8b473b5d87000bb6b50f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf283b84d1c7b8b473b5d87000bb6b50f">cm_set_trim_values</a> (void) DEPRECATED</td></tr>
<tr class="memdesc:gaf283b84d1c7b8b473b5d87000bb6b50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set proper trim values to RC32K, XTAL16M and RC16.  <a href="#gaf283b84d1c7b8b473b5d87000bb6b50f">More...</a><br /></td></tr>
<tr class="separator:gaf283b84d1c7b8b473b5d87000bb6b50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a3eb3e25398887b4e1ab374ccccb6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaf4a3eb3e25398887b4e1ab374ccccb6d">cm_wait_xtal16m_ready</a> (void)</td></tr>
<tr class="memdesc:gaf4a3eb3e25398887b4e1ab374ccccb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until the XTAL16M is ready. If the XTAL16M is running then the function exits immediately.  <a href="#gaf4a3eb3e25398887b4e1ab374ccccb6d">More...</a><br /></td></tr>
<tr class="separator:gaf4a3eb3e25398887b4e1ab374ccccb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9857796532a9d4e64156b009bd82fee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga9857796532a9d4e64156b009bd82fee2">cm_lp_clk_init</a> (void)</td></tr>
<tr class="memdesc:ga9857796532a9d4e64156b009bd82fee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Low Power clock.  <a href="#ga9857796532a9d4e64156b009bd82fee2">More...</a><br /></td></tr>
<tr class="separator:ga9857796532a9d4e64156b009bd82fee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7212c64dd636f427e4cac2358e76a8db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga7212c64dd636f427e4cac2358e76a8db">cm_lp_clk_timer_start</a> (void)</td></tr>
<tr class="memdesc:ga7212c64dd636f427e4cac2358e76a8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the timer the blocks sleep while the low power clock is settling.  <a href="#ga7212c64dd636f427e4cac2358e76a8db">More...</a><br /></td></tr>
<tr class="separator:ga7212c64dd636f427e4cac2358e76a8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1441219191476e451ba6fbc41bb9e103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga1441219191476e451ba6fbc41bb9e103">cm_lp_clk_is_avail</a> (void)</td></tr>
<tr class="memdesc:ga1441219191476e451ba6fbc41bb9e103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Low Power clock is available.  <a href="#ga1441219191476e451ba6fbc41bb9e103">More...</a><br /></td></tr>
<tr class="separator:ga1441219191476e451ba6fbc41bb9e103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8326d96c90e17710e709c0de96fc5e76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga8326d96c90e17710e709c0de96fc5e76">cm_lp_clk_is_avail_fromISR</a> (void)</td></tr>
<tr class="memdesc:ga8326d96c90e17710e709c0de96fc5e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Low Power clock is available, interrupt safe version.  <a href="#ga8326d96c90e17710e709c0de96fc5e76">More...</a><br /></td></tr>
<tr class="separator:ga8326d96c90e17710e709c0de96fc5e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga6dcfa191a663cbc9e2998e79cbc7b68e">cm_wait_lp_clk_ready</a> (void)</td></tr>
<tr class="memdesc:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the Low Power clock is available.  <a href="#ga6dcfa191a663cbc9e2998e79cbc7b68e">More...</a><br /></td></tr>
<tr class="separator:ga6dcfa191a663cbc9e2998e79cbc7b68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ed9c5bf5295e90e6d1b3612af040baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0ed9c5bf5295e90e6d1b3612af040baa">cm_lp_clk_wakeup</a> (void)</td></tr>
<tr class="memdesc:ga0ed9c5bf5295e90e6d1b3612af040baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the flag that indicates that the Low Power clock is available.  <a href="#ga0ed9c5bf5295e90e6d1b3612af040baa">More...</a><br /></td></tr>
<tr class="separator:ga0ed9c5bf5295e90e6d1b3612af040baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcf954bdf087949b5e68fbaf8a846c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga5dcf954bdf087949b5e68fbaf8a846c3">XTAL16RDY_Handler</a> (void)</td></tr>
<tr class="memdesc:ga5dcf954bdf087949b5e68fbaf8a846c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler of the XTAL16RDY_IRQn.  <a href="#ga5dcf954bdf087949b5e68fbaf8a846c3">More...</a><br /></td></tr>
<tr class="separator:ga5dcf954bdf087949b5e68fbaf8a846c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2715774241ca17283cecd4c2ddcc64f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga2715774241ca17283cecd4c2ddcc64f4">cm_lower_all_clocks</a> (void)</td></tr>
<tr class="memdesc:ga2715774241ca17283cecd4c2ddcc64f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower all clocks to the lowest frequency possible (best effort).  <a href="#ga2715774241ca17283cecd4c2ddcc64f4">More...</a><br /></td></tr>
<tr class="separator:ga2715774241ca17283cecd4c2ddcc64f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147b9ef02a0a39ca9957750f339cd9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga147b9ef02a0a39ca9957750f339cd9e2">cm_restore_all_clocks</a> (void)</td></tr>
<tr class="memdesc:ga147b9ef02a0a39ca9957750f339cd9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore all clocks to the speed set by the user.  <a href="#ga147b9ef02a0a39ca9957750f339cd9e2">More...</a><br /></td></tr>
<tr class="separator:ga147b9ef02a0a39ca9957750f339cd9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9871154091e7f99fabf9dc997a68d1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gab9871154091e7f99fabf9dc997a68d1c">cm_wait_xtal16m_ready_fromISR</a> (void)</td></tr>
<tr class="memdesc:gab9871154091e7f99fabf9dc997a68d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the XTAL16M is ready and then switch clocks if necessary.  <a href="#gab9871154091e7f99fabf9dc997a68d1c">More...</a><br /></td></tr>
<tr class="separator:gab9871154091e7f99fabf9dc997a68d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343da861df747553bb41cf5c2c6be318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga343da861df747553bb41cf5c2c6be318">cm_poll_xtal16m_ready</a> (void)</td></tr>
<tr class="memdesc:ga343da861df747553bb41cf5c2c6be318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the XTAL16M is ready.  <a href="#ga343da861df747553bb41cf5c2c6be318">More...</a><br /></td></tr>
<tr class="separator:ga343da861df747553bb41cf5c2c6be318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffc2c5495a7da79d30168e4bdfede9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga4ffc2c5495a7da79d30168e4bdfede9f">cm_check_xtal_startup</a> (void)</td></tr>
<tr class="memdesc:ga4ffc2c5495a7da79d30168e4bdfede9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the XTAL16M has started and is settling.  <a href="#ga4ffc2c5495a7da79d30168e4bdfede9f">More...</a><br /></td></tr>
<tr class="separator:ga4ffc2c5495a7da79d30168e4bdfede9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d77effbfaee1f265e78e86da051908"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga07d77effbfaee1f265e78e86da051908">cm_clk_init_low_level</a> (void)</td></tr>
<tr class="memdesc:ga07d77effbfaee1f265e78e86da051908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic initialization of the system and low power clocks.  <a href="#ga07d77effbfaee1f265e78e86da051908">More...</a><br /></td></tr>
<tr class="separator:ga07d77effbfaee1f265e78e86da051908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc80da66ffdee3102e5de96353d48b6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gafc80da66ffdee3102e5de96353d48b6e">cm_sys_clk_sleep</a> (bool entering_sleep)</td></tr>
<tr class="memdesc:gafc80da66ffdee3102e5de96353d48b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the system clock (unprotected).  <a href="#gafc80da66ffdee3102e5de96353d48b6e">More...</a><br /></td></tr>
<tr class="separator:gafc80da66ffdee3102e5de96353d48b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb540fe4862965078f69914081e3f04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga0eb540fe4862965078f69914081e3f04">cm_sys_restore_sysclk</a> (<a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> prev_sysclk)</td></tr>
<tr class="memdesc:ga0eb540fe4862965078f69914081e3f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the system clock (unprotected).  <a href="#ga0eb540fe4862965078f69914081e3f04">More...</a><br /></td></tr>
<tr class="separator:ga0eb540fe4862965078f69914081e3f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa35a8cffa0bc142ec96349195f9f7817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa35a8cffa0bc142ec96349195f9f7817">cm_sys_clk_wakeup</a> (void)</td></tr>
<tr class="memdesc:gaa35a8cffa0bc142ec96349195f9f7817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the Event Groups Bit(s) and the "settled" flag.  <a href="#gaa35a8cffa0bc142ec96349195f9f7817">More...</a><br /></td></tr>
<tr class="separator:gaa35a8cffa0bc142ec96349195f9f7817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358b60e3e2c9643fec2f0a31d3491fc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga358b60e3e2c9643fec2f0a31d3491fc8">cm_halt_until_xtal16m_ready</a> (void)</td></tr>
<tr class="memdesc:ga358b60e3e2c9643fec2f0a31d3491fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt until the XTAL16M has settled..  <a href="#ga358b60e3e2c9643fec2f0a31d3491fc8">More...</a><br /></td></tr>
<tr class="separator:ga358b60e3e2c9643fec2f0a31d3491fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb8beea660737977bf7d4207fea3f211"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaeb8beea660737977bf7d4207fea3f211">cm_sys_xtal16m_running</a> (void)</td></tr>
<tr class="memdesc:gaeb8beea660737977bf7d4207fea3f211"><td class="mdescLeft">&#160;</td><td class="mdescRight">The XTAL16M has never stopped! Inform the Adapters upon "wake-up".  <a href="#gaeb8beea660737977bf7d4207fea3f211">More...</a><br /></td></tr>
<tr class="separator:gaeb8beea660737977bf7d4207fea3f211"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Clock Manager. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga462965cf64536f7d5d6f9c72b5f3e4e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_p_m.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> cm_ahb_get_clock_divider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AMBA High speed Bus clock divider. </p>
<dl class="section return"><dt>Returns</dt><dd>The hclk being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90243443fec827d02b4c608da8c83790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_p_m.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a> cm_ahb_get_clock_divider_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AMBA High speed Bus clock divider (interrupt safe). </p>
<dl class="section return"><dt>Returns</dt><dd>The hclk being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga44b18ecfc74a372db8f75ba23c974126"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_ahb_set_clock_divider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_p_m.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the divider of the AMBA High speed Bus clock. </p>
<p>The frequency of the AHB clock is: (cm_sysclk * 16 / (1 &lt;&lt; cm_ahbclk)). Note: if the SysTick runs then it is the dg_configABORT_IF_SYSTICK_CLK_ERR setting that controls whether the switch will be aborted or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>The new value of the AHB divider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the divider was changed to the requested value, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c46e80c972a2214a394c62b9c60bc22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_p_m.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> cm_apb_get_clock_divider </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AMBA Peripheral Bus clock divider. </p>
<dl class="section return"><dt>Returns</dt><dd>The pclk being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d1da04afaf8e01457910c6174edeb5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_p_m.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a> cm_apb_get_clock_divider_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AMBA Peripheral Bus clock divider (interrupt safe). </p>
<dl class="section return"><dt>Returns</dt><dd>The pclk being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4c7649939d439045d58fec27c4b48c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_apb_set_clock_divider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_p_m.html#ga76dc2db718173b123e891b885cf77023">apb_div_t</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the divider of the AMBA Peripheral Bus clock. </p>
<p>The frequency of the APB clock is: (cm_sysclk * 16 / (1 &lt;&lt; cm_ahbclk)) / (1 &lt;&lt; cm_apbclk).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>The new value of the APB divider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b96b631a34f1e2c30a9213f300d3798"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_calibrate_rc32k </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrate RC32K. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0dcedf100d5d1dac0770a9f623cb359"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void cm_calibrate_rcx_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start RCX calibration. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="gac4a393e70f97e41f4e4b93341c7de135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_calibrate_rcx_update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get RCX calibration results and update environment variables. </p>
<dl class="section return"><dt>Returns</dt><dd>True, if calibration has finished and sleep can continue, else false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ffc2c5495a7da79d30168e4bdfede9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_check_xtal_startup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the XTAL16M has started and is settling. </p>
<dl class="section warning"><dt>Warning</dt><dd>A WDOG reset will be issued in case the XTAL has not started properly. The NMI Handler may be called, depending on the NMI_RST bit setting. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07d77effbfaee1f265e78e86da051908"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_clk_init_low_level </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic initialization of the system and low power clocks. </p>
<p>It switches to RC16M, restarts XTAL16M and waits for it to settle. It also sets the DIVN. Then it sets up the low power clock.</p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called once, before the OS scheduler is started. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60c2817b0b31bec83ce2d4245766a300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_p_m.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> cm_cpu_clk_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the CPU clock frequency. </p>
<dl class="section return"><dt>Returns</dt><dd>The CPU clock being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any restrictions of the <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaec75427c454e4476752fa28d8147b47e" title="Returns the sys_clk that the system uses at that moment. ">cm_sys_clk_get()</a> and <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga462965cf64536f7d5d6f9c72b5f3e4e9" title="Returns the AMBA High speed Bus clock divider. ">cm_ahb_get_clock_divider()</a> apply here as well. It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b31d79dea86dfba84b3a6dbd56bd9c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_p_m.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a> cm_cpu_clk_get_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the CPU clock frequency (interrupt safe). </p>
<dl class="section return"><dt>Returns</dt><dd>The CPU clock being used.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7a489811442df40533f748695d6494d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_cpu_clk_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_p_m.html#gaae49d94cffe9c77837af61544d1c53f7">cpu_clk_t</a>&#160;</td>
          <td class="paramname"><em>clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the CPU clock. </p>
<p>It attempts to set the sys_clk and the AMBA High speed bus divider to achieve the CPU clock that is requested. ARM Cortex-M0 runs using the AHB clock. Any restrictions of the <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa8fc572086438bcf501c91494587a12d" title="Set the system clock. ">cm_sys_clk_set()</a>, <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126" title="Change the divider of the AMBA High speed Bus clock. ">cm_ahb_set_clock_divider()</a> and <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2" title="Change the divider of the AMBA Peripheral Bus clock. ">cm_apb_set_clock_divider()</a> apply here as well. The APB bus clock will be set to the maximum frequency. The function may return false if the requested frequency is not achievable. For example, the frequency of 1MHz can be achieved only if the RC16 or the XTAL16M is used. If the system clock is not RC16 though (see warning) and the crystal connected to the XTAL16M is 32MHz then it is not possible to get 1MHz AHB clock frequency. The smallest that can be achieved is 2MHz.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clk</td><td>The CPU clock frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the requested clock switch was applied, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since some frequencies can be achieved with RC16, this function will not change to using the XTAL or the PLL, if the RC16 is the current system clock. It is the responsibility of the caller to switch to the XTAL or the PLL before calling this function. After switching, the function will not revert to using the RC16 at any case. Thus, switching from/to RC16 may be considered as "manual" while the switching from/to any other system clock source is done automatically from this function. The setting of the clocks is done via calls to <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa8fc572086438bcf501c91494587a12d" title="Set the system clock. ">cm_sys_clk_set()</a>, <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#ga44b18ecfc74a372db8f75ba23c974126" title="Change the divider of the AMBA High speed Bus clock. ">cm_ahb_set_clock_divider()</a> and <a class="el" href="group___c_l_o_c_k___m_a_n_a_g_e_r.html#gaa4c7649939d439045d58fec27c4b48c2" title="Change the divider of the AMBA Peripheral Bus clock. ">cm_apb_set_clock_divider()</a>. It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2b9916351647b5968fcf98ef23e32d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_cpu_clk_set_fromISR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_p_m.html#ga9b599eb5a005e79a2f770281b11f3cd8">ahb_div_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system and the AHB bus clock (interrupt safe version). </p>
<p>It sets the sys_clk to XTAL16M or PLL and the AHB divider. Actually, it sets the clock frequency that the ARM Cortex-M0 will run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The clock source to use as the system clock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The divider of the AHB clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is called with interrupts disabled. The caller must have checked that the current sys_clk is not the desired one before calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga358b60e3e2c9643fec2f0a31d3491fc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void cm_halt_until_xtal16m_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt until the XTAL16M has settled.. </p>
<p>It executes a WFI() call waiting for the XTAL16RDY_IRQ. Any other interrupts that hit (the WKUP_GPIO_IRQn should be the only one that can hit at that period), are served. </p>

</div>
</div>
<a class="anchor" id="ga2715774241ca17283cecd4c2ddcc64f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_lower_all_clocks </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower all clocks to the lowest frequency possible (best effort). </p>
<ol type="1">
<li><p class="startli">Check which is the lowest system clock that can be used. The RC16 is the lowest but it does not make sense to use it if the system clock is the XTAL or the PLL. Thus, the lowest system clock setting will always be the XTAL if the current system clock is not the RC16.</p>
<p class="startli">If the PLL is on then the switch to the XTAL will be done without disabling the PLL.</p>
<p class="startli">Affects: OTPC, KBSCN*, SPI*, I2C*, ADC*, QSPI and Timer0/2* (* = conditionally) and SysTick. Only the Timer0/2 is inquired. If any timer is active and uses the system clock then the system clock is left unchanged. No block is informed about the change. If there is an active SPI or I2C transaction, it may fail.</p><ol type="a">
<li>Check which is the lowest AHB clock that can be used. When a MAC is active, the lowest AHB clock is 16MHz. The frequency change will destroy any ongoing IR transaction.</li>
</ol>
<p class="startli">Note: if the SysTick runs then it is the dg_configABORT_IF_SYSTICK_CLK_ERR setting that controls whether the switch will continue or it will be aborted.</p><ol type="a">
<li>The APB clock is always set to the lowest setting.</li>
</ol>
</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called with all interrupts disabled. Cannot be called by Application tasks! </dd></dl>

</div>
</div>
<a class="anchor" id="ga9857796532a9d4e64156b009bd82fee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_lp_clk_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Low Power clock. </p>
<p>It initializes and sets as LP clock either the RCX or the XTAL32K. Since the XTAL32K settling takes a long time, the system is kept in active mode until this completes.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ga1441219191476e451ba6fbc41bb9e103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_lp_clk_is_avail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the Low Power clock is available. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the LP clock is available, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It does not block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8326d96c90e17710e709c0de96fc5e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_lp_clk_is_avail_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the Low Power clock is available, interrupt safe version. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the LP clock is available, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It does not block. It can be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7212c64dd636f427e4cac2358e76a8db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_lp_clk_timer_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the timer the blocks sleep while the low power clock is settling. </p>
<p>It starts the timer that blocks system from sleeping for dg_configINITIAL_SLEEP_DELAY_TIME. This is needed when the XTAL32K is used to make sure that the clock has settled properly before going back to sleep again.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ed9c5bf5295e90e6d1b3612af040baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_lp_clk_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the flag that indicates that the Low Power clock is available. </p>
<p>It is called when the system wakes up from a "forced" deep sleep state and the XTAL32K is used as the LP clock so that the system won't enter into sleep until the crystal has settled.</p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga343da861df747553bb41cf5c2c6be318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool cm_poll_xtal16m_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the XTAL16M is ready. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the XTAL16M has settled, else false. </dd></dl>

</div>
</div>
<a class="anchor" id="gae884fa4c86df75b1cb87f591b9417e2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> uint32_t cm_rcx_us_2_lpcycles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts usec to RCX cycles. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of RCX cycles for the given time period.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Maximum time period is 4.095msec. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64bbd9cd49b18ce46a71fa41ae287587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t cm_rcx_us_2_lpcycles_low_acc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts time to RCX cycles. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of RCX cycles for the given time period.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a low accuracy function. To have good accuracy, the minimum time period should be 1msec and the maximum 200msec. Above 200msec, the function calculates more RCX cycles than necessary. </dd></dl>

</div>
</div>
<a class="anchor" id="ga147b9ef02a0a39ca9957750f339cd9e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_restore_all_clocks </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore all clocks to the speed set by the user. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called with all interrupts disabled. Cannot be called by Application tasks! </dd></dl>

</div>
</div>
<a class="anchor" id="gaf283b84d1c7b8b473b5d87000bb6b50f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_set_trim_values </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set proper trim values to RC32K, XTAL16M and RC16. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>This functionality is part of the system initialization.</dd></dl>

</div>
</div>
<a class="anchor" id="gaec75427c454e4476752fa28d8147b47e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> cm_sys_clk_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sys_clk that the system uses at that moment. </p>
<dl class="section return"><dt>Returns</dt><dd>The real sys_clk used by the system.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7c573992fb1d59dd642ee3ef12177ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> cm_sys_clk_get_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sys_clk that the system uses at that moment (interrupt safe version). </p>
<dl class="section return"><dt>Returns</dt><dd>The real sys_clk used by the system. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4e7df8e63e272869fcc340ece7b4d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_clk_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize clocks after power-up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source to use as the system clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called with interrupts enabled! It is called only once, after power-up. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8fc572086438bcf501c91494587a12d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cm_sys_clk_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system clock. </p>
<p>It attempts to set the sys_clk to one of the available options. If it is not possible because, for example, it was requested to switch to RC16 and a MAC or the UART, etc., runs, it returns false. If the request involves turning on the XTAL16M, which was turned-off for some reason, then the task will block and the XTAL16M will be powered on. The task will resume execution when the XTAL16M settles. The CM will restore the last setting after each wake-up, automatically, whenever the XTAL16M settles. Note: if the SysTick runs then it is the dg_configABORT_IF_SYSTICK_CLK_ERR setting that controls whether the switch will be aborted or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The clock source to use as the system clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the requested clock switch was applied, else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc80da66ffdee3102e5de96353d48b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_clk_sleep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>entering_sleep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the system clock (unprotected). </p>
<p>It attempts to set the sys_clk to:</p><ul>
<li>16MHz : called when the system is entering power-down mode. The system clock settings of the application are kept in order to be able to restore them. When the system clock is RC16, it is not changed. When it is XTAL or PLL, it is changed to RC16. (It is called with the scheduler stopped and all interrupts disabled in this case.)</li>
<li>Previous setting : called when the XTAL16M settles. (It is called from ISR context with all interrupts disabled in this case.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entering_sleep</td><td>True if the system is going to sleep, else false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called from Interrupt Context and/or with all interrupts disabled. The function is internal to the CPM and should not be used externally! </dd></dl>

</div>
</div>
<a class="anchor" id="gaa35a8cffa0bc142ec96349195f9f7817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_clk_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the Event Groups Bit(s) and the "settled" flag. </p>
<p>It pends the clearing of the Event Groups bit(s) to the OS task daemon. In the case of waking up from the Tick timer, no other task is ready-to-run anyway. In the case though of waking up from an external interrupt to WKUPCT then another task of equal priority to the OS daemon task may also become ready-to-run. But even in this case, the first task that is made ready-to-run is the OS daemon task and this is the task that the scheduler will execute first.</p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called from Interrupt Context and with all interrupts disabled. The priority of the Timers task (OS daemon task) must be the highest! The function is internal to the CPM and should not be used externally! </dd></dl>

</div>
</div>
<a class="anchor" id="ga0eb540fe4862965078f69914081e3f04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_restore_sysclk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>prev_sysclk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the system clock (unprotected). </p>
<p>It attempts to restore the sys_clk to PLL-48MHz or PLL-96MHz. Is is assumed that the system runs at XTAL16M.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prev_sysclk</td><td>The sys_clk to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called from Interrupt Context and/or with all interrupts disabled. The function is internal to the CPM and should not be used externally! </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb8beea660737977bf7d4207fea3f211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_sys_xtal16m_running </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The XTAL16M has never stopped! Inform the Adapters upon "wake-up". </p>
<p>The debugger did not detach and the chip did not enter into sleep. Thus, the XTAL16 is still running. Use this to inform Adapters that the XTAL16M is available.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is provided only for debugging purposes since when the debugger is attached, the XTAL16M does not stop and no XTAL16RDU_IRQn hits! It will never be called in normal operation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6dcfa191a663cbc9e2998e79cbc7b68e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_lp_clk_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the Low Power clock is available. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4a3eb3e25398887b4e1ab374ccccb6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_xtal16m_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until the XTAL16M is ready. If the XTAL16M is running then the function exits immediately. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It may block. It cannot be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="gab9871154091e7f99fabf9dc997a68d1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cm_wait_xtal16m_ready_fromISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until the XTAL16M is ready and then switch clocks if necessary. </p>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It must be called from Interrupt Context. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dcf954bdf087949b5e68fbaf8a846c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XTAL16RDY_Handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler of the XTAL16RDY_IRQn. </p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:06 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
