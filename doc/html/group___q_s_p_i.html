<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: QSPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">QSPI<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___d_e_v_i_c_e_s.html">DEVICES</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>QSPI Flash Memory Controller.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hw__qspi_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__qspi_8h.html">hw_qspi.h</a></td></tr>
<tr class="memdesc:hw__qspi_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of API for the QSPI Low Level Driver. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqspi__config.html">qspi_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI configuration.  <a href="structqspi__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7f2a498b363ea1884c436ec631b02216"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga7f2a498b363ea1884c436ec631b02216">HW_QSPIC_REG_FIELD_MASK</a>(reg,  field)&#160;&#160;&#160;(QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Msk)</td></tr>
<tr class="memdesc:ga7f2a498b363ea1884c436ec631b02216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mask of a field of an QSPIC register.  <a href="#ga7f2a498b363ea1884c436ec631b02216">More...</a><br /></td></tr>
<tr class="separator:ga7f2a498b363ea1884c436ec631b02216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09eacb461c864f71d038185e76fe1cc9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga09eacb461c864f71d038185e76fe1cc9">HW_QSPIC_REG_FIELD_POS</a>(reg,  field)&#160;&#160;&#160;(QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Pos)</td></tr>
<tr class="memdesc:ga09eacb461c864f71d038185e76fe1cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bit position of a field of an QSPIC register.  <a href="#ga09eacb461c864f71d038185e76fe1cc9">More...</a><br /></td></tr>
<tr class="separator:ga09eacb461c864f71d038185e76fe1cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e65ec6c339fd99c7ce90b2d9fe37d72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga6e65ec6c339fd99c7ce90b2d9fe37d72">HW_QSPIC_REG_GETF</a>(reg,  field)&#160;&#160;&#160;((QSPIC-&gt;QSPIC_##reg##_REG &amp; (QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Msk)) &gt;&gt; (QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Pos))</td></tr>
<tr class="memdesc:ga6e65ec6c339fd99c7ce90b2d9fe37d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a field of an QSPIC register.  <a href="#ga6e65ec6c339fd99c7ce90b2d9fe37d72">More...</a><br /></td></tr>
<tr class="separator:ga6e65ec6c339fd99c7ce90b2d9fe37d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d6bd4fd9953df170e300d3a76e6fefc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga7d6bd4fd9953df170e300d3a76e6fefc">HW_QSPIC_REG_SETF</a>(reg,  field,  new_val)</td></tr>
<tr class="memdesc:ga7d6bd4fd9953df170e300d3a76e6fefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a field of an QSPIC register.  <a href="#ga7d6bd4fd9953df170e300d3a76e6fefc">More...</a><br /></td></tr>
<tr class="separator:ga7d6bd4fd9953df170e300d3a76e6fefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga604b6c149c9e933d2e6606f2e5bc8f6c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> { <a class="el" href="group___q_s_p_i.html#gga604b6c149c9e933d2e6606f2e5bc8f6caca5039bdedd96187fe41e2c66916b09a">HW_QSPI_BUS_MODE_SINGLE</a>, 
<a class="el" href="group___q_s_p_i.html#gga604b6c149c9e933d2e6606f2e5bc8f6cadc76e45c2447138001d3d08ecf9a33b9">HW_QSPI_BUS_MODE_DUAL</a>, 
<a class="el" href="group___q_s_p_i.html#gga604b6c149c9e933d2e6606f2e5bc8f6ca76bb931e961190106991f4252af5a2cd">HW_QSPI_BUS_MODE_QUAD</a>
 }</td></tr>
<tr class="memdesc:ga604b6c149c9e933d2e6606f2e5bc8f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bus mode.  <a href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">More...</a><br /></td></tr>
<tr class="separator:ga604b6c149c9e933d2e6606f2e5bc8f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b31012e4ee1a0afdb3bc394f0d97743"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga7b31012e4ee1a0afdb3bc394f0d97743">HW_QSPI_ADDR_SIZE</a> { <a class="el" href="group___q_s_p_i.html#gga7b31012e4ee1a0afdb3bc394f0d97743a9bd039cd2cf1bfa5f6b025828c273af8">HW_QSPI_ADDR_SIZE_24</a>, 
<a class="el" href="group___q_s_p_i.html#gga7b31012e4ee1a0afdb3bc394f0d97743a8162da815fe79d5dd41231e249b7ac1f">HW_QSPI_ADDR_SIZE_32</a>
 }</td></tr>
<tr class="memdesc:ga7b31012e4ee1a0afdb3bc394f0d97743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash memory address size.  <a href="group___q_s_p_i.html#ga7b31012e4ee1a0afdb3bc394f0d97743">More...</a><br /></td></tr>
<tr class="separator:ga7b31012e4ee1a0afdb3bc394f0d97743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18d9feb5205b04d978770d17cf117059"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga18d9feb5205b04d978770d17cf117059">HW_QSPI_POL</a> { <a class="el" href="group___q_s_p_i.html#gga18d9feb5205b04d978770d17cf117059ac6cc54df6eaf9e2fffa89c482d8869a3">HW_QSPI_POL_LOW</a> = 0, 
<a class="el" href="group___q_s_p_i.html#gga18d9feb5205b04d978770d17cf117059ade9c6a47500c67fabc454edc874f58a9">HW_QSPI_POL_HIGH</a> = 1
 }</td></tr>
<tr class="memdesc:ga18d9feb5205b04d978770d17cf117059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idle clock state.  <a href="group___q_s_p_i.html#ga18d9feb5205b04d978770d17cf117059">More...</a><br /></td></tr>
<tr class="separator:ga18d9feb5205b04d978770d17cf117059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f21c08ed361bcc72e6cf6ac96b5a857"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga0f21c08ed361bcc72e6cf6ac96b5a857">HW_QSPI_SAMPLING_EDGE</a> { <a class="el" href="group___q_s_p_i.html#gga0f21c08ed361bcc72e6cf6ac96b5a857a414aa8d17c03d3ddf3d11d8075cf5418">HW_QSPI_SAMPLING_EDGE_POSITIVE</a> = 0, 
<a class="el" href="group___q_s_p_i.html#gga0f21c08ed361bcc72e6cf6ac96b5a857a3e2c2a1af33ccb1c31c1e55a14192cb4">HW_QSPI_SAMPLING_EDGE_NEGATIVE</a> = 1
 }</td></tr>
<tr class="memdesc:ga0f21c08ed361bcc72e6cf6ac96b5a857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of QSPI_CLK edge for sampling received data.  <a href="group___q_s_p_i.html#ga0f21c08ed361bcc72e6cf6ac96b5a857">More...</a><br /></td></tr>
<tr class="separator:ga0f21c08ed361bcc72e6cf6ac96b5a857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ceb2660e908c030d93e6f4b84d7d667"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga9ceb2660e908c030d93e6f4b84d7d667">HW_QSPI_WRAP_SIZE</a> { <a class="el" href="group___q_s_p_i.html#gga9ceb2660e908c030d93e6f4b84d7d667a76375cbd5c163750c9cd23b340b78cee">HW_QSPI_WRAP_SIZE_8BITS</a> = 0, 
<a class="el" href="group___q_s_p_i.html#gga9ceb2660e908c030d93e6f4b84d7d667af94a3b5fce9ec384832ec271cbeac26e">HW_QSPI_WRAP_SIZE_16BITS</a> = 1, 
<a class="el" href="group___q_s_p_i.html#gga9ceb2660e908c030d93e6f4b84d7d667a6e29a654c746ce92b5f87fbe2bda93f6">HW_QSPI_WRAP_SIZE_32BITS</a> = 2
 }</td></tr>
<tr class="memdesc:ga9ceb2660e908c030d93e6f4b84d7d667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selected data size of a wrapping burst.  <a href="group___q_s_p_i.html#ga9ceb2660e908c030d93e6f4b84d7d667">More...</a><br /></td></tr>
<tr class="separator:ga9ceb2660e908c030d93e6f4b84d7d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4d9a77064663720318bb6fd1077c2e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga4c4d9a77064663720318bb6fd1077c2e">HW_QSPI_WRAP_LEN</a> { <a class="el" href="group___q_s_p_i.html#gga4c4d9a77064663720318bb6fd1077c2ea7bfd0c3a41f0ae5cae1ce881d7e14af0">HW_QSPI_WRAP_LEN_4BEAT</a> = 0, 
<a class="el" href="group___q_s_p_i.html#gga4c4d9a77064663720318bb6fd1077c2ea362b71768c888d4052802dc5753133e5">HW_QSPI_WRAP_LEN_8BEAT</a> = 1, 
<a class="el" href="group___q_s_p_i.html#gga4c4d9a77064663720318bb6fd1077c2ea4d1c86b71566a3f8726cd9666428f3ea">HW_QSPI_WRAP_LEN_16BEAT</a> = 2
 }</td></tr>
<tr class="memdesc:ga4c4d9a77064663720318bb6fd1077c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selected data length of a wrapping burst.  <a href="group___q_s_p_i.html#ga4c4d9a77064663720318bb6fd1077c2e">More...</a><br /></td></tr>
<tr class="separator:ga4c4d9a77064663720318bb6fd1077c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac307a660e5a28c297e4c29bd93f69ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gaac307a660e5a28c297e4c29bd93f69ca">HW_QSPI_BREAK_SEQ_SIZE</a> { <a class="el" href="group___q_s_p_i.html#ggaac307a660e5a28c297e4c29bd93f69caa75d28bb2bc33dedd443b2af6f44fde0e">HW_QSPI_BREAK_SEQ_SIZE_1B</a> = 0, 
<a class="el" href="group___q_s_p_i.html#ggaac307a660e5a28c297e4c29bd93f69caa7ae2e070cdfd88cd08cc3def2e334dea">HW_QSPI_BREAK_SEQ_SIZE_2B</a> = 1
 }</td></tr>
<tr class="memdesc:gaac307a660e5a28c297e4c29bd93f69ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of Burst Break Sequence.  <a href="group___q_s_p_i.html#gaac307a660e5a28c297e4c29bd93f69ca">More...</a><br /></td></tr>
<tr class="separator:gaac307a660e5a28c297e4c29bd93f69ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b91c8f3fd1797b6b0c44f410e2306a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga91b91c8f3fd1797b6b0c44f410e2306a">HW_QSPI_SLEW_RATE</a> { <a class="el" href="group___q_s_p_i.html#gga91b91c8f3fd1797b6b0c44f410e2306aa8ad13336cbb2430f91fb17c64f3327b4">HW_QSPI_SLEW_RATE_0</a>, 
<a class="el" href="group___q_s_p_i.html#gga91b91c8f3fd1797b6b0c44f410e2306aabfd6638bd2b629025d94ff09cd7c22f2">HW_QSPI_SLEW_RATE_1</a>, 
<a class="el" href="group___q_s_p_i.html#gga91b91c8f3fd1797b6b0c44f410e2306aa5db696c827bffdac904828d4e5ce0f4e">HW_QSPI_SLEW_RATE_2</a>, 
<a class="el" href="group___q_s_p_i.html#gga91b91c8f3fd1797b6b0c44f410e2306aa8dea3b352e948851a28252668a6888ab">HW_QSPI_SLEW_RATE_3</a>
 }</td></tr>
<tr class="memdesc:ga91b91c8f3fd1797b6b0c44f410e2306a"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI pads slew rate control.  <a href="group___q_s_p_i.html#ga91b91c8f3fd1797b6b0c44f410e2306a">More...</a><br /></td></tr>
<tr class="separator:ga91b91c8f3fd1797b6b0c44f410e2306a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3739b9e69513e2d3f6509ce70eb36d9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gac3739b9e69513e2d3f6509ce70eb36d9">HW_QSPI_DRIVE_CURRENT</a> { <a class="el" href="group___q_s_p_i.html#ggac3739b9e69513e2d3f6509ce70eb36d9a5a740f1c21d338076513d7023276960f">HW_QSPI_DRIVE_CURRENT_4</a>, 
<a class="el" href="group___q_s_p_i.html#ggac3739b9e69513e2d3f6509ce70eb36d9a7c80a809bde14c8047128f4c3fb1e49c">HW_QSPI_DRIVE_CURRENT_8</a>, 
<a class="el" href="group___q_s_p_i.html#ggac3739b9e69513e2d3f6509ce70eb36d9ac9660f0ad8f7f8061f6297811eeafb29">HW_QSPI_DRIVE_CURRENT_12</a>, 
<a class="el" href="group___q_s_p_i.html#ggac3739b9e69513e2d3f6509ce70eb36d9a989bd9b7c5fadd881bad07cf540560b1">HW_QSPI_DRIVE_CURRENT_16</a>
 }</td></tr>
<tr class="memdesc:gac3739b9e69513e2d3f6509ce70eb36d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI pads drive current.  <a href="group___q_s_p_i.html#gac3739b9e69513e2d3f6509ce70eb36d9">More...</a><br /></td></tr>
<tr class="separator:gac3739b9e69513e2d3f6509ce70eb36d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb860d0ebeb53cccbfc26317303cd8ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gafb860d0ebeb53cccbfc26317303cd8ee">HW_QSPI_DIV</a> { <a class="el" href="group___q_s_p_i.html#ggafb860d0ebeb53cccbfc26317303cd8eea6b310ff17e90bc855644964bf6984646">HW_QSPI_DIV_1</a> = 0, 
<a class="el" href="group___q_s_p_i.html#ggafb860d0ebeb53cccbfc26317303cd8eeaf4929374ed3991d7168494461988e870">HW_QSPI_DIV_2</a> = 1, 
<a class="el" href="group___q_s_p_i.html#ggafb860d0ebeb53cccbfc26317303cd8eea044fd365f86a4db8122048995faeaba5">HW_QSPI_DIV_4</a> = 2, 
<a class="el" href="group___q_s_p_i.html#ggafb860d0ebeb53cccbfc26317303cd8eeaa939831b4f96a852d6f0867f587b2d36">HW_QSPI_DIV_8</a> = 3
 }</td></tr>
<tr class="memdesc:gafb860d0ebeb53cccbfc26317303cd8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI clock divider setting.  <a href="group___q_s_p_i.html#gafb860d0ebeb53cccbfc26317303cd8ee">More...</a><br /></td></tr>
<tr class="separator:gafb860d0ebeb53cccbfc26317303cd8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad5b7b841a461f28fa97d787fac1f1b8a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gad5b7b841a461f28fa97d787fac1f1b8a">hw_qspi_cs_enable</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gad5b7b841a461f28fa97d787fac1f1b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable CS on QSPI bus.  <a href="#gad5b7b841a461f28fa97d787fac1f1b8a">More...</a><br /></td></tr>
<tr class="separator:gad5b7b841a461f28fa97d787fac1f1b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231d7fffdffff851bc249302eb77b0a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga231d7fffdffff851bc249302eb77b0a2">hw_qspi_cs_disable</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga231d7fffdffff851bc249302eb77b0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable CS on QSPI bus.  <a href="#ga231d7fffdffff851bc249302eb77b0a2">More...</a><br /></td></tr>
<tr class="separator:ga231d7fffdffff851bc249302eb77b0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10657932d6ac56e80c632e57cd3210b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gae10657932d6ac56e80c632e57cd3210b">hw_qspi_set_bus_mode</a> (<a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> mode)</td></tr>
<tr class="memdesc:gae10657932d6ac56e80c632e57cd3210b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select QSPI bus mode.  <a href="#gae10657932d6ac56e80c632e57cd3210b">More...</a><br /></td></tr>
<tr class="separator:gae10657932d6ac56e80c632e57cd3210b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4439d60511e35b8c7c6feafbe6637cb4"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga4439d60511e35b8c7c6feafbe6637cb4">hw_qspi_is_busy</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga4439d60511e35b8c7c6feafbe6637cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check is SPI Bus is busy.  <a href="#ga4439d60511e35b8c7c6feafbe6637cb4">More...</a><br /></td></tr>
<tr class="separator:ga4439d60511e35b8c7c6feafbe6637cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcda692405321e29f5dee4863b6c56fd"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gadcda692405321e29f5dee4863b6c56fd">hw_qspi_read32</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gadcda692405321e29f5dee4863b6c56fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 32 bits read transfer on QSPI bus.  <a href="#gadcda692405321e29f5dee4863b6c56fd">More...</a><br /></td></tr>
<tr class="separator:gadcda692405321e29f5dee4863b6c56fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3be01a2264b88bf1f943699f4159745"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gad3be01a2264b88bf1f943699f4159745">hw_qspi_read16</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gad3be01a2264b88bf1f943699f4159745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 16 bits read transfer on QSPI bus.  <a href="#gad3be01a2264b88bf1f943699f4159745">More...</a><br /></td></tr>
<tr class="separator:gad3be01a2264b88bf1f943699f4159745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ade9457c6cc21b627be7acfb990ba8f"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga8ade9457c6cc21b627be7acfb990ba8f">hw_qspi_read8</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga8ade9457c6cc21b627be7acfb990ba8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 8 bits read transfer on QSPI bus.  <a href="#ga8ade9457c6cc21b627be7acfb990ba8f">More...</a><br /></td></tr>
<tr class="separator:ga8ade9457c6cc21b627be7acfb990ba8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38526b8c1079a0db8292c54b5ee371d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gae38526b8c1079a0db8292c54b5ee371d">hw_qspi_write32</a> (uint32_t data) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gae38526b8c1079a0db8292c54b5ee371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 32 bits write transfer on QSPI bus.  <a href="#gae38526b8c1079a0db8292c54b5ee371d">More...</a><br /></td></tr>
<tr class="separator:gae38526b8c1079a0db8292c54b5ee371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125f525240ff800308e2b6ca319d4daf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga125f525240ff800308e2b6ca319d4daf">hw_qspi_write16</a> (uint16_t data) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga125f525240ff800308e2b6ca319d4daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 16 bits write transfer on QSPI bus.  <a href="#ga125f525240ff800308e2b6ca319d4daf">More...</a><br /></td></tr>
<tr class="separator:ga125f525240ff800308e2b6ca319d4daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae264aefe90cfbf35f1d7d0e719a86d52"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gae264aefe90cfbf35f1d7d0e719a86d52">hw_qspi_write8</a> (uint8_t data) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gae264aefe90cfbf35f1d7d0e719a86d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate 8 bits write transfer on QSPI bus.  <a href="#gae264aefe90cfbf35f1d7d0e719a86d52">More...</a><br /></td></tr>
<tr class="separator:gae264aefe90cfbf35f1d7d0e719a86d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacfb9904e2e52c50b86814580676f9cf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gaacfb9904e2e52c50b86814580676f9cf">hw_qspi_dummy32</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gaacfb9904e2e52c50b86814580676f9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a clock pulses to the SPI bus for 32 bits transfer.  <a href="#gaacfb9904e2e52c50b86814580676f9cf">More...</a><br /></td></tr>
<tr class="separator:gaacfb9904e2e52c50b86814580676f9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6888ee5a418f305797934cef0b78cf5a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga6888ee5a418f305797934cef0b78cf5a">hw_qspi_dummy16</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga6888ee5a418f305797934cef0b78cf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a clock pulses to the SPI bus for 16 bits transfer.  <a href="#ga6888ee5a418f305797934cef0b78cf5a">More...</a><br /></td></tr>
<tr class="separator:ga6888ee5a418f305797934cef0b78cf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72870b09cae199d10c385ec72d23e80b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga72870b09cae199d10c385ec72d23e80b">hw_qspi_dummy8</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga72870b09cae199d10c385ec72d23e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a clock pulses to the SPI bus for 8 bits transfer.  <a href="#ga72870b09cae199d10c385ec72d23e80b">More...</a><br /></td></tr>
<tr class="separator:ga72870b09cae199d10c385ec72d23e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938f03d570a2e42cdf83e244048651c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga938f03d570a2e42cdf83e244048651c6">hw_qspi_set_address_size</a> (<a class="el" href="group___q_s_p_i.html#ga7b31012e4ee1a0afdb3bc394f0d97743">HW_QSPI_ADDR_SIZE</a> size) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga938f03d570a2e42cdf83e244048651c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies address with that flash memory uses.  <a href="#ga938f03d570a2e42cdf83e244048651c6">More...</a><br /></td></tr>
<tr class="separator:ga938f03d570a2e42cdf83e244048651c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a95cb3f1f83fe9b67fdfb57a3d49d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___q_s_p_i.html#ga7b31012e4ee1a0afdb3bc394f0d97743">HW_QSPI_ADDR_SIZE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga35a95cb3f1f83fe9b67fdfb57a3d49d3">hw_qspi_get_address_size</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga35a95cb3f1f83fe9b67fdfb57a3d49d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address size that flash memory uses.  <a href="#ga35a95cb3f1f83fe9b67fdfb57a3d49d3">More...</a><br /></td></tr>
<tr class="separator:ga35a95cb3f1f83fe9b67fdfb57a3d49d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4109ebb6a385b0a206f065746ec4d486"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga4109ebb6a385b0a206f065746ec4d486">hw_qspi_force_nseq</a> (uint8_t force) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga4109ebb6a385b0a206f065746ec4d486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls translation of burst accesses form AMBA bus to the QSPI bus.  <a href="#ga4109ebb6a385b0a206f065746ec4d486">More...</a><br /></td></tr>
<tr class="separator:ga4109ebb6a385b0a206f065746ec4d486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeccdbed979366155954ba741f7fc9e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gaeccdbed979366155954ba741f7fc9e14">hw_qspi_set_automode</a> (bool automode)</td></tr>
<tr class="memdesc:gaeccdbed979366155954ba741f7fc9e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable auto mode on QSPI.  <a href="#gaeccdbed979366155954ba741f7fc9e14">More...</a><br /></td></tr>
<tr class="separator:gaeccdbed979366155954ba741f7fc9e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20b72fe8aa486b13d4b7b98bc845639f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga20b72fe8aa486b13d4b7b98bc845639f">hw_qspi_get_automode</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga20b72fe8aa486b13d4b7b98bc845639f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read automode state.  <a href="#ga20b72fe8aa486b13d4b7b98bc845639f">More...</a><br /></td></tr>
<tr class="separator:ga20b72fe8aa486b13d4b7b98bc845639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78fec4c9be4bffe06d6331052770dcfb"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga78fec4c9be4bffe06d6331052770dcfb">hw_qspi_get_read_pipe_clock_delay</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga78fec4c9be4bffe06d6331052770dcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read pipe clock delay.  <a href="#ga78fec4c9be4bffe06d6331052770dcfb">More...</a><br /></td></tr>
<tr class="separator:ga78fec4c9be4bffe06d6331052770dcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecae57ebdaf6fda965b89f8d983660e1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gaecae57ebdaf6fda965b89f8d983660e1">hw_qspi_set_read_pipe_clock_delay</a> (uint8_t delay) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gaecae57ebdaf6fda965b89f8d983660e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set read pipe clock delay.  <a href="#gaecae57ebdaf6fda965b89f8d983660e1">More...</a><br /></td></tr>
<tr class="separator:gaecae57ebdaf6fda965b89f8d983660e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f2c2eaec5f327cda7ad047128d183e"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga66f2c2eaec5f327cda7ad047128d183e">hw_qspi_is_read_pipe_clock_enabled</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga66f2c2eaec5f327cda7ad047128d183e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if read pipe is enabled.  <a href="#ga66f2c2eaec5f327cda7ad047128d183e">More...</a><br /></td></tr>
<tr class="separator:ga66f2c2eaec5f327cda7ad047128d183e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f336c5f8f41c57ce6f91578a67c32a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gaf6f336c5f8f41c57ce6f91578a67c32a">hw_qspi_enable_readpipe</a> (uint8_t enable) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gaf6f336c5f8f41c57ce6f91578a67c32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable read pipe.  <a href="#gaf6f336c5f8f41c57ce6f91578a67c32a">More...</a><br /></td></tr>
<tr class="separator:gaf6f336c5f8f41c57ce6f91578a67c32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc73f18b8779e064572c64bd1360a9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___q_s_p_i.html#ga0f21c08ed361bcc72e6cf6ac96b5a857">HW_QSPI_SAMPLING_EDGE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gadbc73f18b8779e064572c64bd1360a9a">hw_qspi_get_read_sampling_edge</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gadbc73f18b8779e064572c64bd1360a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read sampling edge.  <a href="#gadbc73f18b8779e064572c64bd1360a9a">More...</a><br /></td></tr>
<tr class="separator:gadbc73f18b8779e064572c64bd1360a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22083ece33b110b5edf5bb905dd4f88e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga22083ece33b110b5edf5bb905dd4f88e">hw_qspi_set_read_sampling_edge</a> (<a class="el" href="group___q_s_p_i.html#ga0f21c08ed361bcc72e6cf6ac96b5a857">HW_QSPI_SAMPLING_EDGE</a> edge) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga22083ece33b110b5edf5bb905dd4f88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set read sampling edge.  <a href="#ga22083ece33b110b5edf5bb905dd4f88e">More...</a><br /></td></tr>
<tr class="separator:ga22083ece33b110b5edf5bb905dd4f88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0c9829970dc0c2082a308cc816e155"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga9f0c9829970dc0c2082a308cc816e155">hw_qspi_is_hready_enabled</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga9f0c9829970dc0c2082a308cc816e155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if hready signal is used.  <a href="#ga9f0c9829970dc0c2082a308cc816e155">More...</a><br /></td></tr>
<tr class="separator:ga9f0c9829970dc0c2082a308cc816e155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f6d603db6be9386bc274b19d70bc4f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga67f6d603db6be9386bc274b19d70bc4f">hw_qspi_enable_hready</a> (uint8_t enable) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga67f6d603db6be9386bc274b19d70bc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable adding wait states during register access.  <a href="#ga67f6d603db6be9386bc274b19d70bc4f">More...</a><br /></td></tr>
<tr class="separator:ga67f6d603db6be9386bc274b19d70bc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9299450a0491acbbba2c666537bafa"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gafb9299450a0491acbbba2c666537bafa">hw_qspi_get_clock_mode</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gafb9299450a0491acbbba2c666537bafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get clock mode.  <a href="#gafb9299450a0491acbbba2c666537bafa">More...</a><br /></td></tr>
<tr class="separator:gafb9299450a0491acbbba2c666537bafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07aacf854939e5ada37ccf7c6b2dfdee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga07aacf854939e5ada37ccf7c6b2dfdee">hw_qspi_set_clock_mode</a> (<a class="el" href="group___q_s_p_i.html#ga18d9feb5205b04d978770d17cf117059">HW_QSPI_POL</a> mode) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga07aacf854939e5ada37ccf7c6b2dfdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set clock mode.  <a href="#ga07aacf854939e5ada37ccf7c6b2dfdee">More...</a><br /></td></tr>
<tr class="separator:ga07aacf854939e5ada37ccf7c6b2dfdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd10a7cccd7d6739129ff83f2da183d7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gacd10a7cccd7d6739129ff83f2da183d7">hw_qspi_set_io2_output</a> (bool output) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gacd10a7cccd7d6739129ff83f2da183d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set IO2 direction.  <a href="#gacd10a7cccd7d6739129ff83f2da183d7">More...</a><br /></td></tr>
<tr class="separator:gacd10a7cccd7d6739129ff83f2da183d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga589ed899598c752d0b9eba2dee03888b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga589ed899598c752d0b9eba2dee03888b">hw_qspi_set_io3_output</a> (bool output) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga589ed899598c752d0b9eba2dee03888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set IO3 direction.  <a href="#ga589ed899598c752d0b9eba2dee03888b">More...</a><br /></td></tr>
<tr class="separator:ga589ed899598c752d0b9eba2dee03888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9308bdf1f4115502950271801b858a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gac9308bdf1f4115502950271801b858a9">hw_qspi_set_io2</a> (uint8_t val) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gac9308bdf1f4115502950271801b858a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set state for IO2 when it's configured as output.  <a href="#gac9308bdf1f4115502950271801b858a9">More...</a><br /></td></tr>
<tr class="separator:gac9308bdf1f4115502950271801b858a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabebb6170d2fcf702bb5ffd5db657d4d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gabebb6170d2fcf702bb5ffd5db657d4d0">hw_qspi_set_io3</a> (uint8_t val) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gabebb6170d2fcf702bb5ffd5db657d4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set state for IO3 when it's configured as output.  <a href="#gabebb6170d2fcf702bb5ffd5db657d4d0">More...</a><br /></td></tr>
<tr class="separator:gabebb6170d2fcf702bb5ffd5db657d4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ff090240b1e0308d32dfbd10946b94"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga84ff090240b1e0308d32dfbd10946b94">hw_qspi_get_io2</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga84ff090240b1e0308d32dfbd10946b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read state of IO2 when not in QUAD mode.  <a href="#ga84ff090240b1e0308d32dfbd10946b94">More...</a><br /></td></tr>
<tr class="separator:ga84ff090240b1e0308d32dfbd10946b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a6ebb93f6355b26fa81f41ef52f776"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga55a6ebb93f6355b26fa81f41ef52f776">hw_qspi_get_io3</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga55a6ebb93f6355b26fa81f41ef52f776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read state of IO3 when not in QUAD mode.  <a href="#ga55a6ebb93f6355b26fa81f41ef52f776">More...</a><br /></td></tr>
<tr class="separator:ga55a6ebb93f6355b26fa81f41ef52f776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed450cf7e0fdb8ddb42bd10084d3d2d1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gaed450cf7e0fdb8ddb42bd10084d3d2d1">hw_qspi_set_read_instruction</a> (uint8_t inst, uint8_t send_once, uint8_t dummy_count, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> inst_phase, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> addr_phase, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> dummy_phase, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> data_phase) __attribute((always_inline))</td></tr>
<tr class="memdesc:gaed450cf7e0fdb8ddb42bd10084d3d2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set read instructions for QSPI flash.  <a href="#gaed450cf7e0fdb8ddb42bd10084d3d2d1">More...</a><br /></td></tr>
<tr class="separator:gaed450cf7e0fdb8ddb42bd10084d3d2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga378dd127c329a9a01da346b4f903e191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga378dd127c329a9a01da346b4f903e191">hw_qspi_set_wrapping_burst_instruction</a> (uint8_t inst, <a class="el" href="group___q_s_p_i.html#ga4c4d9a77064663720318bb6fd1077c2e">HW_QSPI_WRAP_LEN</a> len, <a class="el" href="group___q_s_p_i.html#ga9ceb2660e908c030d93e6f4b84d7d667">HW_QSPI_WRAP_SIZE</a> size)</td></tr>
<tr class="memdesc:ga378dd127c329a9a01da346b4f903e191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set wrapping burst read instructions for QSPI flash.  <a href="#ga378dd127c329a9a01da346b4f903e191">More...</a><br /></td></tr>
<tr class="separator:ga378dd127c329a9a01da346b4f903e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cbeb5e33c77c98d8a30931520b3fcb9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga7cbeb5e33c77c98d8a30931520b3fcb9">hw_qspi_set_extra_byte</a> (uint8_t extra_byte, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> bus_mode, uint8_t half_disable_out) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga7cbeb5e33c77c98d8a30931520b3fcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set extra byte to use in read instruction.  <a href="#ga7cbeb5e33c77c98d8a30931520b3fcb9">More...</a><br /></td></tr>
<tr class="separator:ga7cbeb5e33c77c98d8a30931520b3fcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38b094bfde09a376b38c52788fde7ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gae38b094bfde09a376b38c52788fde7ea">hw_qspi_set_dummy_bytes_count</a> (uint8_t count)</td></tr>
<tr class="memdesc:gae38b094bfde09a376b38c52788fde7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set dummy byte count.  <a href="#gae38b094bfde09a376b38c52788fde7ea">More...</a><br /></td></tr>
<tr class="separator:gae38b094bfde09a376b38c52788fde7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6792086d95b45692e11bf1f014137d30"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga6792086d95b45692e11bf1f014137d30">hw_qspi_set_min_cs_high</a> (uint8_t clock_count) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga6792086d95b45692e11bf1f014137d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of clock when CS stays high.  <a href="#ga6792086d95b45692e11bf1f014137d30">More...</a><br /></td></tr>
<tr class="separator:ga6792086d95b45692e11bf1f014137d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbc6a7350ee5115add2ef26d896021f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gacbc6a7350ee5115add2ef26d896021f3">hw_qspi_set_erase_instruction</a> (uint8_t inst, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> inst_phase, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> addr_phase, uint8_t hclk_cycles, uint8_t cs_hi_cycles) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gacbc6a7350ee5115add2ef26d896021f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up erase instructions.  <a href="#gacbc6a7350ee5115add2ef26d896021f3">More...</a><br /></td></tr>
<tr class="separator:gacbc6a7350ee5115add2ef26d896021f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6cd7195036b1c2550619b08d22e09b2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gac6cd7195036b1c2550619b08d22e09b2">hw_qspi_set_write_enable_instruction</a> (uint8_t write_enable, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> inst_phase) __attribute((always_inline))</td></tr>
<tr class="memdesc:gac6cd7195036b1c2550619b08d22e09b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up write enable instruction.  <a href="#gac6cd7195036b1c2550619b08d22e09b2">More...</a><br /></td></tr>
<tr class="separator:gac6cd7195036b1c2550619b08d22e09b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3cf0f9ea69f1451edbde8c09c29b5e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga9a3cf0f9ea69f1451edbde8c09c29b5e">hw_qspi_set_suspend_resume_instructions</a> (uint8_t erase_suspend_inst, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> suspend_inst_phase, uint8_t erase_resume_inst, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> resume_inst_phase, uint8_t minimum_delay) __attribute((always_inline))</td></tr>
<tr class="memdesc:ga9a3cf0f9ea69f1451edbde8c09c29b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up erase suspend/resume instructions.  <a href="#ga9a3cf0f9ea69f1451edbde8c09c29b5e">More...</a><br /></td></tr>
<tr class="separator:ga9a3cf0f9ea69f1451edbde8c09c29b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd0c9143d2a3ef7e6960d2b1e53d0dd2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gacd0c9143d2a3ef7e6960d2b1e53d0dd2">hw_qspi_set_read_status_instruction</a> (uint8_t inst, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> inst_phase, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> receive_phase, uint8_t busy_pos, uint8_t busy_val, uint8_t read_delay, uint8_t sts_delay) __attribute((always_inline))</td></tr>
<tr class="memdesc:gacd0c9143d2a3ef7e6960d2b1e53d0dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set status command.  <a href="#gacd0c9143d2a3ef7e6960d2b1e53d0dd2">More...</a><br /></td></tr>
<tr class="separator:gacd0c9143d2a3ef7e6960d2b1e53d0dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2473438b2b239ba0a5fe42e6d6bc5c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga2473438b2b239ba0a5fe42e6d6bc5c07">hw_qspi_erase_block</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga2473438b2b239ba0a5fe42e6d6bc5c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase block/sector of flash memory.  <a href="#ga2473438b2b239ba0a5fe42e6d6bc5c07">More...</a><br /></td></tr>
<tr class="separator:ga2473438b2b239ba0a5fe42e6d6bc5c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c81e61a64a8dc239eb8f6e857fca7d"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga52c81e61a64a8dc239eb8f6e857fca7d">hw_qspi_get_erase_status</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga52c81e61a64a8dc239eb8f6e857fca7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get erase status.  <a href="#ga52c81e61a64a8dc239eb8f6e857fca7d">More...</a><br /></td></tr>
<tr class="separator:ga52c81e61a64a8dc239eb8f6e857fca7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad31ae546677b70ae9ebd65286bc1b55"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gaad31ae546677b70ae9ebd65286bc1b55">hw_qspi_set_break_sequence</a> (uint16_t sequence, <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a> mode, <a class="el" href="group___q_s_p_i.html#gaac307a660e5a28c297e4c29bd93f69ca">HW_QSPI_BREAK_SEQ_SIZE</a> size, uint8_t dis_out) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gaad31ae546677b70ae9ebd65286bc1b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set burst break sequence.  <a href="#gaad31ae546677b70ae9ebd65286bc1b55">More...</a><br /></td></tr>
<tr class="separator:gaad31ae546677b70ae9ebd65286bc1b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe98a1d06acbe815f7564c5282676e48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe98a1d06acbe815f7564c5282676e48"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gabe98a1d06acbe815f7564c5282676e48">hw_qspi_disable_burst_break_sequence</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gabe98a1d06acbe815f7564c5282676e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable burst break sequence. <br /></td></tr>
<tr class="separator:gabe98a1d06acbe815f7564c5282676e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598bcbce725f2c480ecc9610b12036db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga598bcbce725f2c480ecc9610b12036db">hw_qspi_set_pads</a> (<a class="el" href="group___q_s_p_i.html#ga91b91c8f3fd1797b6b0c44f410e2306a">HW_QSPI_SLEW_RATE</a> rate, <a class="el" href="group___q_s_p_i.html#gac3739b9e69513e2d3f6509ce70eb36d9">HW_QSPI_DRIVE_CURRENT</a> current)</td></tr>
<tr class="memdesc:ga598bcbce725f2c480ecc9610b12036db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set configuration of QSPI pads.  <a href="#ga598bcbce725f2c480ecc9610b12036db">More...</a><br /></td></tr>
<tr class="separator:ga598bcbce725f2c480ecc9610b12036db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb79231e89ded8ce2556fd5ace407251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gafb79231e89ded8ce2556fd5ace407251">hw_qspi_init</a> (const <a class="el" href="structqspi__config.html">qspi_config</a> *cfg)</td></tr>
<tr class="memdesc:gafb79231e89ded8ce2556fd5ace407251"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI controller initialization.  <a href="#gafb79231e89ded8ce2556fd5ace407251">More...</a><br /></td></tr>
<tr class="separator:gafb79231e89ded8ce2556fd5ace407251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d2768ca7a33b1eac486b99e4c31e76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82d2768ca7a33b1eac486b99e4c31e76"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga82d2768ca7a33b1eac486b99e4c31e76">hw_qspi_enable_clock</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga82d2768ca7a33b1eac486b99e4c31e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable QSPI controller clock. <br /></td></tr>
<tr class="separator:ga82d2768ca7a33b1eac486b99e4c31e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d060b2809d1c39ac32d29d894c2227"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae2d060b2809d1c39ac32d29d894c2227"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#gae2d060b2809d1c39ac32d29d894c2227">hw_qspi_disable_clock</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:gae2d060b2809d1c39ac32d29d894c2227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable QSPI controller clock. <br /></td></tr>
<tr class="separator:gae2d060b2809d1c39ac32d29d894c2227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d0aae2c8aa4490a3b2de90d18e7893"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga80d0aae2c8aa4490a3b2de90d18e7893">hw_qspi_set_div</a> (<a class="el" href="group___q_s_p_i.html#gafb860d0ebeb53cccbfc26317303cd8ee">HW_QSPI_DIV</a> div) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga80d0aae2c8aa4490a3b2de90d18e7893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the QSPI clock divider.  <a href="#ga80d0aae2c8aa4490a3b2de90d18e7893">More...</a><br /></td></tr>
<tr class="separator:ga80d0aae2c8aa4490a3b2de90d18e7893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga259a13f6653d99c8a95cdb0ee4516801"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___q_s_p_i.html#gafb860d0ebeb53cccbfc26317303cd8ee">HW_QSPI_DIV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i.html#ga259a13f6653d99c8a95cdb0ee4516801">hw_qspi_get_div</a> (void) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga259a13f6653d99c8a95cdb0ee4516801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the QSPI clock divider.  <a href="#ga259a13f6653d99c8a95cdb0ee4516801">More...</a><br /></td></tr>
<tr class="separator:ga259a13f6653d99c8a95cdb0ee4516801"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>QSPI Flash Memory Controller. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7f2a498b363ea1884c436ec631b02216"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_QSPIC_REG_FIELD_MASK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Msk)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mask of a field of an QSPIC register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>is the register to access </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>is the register field to access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09eacb461c864f71d038185e76fe1cc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_QSPIC_REG_FIELD_POS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Pos)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bit position of a field of an QSPIC register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>is the register to access </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>is the register field to access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e65ec6c339fd99c7ce90b2d9fe37d72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_QSPIC_REG_GETF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((QSPIC-&gt;QSPIC_##reg##_REG &amp; (QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Msk)) &gt;&gt; (QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Pos))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a field of an QSPIC register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>is the register to access </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>is the register field to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the register field </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d6bd4fd9953df170e300d3a76e6fefc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HW_QSPIC_REG_SETF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">new_val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">QSPIC-&gt;QSPIC_##reg##_REG = ((QSPIC-&gt;QSPIC_##reg##_REG &amp; ~(QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Msk)) | \</div>
<div class="line">        ((QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Msk) &amp; ((new_val) &lt;&lt; (QSPIC_QSPIC_##reg##_REG_##QSPIC_##field##_Pos))))</div>
</div><!-- fragment -->
<p>Set the value of a field of an QSPIC register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>is the register to access </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>is the register field to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_val</td><td>is the value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga7b31012e4ee1a0afdb3bc394f0d97743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#ga7b31012e4ee1a0afdb3bc394f0d97743">HW_QSPI_ADDR_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash memory address size. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7b31012e4ee1a0afdb3bc394f0d97743a9bd039cd2cf1bfa5f6b025828c273af8"></a>HW_QSPI_ADDR_SIZE_24&#160;</td><td class="fielddoc">
<p>QSPI flash memory uses 24 bits address </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7b31012e4ee1a0afdb3bc394f0d97743a8162da815fe79d5dd41231e249b7ac1f"></a>HW_QSPI_ADDR_SIZE_32&#160;</td><td class="fielddoc">
<p>QSPI flash memory uses 32 bits address </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaac307a660e5a28c297e4c29bd93f69ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#gaac307a660e5a28c297e4c29bd93f69ca">HW_QSPI_BREAK_SEQ_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of Burst Break Sequence. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaac307a660e5a28c297e4c29bd93f69caa75d28bb2bc33dedd443b2af6f44fde0e"></a>HW_QSPI_BREAK_SEQ_SIZE_1B&#160;</td><td class="fielddoc">
<p>One byte </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaac307a660e5a28c297e4c29bd93f69caa7ae2e070cdfd88cd08cc3def2e334dea"></a>HW_QSPI_BREAK_SEQ_SIZE_2B&#160;</td><td class="fielddoc">
<p>Two bytes </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga604b6c149c9e933d2e6606f2e5bc8f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bus mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga604b6c149c9e933d2e6606f2e5bc8f6caca5039bdedd96187fe41e2c66916b09a"></a>HW_QSPI_BUS_MODE_SINGLE&#160;</td><td class="fielddoc">
<p>Bus mode in single mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga604b6c149c9e933d2e6606f2e5bc8f6cadc76e45c2447138001d3d08ecf9a33b9"></a>HW_QSPI_BUS_MODE_DUAL&#160;</td><td class="fielddoc">
<p>Bus mode in dual mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga604b6c149c9e933d2e6606f2e5bc8f6ca76bb931e961190106991f4252af5a2cd"></a>HW_QSPI_BUS_MODE_QUAD&#160;</td><td class="fielddoc">
<p>Bus mode in quad mode </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gafb860d0ebeb53cccbfc26317303cd8ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#gafb860d0ebeb53cccbfc26317303cd8ee">HW_QSPI_DIV</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI clock divider setting. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggafb860d0ebeb53cccbfc26317303cd8eea6b310ff17e90bc855644964bf6984646"></a>HW_QSPI_DIV_1&#160;</td><td class="fielddoc">
<p>divide by 1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafb860d0ebeb53cccbfc26317303cd8eeaf4929374ed3991d7168494461988e870"></a>HW_QSPI_DIV_2&#160;</td><td class="fielddoc">
<p>divide by 2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafb860d0ebeb53cccbfc26317303cd8eea044fd365f86a4db8122048995faeaba5"></a>HW_QSPI_DIV_4&#160;</td><td class="fielddoc">
<p>divide by 4 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggafb860d0ebeb53cccbfc26317303cd8eeaa939831b4f96a852d6f0867f587b2d36"></a>HW_QSPI_DIV_8&#160;</td><td class="fielddoc">
<p>divide by 8 </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gac3739b9e69513e2d3f6509ce70eb36d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#gac3739b9e69513e2d3f6509ce70eb36d9">HW_QSPI_DRIVE_CURRENT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI pads drive current. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggac3739b9e69513e2d3f6509ce70eb36d9a5a740f1c21d338076513d7023276960f"></a>HW_QSPI_DRIVE_CURRENT_4&#160;</td><td class="fielddoc">
<p>4 mA </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac3739b9e69513e2d3f6509ce70eb36d9a7c80a809bde14c8047128f4c3fb1e49c"></a>HW_QSPI_DRIVE_CURRENT_8&#160;</td><td class="fielddoc">
<p>8 mA </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac3739b9e69513e2d3f6509ce70eb36d9ac9660f0ad8f7f8061f6297811eeafb29"></a>HW_QSPI_DRIVE_CURRENT_12&#160;</td><td class="fielddoc">
<p>12 mA </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac3739b9e69513e2d3f6509ce70eb36d9a989bd9b7c5fadd881bad07cf540560b1"></a>HW_QSPI_DRIVE_CURRENT_16&#160;</td><td class="fielddoc">
<p>16 mA </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga18d9feb5205b04d978770d17cf117059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#ga18d9feb5205b04d978770d17cf117059">HW_QSPI_POL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Idle clock state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga18d9feb5205b04d978770d17cf117059ac6cc54df6eaf9e2fffa89c482d8869a3"></a>HW_QSPI_POL_LOW&#160;</td><td class="fielddoc">
<p>SPI clock will be low at idle </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga18d9feb5205b04d978770d17cf117059ade9c6a47500c67fabc454edc874f58a9"></a>HW_QSPI_POL_HIGH&#160;</td><td class="fielddoc">
<p>SPI clock will be high at idle </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga0f21c08ed361bcc72e6cf6ac96b5a857"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#ga0f21c08ed361bcc72e6cf6ac96b5a857">HW_QSPI_SAMPLING_EDGE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of QSPI_CLK edge for sampling received data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga0f21c08ed361bcc72e6cf6ac96b5a857a414aa8d17c03d3ddf3d11d8075cf5418"></a>HW_QSPI_SAMPLING_EDGE_POSITIVE&#160;</td><td class="fielddoc">
<p>Sample the received data with the positive edge of the QSPI_SCK </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga0f21c08ed361bcc72e6cf6ac96b5a857a3e2c2a1af33ccb1c31c1e55a14192cb4"></a>HW_QSPI_SAMPLING_EDGE_NEGATIVE&#160;</td><td class="fielddoc">
<p>Sample the received data with the negative edge of the QSPI_SCK </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga91b91c8f3fd1797b6b0c44f410e2306a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#ga91b91c8f3fd1797b6b0c44f410e2306a">HW_QSPI_SLEW_RATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI pads slew rate control. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga91b91c8f3fd1797b6b0c44f410e2306aa8ad13336cbb2430f91fb17c64f3327b4"></a>HW_QSPI_SLEW_RATE_0&#160;</td><td class="fielddoc">
<p>xx V/ns (weak) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91b91c8f3fd1797b6b0c44f410e2306aabfd6638bd2b629025d94ff09cd7c22f2"></a>HW_QSPI_SLEW_RATE_1&#160;</td><td class="fielddoc">
<p>xx V/ns </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91b91c8f3fd1797b6b0c44f410e2306aa5db696c827bffdac904828d4e5ce0f4e"></a>HW_QSPI_SLEW_RATE_2&#160;</td><td class="fielddoc">
<p>xx V/ns </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91b91c8f3fd1797b6b0c44f410e2306aa8dea3b352e948851a28252668a6888ab"></a>HW_QSPI_SLEW_RATE_3&#160;</td><td class="fielddoc">
<p>xx V/ns (strong) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4c4d9a77064663720318bb6fd1077c2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#ga4c4d9a77064663720318bb6fd1077c2e">HW_QSPI_WRAP_LEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selected data length of a wrapping burst. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4c4d9a77064663720318bb6fd1077c2ea7bfd0c3a41f0ae5cae1ce881d7e14af0"></a>HW_QSPI_WRAP_LEN_4BEAT&#160;</td><td class="fielddoc">
<p>4 beat wrapping burst </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4c4d9a77064663720318bb6fd1077c2ea362b71768c888d4052802dc5753133e5"></a>HW_QSPI_WRAP_LEN_8BEAT&#160;</td><td class="fielddoc">
<p>8 beat wrapping burst </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4c4d9a77064663720318bb6fd1077c2ea4d1c86b71566a3f8726cd9666428f3ea"></a>HW_QSPI_WRAP_LEN_16BEAT&#160;</td><td class="fielddoc">
<p>16 beat wrapping burst </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9ceb2660e908c030d93e6f4b84d7d667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___q_s_p_i.html#ga9ceb2660e908c030d93e6f4b84d7d667">HW_QSPI_WRAP_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selected data size of a wrapping burst. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9ceb2660e908c030d93e6f4b84d7d667a76375cbd5c163750c9cd23b340b78cee"></a>HW_QSPI_WRAP_SIZE_8BITS&#160;</td><td class="fielddoc">
<p>Byte access (8-bits) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9ceb2660e908c030d93e6f4b84d7d667af94a3b5fce9ec384832ec271cbeac26e"></a>HW_QSPI_WRAP_SIZE_16BITS&#160;</td><td class="fielddoc">
<p>Half word access (8-bits) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9ceb2660e908c030d93e6f4b84d7d667a6e29a654c746ce92b5f87fbe2bda93f6"></a>HW_QSPI_WRAP_SIZE_32BITS&#160;</td><td class="fielddoc">
<p>Word access (8-bits) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga231d7fffdffff851bc249302eb77b0a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_cs_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable CS on QSPI bus. </p>
<p>Use this in manual mode. </p>

</div>
</div>
<a class="anchor" id="gad5b7b841a461f28fa97d787fac1f1b8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_cs_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable CS on QSPI bus. </p>
<p>Use this in manual mode. </p>

</div>
</div>
<a class="anchor" id="ga6888ee5a418f305797934cef0b78cf5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_dummy16 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a clock pulses to the SPI bus for 16 bits transfer. </p>
<p>During this activity in the SPI bus, the QSPI_IOx data pads are in hi-z state. Number of pulses depends on selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). </p>

</div>
</div>
<a class="anchor" id="gaacfb9904e2e52c50b86814580676f9cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_dummy32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a clock pulses to the SPI bus for 32 bits transfer. </p>
<p>During this activity in the SPI bus, the QSPI_IOx data pads are in hi-z state. Number of pulses depends on selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). </p>

</div>
</div>
<a class="anchor" id="ga72870b09cae199d10c385ec72d23e80b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_dummy8 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a clock pulses to the SPI bus for 8 bits transfer. </p>
<p>During this activity in the SPI bus, the QSPI_IOx data pads are in hi-z state. Number of pulses depends on selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). </p>

</div>
</div>
<a class="anchor" id="ga67f6d603db6be9386bc274b19d70bc4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_enable_hready </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable/disable adding wait states during register access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>0 - wait states will be added in hready signal during access to QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf6f336c5f8f41c57ce6f91578a67c32a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_enable_readpipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable read pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>1 enable read pipe, 0 disable read pipe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2473438b2b239ba0a5fe42e6d6bc5c07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_qspi_erase_block </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase block/sector of flash memory. </p>
<p>For this function to work, erase instructions must be set up with hw_qspi_set_erase_instruction. User should call hw_qspi_get_erase_status to check if block erased.</p>
<dl class="section note"><dt>Note</dt><dd>If user doesn't call hw_qspi_get_erase_status that returns status 0 QSPI controller will not be able to switch to manual mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>memory address of block/sector thats is requested to be erased for 24 bits addressing, bits [23:12] determine the block/sector address bits. Bits [11:0] are ignored by the controller. For 32 bits addressing, bits [31:12] determine the block/sectors address bits. Bits [11:0] are ignored by the controller</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#gacbc6a7350ee5115add2ef26d896021f3" title="Set up erase instructions. ">hw_qspi_set_erase_instruction</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#ga52c81e61a64a8dc239eb8f6e857fca7d" title="Get erase status. ">hw_qspi_get_erase_status</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#gaeccdbed979366155954ba741f7fc9e14" title="Enable or disable auto mode on QSPI. ">hw_qspi_set_automode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4109ebb6a385b0a206f065746ec4d486"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_force_nseq </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>force</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls translation of burst accesses form AMBA bus to the QSPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>0 - controller translates a burst access on the AMBA bus to a burst access on the QSPI bus. That results to a minimum command/address phases, but the QSPI_CS is low for as long as the access occures, 1 - controller will split a burst access on the AMBA bus into single accesses on the qspi bus. This results to a separate read command to the FLASH memory foreach data required. A 4-beat word incremental AMBA access will be split into 4 different sequences of reading (command/address/ extra clock/read data). QSPI_CS will be only high while a qspi access occures. This results to lower power dissipation with respect to QSPIC_FORCENSEQ_EN=0 at cost of performance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35a95cb3f1f83fe9b67fdfb57a3d49d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___q_s_p_i.html#ga7b31012e4ee1a0afdb3bc394f0d97743">HW_QSPI_ADDR_SIZE</a> hw_qspi_get_address_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get address size that flash memory uses. </p>
<p>The controller uses 32 of 24 bits for address during Auto mode transfer.</p>
<dl class="section return"><dt>Returns</dt><dd>currently selected address size</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#ga938f03d570a2e42cdf83e244048651c6" title="Specifies address with that flash memory uses. ">hw_qspi_set_address_size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga20b72fe8aa486b13d4b7b98bc845639f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hw_qspi_get_automode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read automode state. </p>
<dl class="section return"><dt>Returns</dt><dd>true auto mode is selected, false manual mode is selected </dd></dl>

</div>
</div>
<a class="anchor" id="gafb9299450a0491acbbba2c666537bafa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_qspi_get_clock_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get clock mode. </p>
<dl class="section return"><dt>Returns</dt><dd>0 - SPI mode 0 is used for QSPI_CLK, the QSPI_SCK is low when QSPI_CS is high (idle), 1 - SPI mode 3 is used for QSPI_CLK, the QSPI_SCK is high when QSPI_CS is high (idle) </dd></dl>

</div>
</div>
<a class="anchor" id="ga259a13f6653d99c8a95cdb0ee4516801"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___q_s_p_i.html#gafb860d0ebeb53cccbfc26317303cd8ee">HW_QSPI_DIV</a> hw_qspi_get_div </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the QSPI clock divider. </p>
<dl class="section return"><dt>Returns</dt><dd>the QSPI clock divider setting</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#gafb860d0ebeb53cccbfc26317303cd8ee" title="QSPI clock divider setting. ">HW_QSPI_DIV</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga52c81e61a64a8dc239eb8f6e857fca7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_qspi_get_erase_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get erase status. </p>
<dl class="section return"><dt>Returns</dt><dd>progress of sector/block erasing 0 = no erase, 1 = pending erase request, 2 = erase procedure is running, 3 = suspended erase procedure, 4 = finishing the erase procedure </dd></dl>

</div>
</div>
<a class="anchor" id="ga84ff090240b1e0308d32dfbd10946b94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_qspi_get_io2 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read state of IO2 when not in QUAD mode. </p>
<dl class="section return"><dt>Returns</dt><dd>value of IO2 pin (0 or 1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga55a6ebb93f6355b26fa81f41ef52f776"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_qspi_get_io3 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read state of IO3 when not in QUAD mode. </p>
<dl class="section return"><dt>Returns</dt><dd>value of IO3 pin (0 or 1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga78fec4c9be4bffe06d6331052770dcfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_qspi_get_read_pipe_clock_delay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get read pipe clock delay. </p>
<dl class="section return"><dt>Returns</dt><dd>read pipe clock delay relative to the falling edge of QSPI_SCK </dd></dl>

</div>
</div>
<a class="anchor" id="gadbc73f18b8779e064572c64bd1360a9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___q_s_p_i.html#ga0f21c08ed361bcc72e6cf6ac96b5a857">HW_QSPI_SAMPLING_EDGE</a> hw_qspi_get_read_sampling_edge </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get read sampling edge. </p>
<dl class="section return"><dt>Returns</dt><dd>type of QSPI_CLK edge for sampling received data </dd></dl>

</div>
</div>
<a class="anchor" id="gafb79231e89ded8ce2556fd5ace407251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_qspi_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structqspi__config.html">qspi_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI controller initialization. </p>
<p>This function will enable QSPI controller in manual mode.</p>
<dl class="section note"><dt>Note</dt><dd>This function doesn't change QSPI_DIV </dd></dl>

</div>
</div>
<a class="anchor" id="ga4439d60511e35b8c7c6feafbe6637cb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_qspi_is_busy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check is SPI Bus is busy. </p>
<dl class="section return"><dt>Returns</dt><dd>0 - SPI Bus is idle, 1 - SPI Bus is active. ReadData, WriteData or DummyData activity is in progress </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f0c9829970dc0c2082a308cc816e155"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_qspi_is_hready_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if hready signal is used. </p>
<dl class="section return"><dt>Returns</dt><dd>0 - when wait states are not added via hready signal during access to QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers, 1 - when wait states are added via hready signal during access to QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers. In this case read read QSPI_STATUS register to check the end of activity at the SPI bus </dd></dl>

</div>
</div>
<a class="anchor" id="ga66f2c2eaec5f327cda7ad047128d183e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_qspi_is_read_pipe_clock_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if read pipe is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if read pipe is enabled, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gad3be01a2264b88bf1f943699f4159745"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t hw_qspi_read16 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate 16 bits read transfer on QSPI bus. </p>
<p>The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI).</p>
<dl class="section return"><dt>Returns</dt><dd>data read during read transfer </dd></dl>

</div>
</div>
<a class="anchor" id="gadcda692405321e29f5dee4863b6c56fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t hw_qspi_read32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate 32 bits read transfer on QSPI bus. </p>
<p>The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI).</p>
<dl class="section return"><dt>Returns</dt><dd>data read during read transfer </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ade9457c6cc21b627be7acfb990ba8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t hw_qspi_read8 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate 8 bits read transfer on QSPI bus. </p>
<p>The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI).</p>
<dl class="section return"><dt>Returns</dt><dd>data read during read transfer </dd></dl>

</div>
</div>
<a class="anchor" id="ga938f03d570a2e42cdf83e244048651c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_address_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga7b31012e4ee1a0afdb3bc394f0d97743">HW_QSPI_ADDR_SIZE</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies address with that flash memory uses. </p>
<p>The controller uses 32 of 24 bits for address during Auto mode transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>selects 32 or 24 address size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeccdbed979366155954ba741f7fc9e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_qspi_set_automode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>automode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable auto mode on QSPI. </p>
<dl class="section note"><dt>Note</dt><dd>Selecting auto mode when any command previously configured has chosen QUAD mode for any phase will automatically configure pins IO2 and IO3 to input.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">automode</td><td>true auto mode selected, false manual mode selected</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#gaed450cf7e0fdb8ddb42bd10084d3d2d1" title="Set read instructions for QSPI flash. ">hw_qspi_set_read_instruction</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#gacd0c9143d2a3ef7e6960d2b1e53d0dd2" title="Set status command. ">hw_qspi_set_read_status_instruction</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#ga9a3cf0f9ea69f1451edbde8c09c29b5e" title="Set up erase suspend/resume instructions. ">hw_qspi_set_suspend_resume_instructions</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#gac6cd7195036b1c2550619b08d22e09b2" title="Set up write enable instruction. ">hw_qspi_set_write_enable_instruction</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#ga7cbeb5e33c77c98d8a30931520b3fcb9" title="Set extra byte to use in read instruction. ">hw_qspi_set_extra_byte</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#gacbc6a7350ee5115add2ef26d896021f3" title="Set up erase instructions. ">hw_qspi_set_erase_instruction</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#gaad31ae546677b70ae9ebd65286bc1b55" title="Set burst break sequence. ">hw_qspi_set_break_sequence</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaad31ae546677b70ae9ebd65286bc1b55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_break_sequence </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#gaac307a660e5a28c297e4c29bd93f69ca">HW_QSPI_BREAK_SEQ_SIZE</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dis_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set burst break sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sequence</td><td>value will be transmitted as the burst break sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode of the QSPI Bus during the transmission of the burst break sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of Burst Break Sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dis_out</td><td>disable output during the transmission of the second half (sequence[3:0]). Setting this bit is only useful if size = 1. 0 - controller drives the QSPI bus during the transmission of the sequence[3:0], 1 - controller leaves the QSPI bus in Hi-Z during the transmission of the sequence[3:0] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae10657932d6ac56e80c632e57cd3210b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_qspi_set_bus_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select QSPI bus mode. </p>
<p>Use this in manual mode.</p>
<dl class="section note"><dt>Note</dt><dd>Selecting QUAD mode will automatically configure pins IO2 and IO3 to input.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>selects single/dual/quad mode for QSPI bus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga07aacf854939e5ada37ccf7c6b2dfdee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_clock_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga18d9feb5205b04d978770d17cf117059">HW_QSPI_POL</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set clock mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>HW_SPI_POL_LOW - SPI mode 0 is used for QSPI_CLK, The QSPI_SCK is low when QSPI_CS is high (idle), HW_SPI_POL_HIGH - SPI mode 3 is used for QSPI_CLK, The QSPI_SCK is high when QSPI_CS is high (idle) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga80d0aae2c8aa4490a3b2de90d18e7893"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#gafb860d0ebeb53cccbfc26317303cd8ee">HW_QSPI_DIV</a>&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the QSPI clock divider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">div</td><td>QSPI clock divider</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#gafb860d0ebeb53cccbfc26317303cd8ee" title="QSPI clock divider setting. ">HW_QSPI_DIV</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae38b094bfde09a376b38c52788fde7ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_qspi_set_dummy_bytes_count </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set dummy byte count. </p>
<p>Number of dummy bytes to send when read instruction is executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of dummy bytes to send 0..4 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacbc6a7350ee5115add2ef26d896021f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_erase_instruction </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>inst_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>addr_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hclk_cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cs_hi_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up erase instructions. </p>
<p>Instruction will be send after call to hw_qspi_erase_block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inst</td><td>code value of the erase instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inst_phase</td><td>mode of the QSPI Bus during the instruction phase of the erase instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_phase</td><td>the mode of the QSPI Bus during the address phase of the erase instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hclk_cycles</td><td>the controller must stay without flash memory reading requests for this number of AMBA AHB hclk cycles, before performs the command of erase or resume 15 - 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs_hi_cycles</td><td>after the execution of instructions: write enable, erase, erase suspend and erase resume, the QSPI_CS remains high for at least this number of qspi bus clock cycles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#ga2473438b2b239ba0a5fe42e6d6bc5c07" title="Erase block/sector of flash memory. ">hw_qspi_erase_block</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7cbeb5e33c77c98d8a30931520b3fcb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_extra_byte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>extra_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>bus_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>half_disable_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set extra byte to use in read instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extra_byte</td><td>the value of an extra byte which will be transferred after address. This byte is used for telling memory if it should stay in continuous read mode or wait for normal instruction after CS goes inactive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_mode</td><td>describes the mode of the SPI bus during the extra byte phase. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">half_disable_out</td><td>1 - disable (hi-z) output during the transmission of bits [3:0] of extra byte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#gaed450cf7e0fdb8ddb42bd10084d3d2d1" title="Set read instructions for QSPI flash. ">hw_qspi_set_read_instruction</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac9308bdf1f4115502950271801b858a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_io2 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set state for IO2 when it's configured as output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>QSPI_IO2 value to set (0 or 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>hw_qspi_set_io2_direction </dd></dl>

</div>
</div>
<a class="anchor" id="gacd10a7cccd7d6739129ff83f2da183d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_io2_output </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set IO2 direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>QSPI_IO2 output enable. Use this only in SPI or Dual SPI mode to control /WP signal. When the Auto Mode is selected and the QUAD SPI is used, set this to false. false: The QSPI_IO2 pad is input true: The QSPI_IO2 pad is output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabebb6170d2fcf702bb5ffd5db657d4d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_io3 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set state for IO3 when it's configured as output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>QSPI_IO3 value to set (0 or 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>hw_qspi_set_io3_direction </dd></dl>

</div>
</div>
<a class="anchor" id="ga589ed899598c752d0b9eba2dee03888b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_io3_output </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set IO3 direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">output</td><td>Use this only in SPI or Dual SPI mode to control /HOLD signal. When the Auto Mode is selected and the QUAD SPI is used, set this to false. false: The QSPI_IO3 pad is input, true: The QSPI_IO3 pad is output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6792086d95b45692e11bf1f014137d30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_min_cs_high </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>clock_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set number of clock when CS stays high. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clock_count</td><td>between the transmission of two different instructions to the flash memory, the qspi bus stays in idle state (QSPI_CS high) for at least this number of spi clock cycles. See the QSPIC_ERS_CS_HI register for an exception </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga598bcbce725f2c480ecc9610b12036db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_qspi_set_pads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga91b91c8f3fd1797b6b0c44f410e2306a">HW_QSPI_SLEW_RATE</a>&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#gac3739b9e69513e2d3f6509ce70eb36d9">HW_QSPI_DRIVE_CURRENT</a>&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set configuration of QSPI pads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rate</td><td>QSPI pads slew rate control </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">current</td><td>QSPI pads drive current </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaed450cf7e0fdb8ddb42bd10084d3d2d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_read_instruction </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>send_once</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dummy_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>inst_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>addr_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>dummy_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>data_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set read instructions for QSPI flash. </p>
<p>This function sets up instruction to be sent to flash memory when data is requested on AHB bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inst</td><td>instruction for Incremental Burst or Single read access. This value is the selected instruction at the cases of incremental burst or single read access. Also this value is used when a wrapping burst is not supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">send_once</td><td>0 - transmit instruction at any burst access, 1 - transmit instruction only in the first access after the selection of Auto Mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dummy_count</td><td>number of dummy bytes to send 0..4 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inst_phase</td><td>describes the mode of the SPI bus during the instruction phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_phase</td><td>describes the mode of the SPI bus during the address phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dummy_phase</td><td>describes the mode of the SPI bus during the dummy phase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_phase</td><td>describes the mode of the SPI bus during the data phase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#ga7cbeb5e33c77c98d8a30931520b3fcb9" title="Set extra byte to use in read instruction. ">hw_qspi_set_extra_byte</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#ga378dd127c329a9a01da346b4f903e191" title="Set wrapping burst read instructions for QSPI flash. ">hw_qspi_set_wrapping_burst_instruction</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaecae57ebdaf6fda965b89f8d983660e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_read_pipe_clock_delay </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set read pipe clock delay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>read pipe clock delay relative to the falling edge of QSPI_SCK value should be in range 0..7 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga22083ece33b110b5edf5bb905dd4f88e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_read_sampling_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga0f21c08ed361bcc72e6cf6ac96b5a857">HW_QSPI_SAMPLING_EDGE</a>&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set read sampling edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">edge</td><td>sets whether read samples or taken on rising or falling edge of QSPI_SCK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacd0c9143d2a3ef7e6960d2b1e53d0dd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_read_status_instruction </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>inst_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>receive_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>busy_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>busy_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>read_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sts_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set status command. </p>
<p>This command will be send by QSPI controller when it needs to check status of flash memory. This command is also send indirectly when hw_qspi_get_erase_status is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inst</td><td>instruction for read status </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inst_phase</td><td>mode of the QSPI Bus during the instruction phase of the read status instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">receive_phase</td><td>mode of the QSPI Bus during the receive status phase of the read status instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">busy_pos</td><td>it describes which bit from the bits of status represents the Busy bit (7 - 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">busy_val</td><td>defines the value of the Busy bit which means that the flash is busy 0 - flash is busy when the Busy bit is equal to 0, 1 - flash is busy when the Busy bit is equal to 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_delay</td><td>defines the minimum time distance between the instruction read status register and previous instructions like erase or resume. The same delay will be also applied after the Erase command. 0 - don't wait. The controller starts to read the Flash memory status register immediately. 1..63 - controller waits at least the number of QSPI_CLK cycles and afterwards it starts to read the Flash memory status register. Time starts counting after the end of the previous erase/resume. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sts_delay</td><td>defines the register to count the delay to wait for the FLASH Status Register read after an erase or erase/ resume command. 0 - delay is controlled by the <code>read_dealy</code> (QSPIC_RESSTS_DLY) which counts on the qspi clock, 1 - delay is controlled by the <code>minimum_delay</code> value passed to hw_qspi_set_suspend_resume_instructions (QSPIC_RESSUS_DLY) which counts on the 288 kHz clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#ga9a3cf0f9ea69f1451edbde8c09c29b5e" title="Set up erase suspend/resume instructions. ">hw_qspi_set_suspend_resume_instructions</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#ga52c81e61a64a8dc239eb8f6e857fca7d" title="Get erase status. ">hw_qspi_get_erase_status</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a3cf0f9ea69f1451edbde8c09c29b5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_suspend_resume_instructions </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>erase_suspend_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>suspend_inst_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>erase_resume_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>resume_inst_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>minimum_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up erase suspend/resume instructions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">erase_suspend_inst</td><td>code value of the erase suspend instruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suspend_inst_phase</td><td>mode of the QSPI Bus during the instruction phase of the suspend instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">erase_resume_inst</td><td>code value of the erase resume instruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resume_inst_phase</td><td>mode of the QSPI Bus during the instruction phase of the resume instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minimum_delay</td><td>defines the minimum time distance between the instruction erase suspend and the previous instruction erase resume. This delay will be also applied after the Erase command. 0 - don't wait. The controller starts the erase suspend procedure immediately, 1..63 - controller waits at least this number of 288kHz clock cycles before the suspension of erasing. Time starts counting after the end of the previous erase resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga378dd127c329a9a01da346b4f903e191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hw_qspi_set_wrapping_burst_instruction </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga4c4d9a77064663720318bb6fd1077c2e">HW_QSPI_WRAP_LEN</a>&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga9ceb2660e908c030d93e6f4b84d7d667">HW_QSPI_WRAP_SIZE</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set wrapping burst read instructions for QSPI flash. </p>
<p>Calling this function will set up wrapping burst instruction to use. Use this feature only when the serial FLASH memory supports a special instruction for wrapping burst access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inst</td><td>instruction for Wrapping Burst </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>describes the selected length of a wrapping burst </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>describes the selected data size of a wrapping burst </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac6cd7195036b1c2550619b08d22e09b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_set_write_enable_instruction </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>write_enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___q_s_p_i.html#ga604b6c149c9e933d2e6606f2e5bc8f6c">HW_QSPI_BUS_MODE</a>&#160;</td>
          <td class="paramname"><em>inst_phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set up write enable instruction. </p>
<p>Instruction setup by this function will be executed before erase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">write_enable</td><td>code value of the write enable instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inst_phase</td><td>mode of the QSPI Bus during the instruction phase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___q_s_p_i.html#ga2473438b2b239ba0a5fe42e6d6bc5c07" title="Erase block/sector of flash memory. ">hw_qspi_erase_block</a> </dd>
<dd>
<a class="el" href="group___q_s_p_i.html#gacbc6a7350ee5115add2ef26d896021f3" title="Set up erase instructions. ">hw_qspi_set_erase_instruction</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga125f525240ff800308e2b6ca319d4daf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_write16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate 16 bits write transfer on QSPI bus. </p>
<p>The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI).</p>
<p>param [in] data data to transfer </p>

</div>
</div>
<a class="anchor" id="gae38526b8c1079a0db8292c54b5ee371d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_write32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate 32 bits write transfer on QSPI bus. </p>
<p>The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI).</p>
<p>param [in] data data to transfer </p>

</div>
</div>
<a class="anchor" id="gae264aefe90cfbf35f1d7d0e719a86d52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hw_qspi_write8 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate 8 bits write transfer on QSPI bus. </p>
<p>The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI).</p>
<p>param [in] data data to transfer </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:06 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
