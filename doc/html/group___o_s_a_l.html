<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: OSAL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">OSAL<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>OS Abstraction Layer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___m_s_g___q_u_e_u_e_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_s_g___q_u_e_u_e_s.html">MSG_QUEUES</a></td></tr>
<tr class="memdesc:group___m_s_g___q_u_e_u_e_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">OSAL message queues. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___r_e_s_o_u_r_c_e___m_a_n_a_g_e_m_e_n_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___r_e_s_o_u_r_c_e___m_a_n_a_g_e_m_e_n_t.html">RESOURCE_MANAGEMENT</a></td></tr>
<tr class="memdesc:group___r_e_s_o_u_r_c_e___m_a_n_a_g_e_m_e_n_t"><td class="mdescLeft">&#160;</td><td class="mdescRight">OSAL resource management. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:osal_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="osal_8h.html">osal.h</a></td></tr>
<tr class="memdesc:osal_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS abstraction layer API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8a68360ed332a7a45f9a44af68f56ac9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga8a68360ed332a7a45f9a44af68f56ac9">OS_TIME_TO_TICKS</a>(time_in_ms)&#160;&#160;&#160;pdMS_TO_TICKS(time_in_ms)</td></tr>
<tr class="memdesc:ga8a68360ed332a7a45f9a44af68f56ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a time in milliseconds to a time in ticks.  <a href="#ga8a68360ed332a7a45f9a44af68f56ac9">More...</a><br /></td></tr>
<tr class="separator:ga8a68360ed332a7a45f9a44af68f56ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1a837adbf0d7c4cd6f4c86c5012563"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga6a1a837adbf0d7c4cd6f4c86c5012563">OS_GET_CURRENT_TASK</a>()&#160;&#160;&#160;xTaskGetCurrentTaskHandle()</td></tr>
<tr class="memdesc:ga6a1a837adbf0d7c4cd6f4c86c5012563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current OS task handle.  <a href="#ga6a1a837adbf0d7c4cd6f4c86c5012563">More...</a><br /></td></tr>
<tr class="separator:ga6a1a837adbf0d7c4cd6f4c86c5012563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2a5564afaf810733986c2326a323be2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaf2a5564afaf810733986c2326a323be2">OS_TASK_CREATE</a>(name,  task_func,  arg,  stack_size,  priority,  task)</td></tr>
<tr class="memdesc:gaf2a5564afaf810733986c2326a323be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS task.  <a href="#gaf2a5564afaf810733986c2326a323be2">More...</a><br /></td></tr>
<tr class="separator:gaf2a5564afaf810733986c2326a323be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a73ccb253999f6d79b6985c097fb4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga24a73ccb253999f6d79b6985c097fb4e">OS_TASK_DELETE</a>(task)&#160;&#160;&#160;vTaskDelete(task)</td></tr>
<tr class="memdesc:ga24a73ccb253999f6d79b6985c097fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete OS task.  <a href="#ga24a73ccb253999f6d79b6985c097fb4e">More...</a><br /></td></tr>
<tr class="separator:ga24a73ccb253999f6d79b6985c097fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8dafae5ca6f00ee8ce776ae1212fd5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gabd8dafae5ca6f00ee8ce776ae1212fd5">OS_TASK_PRIORITY_GET</a>(task)&#160;&#160;&#160;uxTaskPriorityGet(task)</td></tr>
<tr class="memdesc:gabd8dafae5ca6f00ee8ce776ae1212fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority of an OS task.  <a href="#gabd8dafae5ca6f00ee8ce776ae1212fd5">More...</a><br /></td></tr>
<tr class="separator:gabd8dafae5ca6f00ee8ce776ae1212fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02bb1b8afdd47bf1031e94aceaf19865"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga02bb1b8afdd47bf1031e94aceaf19865">OS_TASK_PRIORITY_SET</a>(task,  prio)&#160;&#160;&#160;vTaskPrioritySet(task, prio)</td></tr>
<tr class="memdesc:ga02bb1b8afdd47bf1031e94aceaf19865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of an OS task.  <a href="#ga02bb1b8afdd47bf1031e94aceaf19865">More...</a><br /></td></tr>
<tr class="separator:ga02bb1b8afdd47bf1031e94aceaf19865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b95512f360b2980c30404776efc2a21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga9b95512f360b2980c30404776efc2a21">OS_TASK_YIELD</a>()&#160;&#160;&#160;portYIELD()</td></tr>
<tr class="memdesc:ga9b95512f360b2980c30404776efc2a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The running OS task yields control to the scheduler.  <a href="#ga9b95512f360b2980c30404776efc2a21">More...</a><br /></td></tr>
<tr class="separator:ga9b95512f360b2980c30404776efc2a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f2215f0acf1afbe553051eda1972f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga00f2215f0acf1afbe553051eda1972f2">OS_TASK_NOTIFY</a>(task,  value,  action)&#160;&#160;&#160;xTaskNotify((task), (value), (action))</td></tr>
<tr class="memdesc:ga00f2215f0acf1afbe553051eda1972f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event directly to task.  <a href="#ga00f2215f0acf1afbe553051eda1972f2">More...</a><br /></td></tr>
<tr class="separator:ga00f2215f0acf1afbe553051eda1972f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5eac367a1d83149f77bf4cd28d6a93e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaf5eac367a1d83149f77bf4cd28d6a93e">OS_TASK_NOTIFY_AND_QUERY</a>(task,  value,  action,  prev_value)</td></tr>
<tr class="memdesc:gaf5eac367a1d83149f77bf4cd28d6a93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify OS task sending an event and return previous notification value.  <a href="#gaf5eac367a1d83149f77bf4cd28d6a93e">More...</a><br /></td></tr>
<tr class="separator:gaf5eac367a1d83149f77bf4cd28d6a93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c0bb07f14dea53797a0a922d27dbdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga41c0bb07f14dea53797a0a922d27dbdc">OS_TASK_NOTIFY_FROM_ISR</a>(task,  value,  action)</td></tr>
<tr class="memdesc:ga41c0bb07f14dea53797a0a922d27dbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an event and unblock OS task with updating notification value.  <a href="#ga41c0bb07f14dea53797a0a922d27dbdc">More...</a><br /></td></tr>
<tr class="separator:ga41c0bb07f14dea53797a0a922d27dbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922cdffae7bfcabc3e3a29e2521365b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga922cdffae7bfcabc3e3a29e2521365b4">OS_TASK_NOTIFY_GIVE</a>(task)&#160;&#160;&#160;xTaskNotifyGive(task)</td></tr>
<tr class="memdesc:ga922cdffae7bfcabc3e3a29e2521365b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify task and receive OS task notification value.  <a href="#ga922cdffae7bfcabc3e3a29e2521365b4">More...</a><br /></td></tr>
<tr class="separator:ga922cdffae7bfcabc3e3a29e2521365b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073a550e64dbb4b8b4acfd9c83370775"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga073a550e64dbb4b8b4acfd9c83370775">OS_TASK_NOTIFY_GIVE_FROM_ISR</a>(task)</td></tr>
<tr class="memdesc:ga073a550e64dbb4b8b4acfd9c83370775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify task from ISR.  <a href="#ga073a550e64dbb4b8b4acfd9c83370775">More...</a><br /></td></tr>
<tr class="separator:ga073a550e64dbb4b8b4acfd9c83370775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a3bb58bc89af3bb73c75bb4fa8644e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e">OS_TASK_NOTIFY_TAKE</a>(clear_on_exit,  time_to_wait)</td></tr>
<tr class="memdesc:gaf7a3bb58bc89af3bb73c75bb4fa8644e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear to zero or decrement task notification value on exit.  <a href="#gaf7a3bb58bc89af3bb73c75bb4fa8644e">More...</a><br /></td></tr>
<tr class="separator:gaf7a3bb58bc89af3bb73c75bb4fa8644e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbdd8702f6b22611d3cc340602a427d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gafbdd8702f6b22611d3cc340602a427d8">OS_TASK_NOTIFY_WAIT</a>(entry_bits,  exit_bits,  value,  ticks_to_wait)</td></tr>
<tr class="memdesc:gafbdd8702f6b22611d3cc340602a427d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the calling task to receive a notification.  <a href="#gafbdd8702f6b22611d3cc340602a427d8">More...</a><br /></td></tr>
<tr class="separator:gafbdd8702f6b22611d3cc340602a427d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00c9c3498aa76bf2a427f415a2ef5fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gac00c9c3498aa76bf2a427f415a2ef5fa">OS_TASK_RESUME</a>(task)&#160;&#160;&#160;vTaskResume(task)</td></tr>
<tr class="memdesc:gac00c9c3498aa76bf2a427f415a2ef5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume task.  <a href="#gac00c9c3498aa76bf2a427f415a2ef5fa">More...</a><br /></td></tr>
<tr class="separator:gac00c9c3498aa76bf2a427f415a2ef5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4dfac299a63b8d1205d72d7268370b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga2a4dfac299a63b8d1205d72d7268370b">OS_TASK_RESUME_FROM_ISR</a>(task)&#160;&#160;&#160;xTaskResumeFromISR(task)</td></tr>
<tr class="memdesc:ga2a4dfac299a63b8d1205d72d7268370b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume task.  <a href="#ga2a4dfac299a63b8d1205d72d7268370b">More...</a><br /></td></tr>
<tr class="separator:ga2a4dfac299a63b8d1205d72d7268370b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84368282a0e802f529f1423988725fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaa84368282a0e802f529f1423988725fe">OS_TASK_SUSPEND</a>(task)&#160;&#160;&#160;vTaskSuspend(task)</td></tr>
<tr class="memdesc:gaa84368282a0e802f529f1423988725fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend task.  <a href="#gaa84368282a0e802f529f1423988725fe">More...</a><br /></td></tr>
<tr class="separator:gaa84368282a0e802f529f1423988725fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab31890b90e25b6460670ffd6357669f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gab31890b90e25b6460670ffd6357669f9">OS_TASK_SUSPEND_FROM_ISR</a>(task)&#160;&#160;&#160;vTaskSuspendFromISR(task)</td></tr>
<tr class="memdesc:gab31890b90e25b6460670ffd6357669f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend task.  <a href="#gab31890b90e25b6460670ffd6357669f9">More...</a><br /></td></tr>
<tr class="separator:gab31890b90e25b6460670ffd6357669f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112a446b2367e0a86ea65e17b7b001ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga112a446b2367e0a86ea65e17b7b001ea">OS_MUTEX_CREATE</a>(mutex)</td></tr>
<tr class="memdesc:ga112a446b2367e0a86ea65e17b7b001ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS mutex.  <a href="#ga112a446b2367e0a86ea65e17b7b001ea">More...</a><br /></td></tr>
<tr class="separator:ga112a446b2367e0a86ea65e17b7b001ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fbc523417b45470fffc0c5b009361b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga7fbc523417b45470fffc0c5b009361b7">OS_MUTEX_DELETE</a>(mutex)&#160;&#160;&#160;vSemaphoreDelete(mutex)</td></tr>
<tr class="memdesc:ga7fbc523417b45470fffc0c5b009361b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete OS mutex.  <a href="#ga7fbc523417b45470fffc0c5b009361b7">More...</a><br /></td></tr>
<tr class="separator:ga7fbc523417b45470fffc0c5b009361b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f4dfba771ddb5c78b2e9cad9516258"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga28f4dfba771ddb5c78b2e9cad9516258">OS_MUTEX_PUT</a>(mutex)&#160;&#160;&#160;xSemaphoreGiveRecursive(mutex)</td></tr>
<tr class="memdesc:ga28f4dfba771ddb5c78b2e9cad9516258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relase mutex.  <a href="#ga28f4dfba771ddb5c78b2e9cad9516258">More...</a><br /></td></tr>
<tr class="separator:ga28f4dfba771ddb5c78b2e9cad9516258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103665ce82345a6d67cf3b1b68fbcaaa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga103665ce82345a6d67cf3b1b68fbcaaa">OS_MUTEX_GET</a>(mutex,  timeout)&#160;&#160;&#160;xSemaphoreTakeRecursive((mutex), (timeout))</td></tr>
<tr class="memdesc:ga103665ce82345a6d67cf3b1b68fbcaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire mutex.  <a href="#ga103665ce82345a6d67cf3b1b68fbcaaa">More...</a><br /></td></tr>
<tr class="separator:ga103665ce82345a6d67cf3b1b68fbcaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09506ad35a4182108374f79d60c7b054"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga09506ad35a4182108374f79d60c7b054">OS_EVENT_CREATE</a>(event)&#160;&#160;&#160;do { (event) = xSemaphoreCreateBinary(); } while(0)</td></tr>
<tr class="memdesc:ga09506ad35a4182108374f79d60c7b054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS event.  <a href="#ga09506ad35a4182108374f79d60c7b054">More...</a><br /></td></tr>
<tr class="separator:ga09506ad35a4182108374f79d60c7b054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1c77555a99448ebe9cd25bd390f92d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gab1c77555a99448ebe9cd25bd390f92d3">OS_EVENT_DELETE</a>(event)&#160;&#160;&#160;vSemaphoreDelete(event)</td></tr>
<tr class="memdesc:gab1c77555a99448ebe9cd25bd390f92d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete OS event.  <a href="#gab1c77555a99448ebe9cd25bd390f92d3">More...</a><br /></td></tr>
<tr class="separator:gab1c77555a99448ebe9cd25bd390f92d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060073d02b4e7fb6b0a5ec588b6b98d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga060073d02b4e7fb6b0a5ec588b6b98d1">OS_EVENT_SIGNAL</a>(event)&#160;&#160;&#160;xSemaphoreGive(event)</td></tr>
<tr class="memdesc:ga060073d02b4e7fb6b0a5ec588b6b98d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set event in signaled state.  <a href="#ga060073d02b4e7fb6b0a5ec588b6b98d1">More...</a><br /></td></tr>
<tr class="separator:ga060073d02b4e7fb6b0a5ec588b6b98d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8de4397bbf225a92c1105a5dadb3ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga1d8de4397bbf225a92c1105a5dadb3ba">OS_EVENT_SIGNAL_FROM_ISR</a>(event)</td></tr>
<tr class="memdesc:ga1d8de4397bbf225a92c1105a5dadb3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set event in signaled state.  <a href="#ga1d8de4397bbf225a92c1105a5dadb3ba">More...</a><br /></td></tr>
<tr class="separator:ga1d8de4397bbf225a92c1105a5dadb3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb1d31b30a33ccfbfed4cebabf6990a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga7fb1d31b30a33ccfbfed4cebabf6990a">OS_EVENT_WAIT</a>(event,  timeout)&#160;&#160;&#160;xSemaphoreTake((event), (timeout))</td></tr>
<tr class="memdesc:ga7fb1d31b30a33ccfbfed4cebabf6990a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for event.  <a href="#ga7fb1d31b30a33ccfbfed4cebabf6990a">More...</a><br /></td></tr>
<tr class="separator:ga7fb1d31b30a33ccfbfed4cebabf6990a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c99697a636be93943260708124dd0e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga3c99697a636be93943260708124dd0e7">OS_EVENT_CHECK</a>(event)&#160;&#160;&#160;xSemaphoreTake((event), OS_EVENT_NO_WAIT)</td></tr>
<tr class="memdesc:ga3c99697a636be93943260708124dd0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if event is signaled without waiting.  <a href="#ga3c99697a636be93943260708124dd0e7">More...</a><br /></td></tr>
<tr class="separator:ga3c99697a636be93943260708124dd0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e58ad0b5bae1e7bb80c7114716f3d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga88e58ad0b5bae1e7bb80c7114716f3d9">OS_EVENT_GROUP_CREATE</a>()&#160;&#160;&#160;xEventGroupCreate()</td></tr>
<tr class="memdesc:ga88e58ad0b5bae1e7bb80c7114716f3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS event group.  <a href="#ga88e58ad0b5bae1e7bb80c7114716f3d9">More...</a><br /></td></tr>
<tr class="separator:ga88e58ad0b5bae1e7bb80c7114716f3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bda5fac5b0e69c42c1c8385cd0108a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga3bda5fac5b0e69c42c1c8385cd0108a9">OS_EVENT_GROUP_WAIT_BITS</a>(event_group,  bits_to_wait,  clear_on_exit,  wait_for_all,  timeout)</td></tr>
<tr class="memdesc:ga3bda5fac5b0e69c42c1c8385cd0108a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event group wait bits.  <a href="#ga3bda5fac5b0e69c42c1c8385cd0108a9">More...</a><br /></td></tr>
<tr class="separator:ga3bda5fac5b0e69c42c1c8385cd0108a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3327457eefae5c693ae54145f1adeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaba3327457eefae5c693ae54145f1adeb">OS_EVENT_GROUP_SET_BITS</a>(event_group,  bits_to_set)</td></tr>
<tr class="memdesc:gaba3327457eefae5c693ae54145f1adeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event group set bits.  <a href="#gaba3327457eefae5c693ae54145f1adeb">More...</a><br /></td></tr>
<tr class="separator:gaba3327457eefae5c693ae54145f1adeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8714ef11e52d2057eb1629447209071e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga8714ef11e52d2057eb1629447209071e">OS_EVENT_GROUP_SET_BITS_FROM_ISR</a>(event_group,  bits_to_set)</td></tr>
<tr class="memdesc:ga8714ef11e52d2057eb1629447209071e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set event group bits from ISR.  <a href="#ga8714ef11e52d2057eb1629447209071e">More...</a><br /></td></tr>
<tr class="separator:ga8714ef11e52d2057eb1629447209071e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e637dbf5ba23f88d74ea93dafdbe42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga46e637dbf5ba23f88d74ea93dafdbe42">OS_EVENT_GROUP_CLEAR_BITS</a>(event_group,  bits_to_clear)</td></tr>
<tr class="memdesc:ga46e637dbf5ba23f88d74ea93dafdbe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear event group bits.  <a href="#ga46e637dbf5ba23f88d74ea93dafdbe42">More...</a><br /></td></tr>
<tr class="separator:ga46e637dbf5ba23f88d74ea93dafdbe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28c2d7842c556a29e3ce9fb68c20e36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gae28c2d7842c556a29e3ce9fb68c20e36">OS_EVENT_GROUP_CLEAR_BITS_FROM_ISR</a>(event_group,  bits_to_clear)&#160;&#160;&#160;xEventGroupClearBitsFromISR((event_group), (bits_to_clear))</td></tr>
<tr class="memdesc:gae28c2d7842c556a29e3ce9fb68c20e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear event group bits from an interrupt.  <a href="#gae28c2d7842c556a29e3ce9fb68c20e36">More...</a><br /></td></tr>
<tr class="separator:gae28c2d7842c556a29e3ce9fb68c20e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc34f47f4c851ffcba18917feafa2422"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gabc34f47f4c851ffcba18917feafa2422">OS_EVENT_GROUP_GET_BITS</a>(event_group)&#160;&#160;&#160;xEventGroupGetBits(event_group)</td></tr>
<tr class="memdesc:gabc34f47f4c851ffcba18917feafa2422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get event group bits.  <a href="#gabc34f47f4c851ffcba18917feafa2422">More...</a><br /></td></tr>
<tr class="separator:gabc34f47f4c851ffcba18917feafa2422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac289748c5e1f388342c1ae54012b806"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaac289748c5e1f388342c1ae54012b806">OS_EVENT_GROUP_GET_BITS_FROM_ISR</a>(event_group)&#160;&#160;&#160;xEventGroupGetBitsFromISR(event_group)</td></tr>
<tr class="memdesc:gaac289748c5e1f388342c1ae54012b806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get event group bits from an interrupt.  <a href="#gaac289748c5e1f388342c1ae54012b806">More...</a><br /></td></tr>
<tr class="separator:gaac289748c5e1f388342c1ae54012b806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94f4416bf0ac7e69f7b1cef77822dfa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaa94f4416bf0ac7e69f7b1cef77822dfa">OS_EVENT_GROUP_SYNC</a>(event_group,  bits_to_set,  bits_to_wait,  timeout)</td></tr>
<tr class="memdesc:gaa94f4416bf0ac7e69f7b1cef77822dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize event group bits.  <a href="#gaa94f4416bf0ac7e69f7b1cef77822dfa">More...</a><br /></td></tr>
<tr class="separator:gaa94f4416bf0ac7e69f7b1cef77822dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ad6b96a7fb19908798426b67779291"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gae3ad6b96a7fb19908798426b67779291">OS_EVENT_GROUP_DELETE</a>(event_group)&#160;&#160;&#160;xEventGroupDelete(event_group)</td></tr>
<tr class="memdesc:gae3ad6b96a7fb19908798426b67779291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete event group.  <a href="#gae3ad6b96a7fb19908798426b67779291">More...</a><br /></td></tr>
<tr class="separator:gae3ad6b96a7fb19908798426b67779291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc8b7bdb6581ede712d825f092ad00ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gabc8b7bdb6581ede712d825f092ad00ea">OS_QUEUE_CREATE</a>(queue,  item_size,  max_items)&#160;&#160;&#160;do { (queue) = xQueueCreate((max_items), (item_size)); } while(0)</td></tr>
<tr class="memdesc:gabc8b7bdb6581ede712d825f092ad00ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OS queue.  <a href="#gabc8b7bdb6581ede712d825f092ad00ea">More...</a><br /></td></tr>
<tr class="separator:gabc8b7bdb6581ede712d825f092ad00ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4125555127d460161078ddd93b4925"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaab4125555127d460161078ddd93b4925">OS_QUEUE_DELETE</a>(queue)&#160;&#160;&#160;vQueueDelete(queue)</td></tr>
<tr class="memdesc:gaab4125555127d460161078ddd93b4925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes OS queue.  <a href="#gaab4125555127d460161078ddd93b4925">More...</a><br /></td></tr>
<tr class="separator:gaab4125555127d460161078ddd93b4925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28eb0095f405f4a77b70afcb798b6fcd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga28eb0095f405f4a77b70afcb798b6fcd">OS_QUEUE_PUT</a>(queue,  item,  timeout)&#160;&#160;&#160;xQueueSend((queue), (item), (timeout))</td></tr>
<tr class="memdesc:ga28eb0095f405f4a77b70afcb798b6fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put element in queue.  <a href="#ga28eb0095f405f4a77b70afcb798b6fcd">More...</a><br /></td></tr>
<tr class="separator:ga28eb0095f405f4a77b70afcb798b6fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee5f52a66b92c1ee3500a92afb3ea2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gadee5f52a66b92c1ee3500a92afb3ea2b">OS_QUEUE_PUT_FROM_ISR</a>(queue,  item)</td></tr>
<tr class="memdesc:gadee5f52a66b92c1ee3500a92afb3ea2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put element in queue.  <a href="#gadee5f52a66b92c1ee3500a92afb3ea2b">More...</a><br /></td></tr>
<tr class="separator:gadee5f52a66b92c1ee3500a92afb3ea2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga734ae4efa9b0f0648e46d68b39ae9639"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga734ae4efa9b0f0648e46d68b39ae9639">OS_QUEUE_GET</a>(queue,  item,  timeout)&#160;&#160;&#160;xQueueReceive((queue), (item), (timeout))</td></tr>
<tr class="memdesc:ga734ae4efa9b0f0648e46d68b39ae9639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element from queue.  <a href="#ga734ae4efa9b0f0648e46d68b39ae9639">More...</a><br /></td></tr>
<tr class="separator:ga734ae4efa9b0f0648e46d68b39ae9639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1631dad9eb268f390e158cff9036ea3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gab1631dad9eb268f390e158cff9036ea3">OS_QUEUE_PEEK</a>(queue,  item,  timeout)&#160;&#160;&#160;xQueuePeek((queue), (item), (timeout))</td></tr>
<tr class="memdesc:gab1631dad9eb268f390e158cff9036ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek element on queue.  <a href="#gab1631dad9eb268f390e158cff9036ea3">More...</a><br /></td></tr>
<tr class="separator:gab1631dad9eb268f390e158cff9036ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafe3e9f66d7afc396337a95b55eea8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gacafe3e9f66d7afc396337a95b55eea8b">OS_QUEUE_MESSAGES_WAITING</a>(queue)&#160;&#160;&#160;uxQueueMessagesWaiting((queue))</td></tr>
<tr class="memdesc:gacafe3e9f66d7afc396337a95b55eea8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of messages stored in the queue.  <a href="#gacafe3e9f66d7afc396337a95b55eea8b">More...</a><br /></td></tr>
<tr class="separator:gacafe3e9f66d7afc396337a95b55eea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ddcaa3765d3322f6c1a5e48c102c61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gab3ddcaa3765d3322f6c1a5e48c102c61">OS_TIMER_CREATE</a>(name,  period,  reload,  timer_id,  callback)</td></tr>
<tr class="memdesc:gab3ddcaa3765d3322f6c1a5e48c102c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create software timer.  <a href="#gab3ddcaa3765d3322f6c1a5e48c102c61">More...</a><br /></td></tr>
<tr class="separator:gab3ddcaa3765d3322f6c1a5e48c102c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829f2c08546706de27d74f3d94991e32"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga829f2c08546706de27d74f3d94991e32">OS_TIMER_GET_TIMER_ID</a>(timer)&#160;&#160;&#160;pvTimerGetTimerID(timer)</td></tr>
<tr class="memdesc:ga829f2c08546706de27d74f3d94991e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timer ID.  <a href="#ga829f2c08546706de27d74f3d94991e32">More...</a><br /></td></tr>
<tr class="separator:ga829f2c08546706de27d74f3d94991e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1566ca04ff8d3c2656777803f54f4d4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga1566ca04ff8d3c2656777803f54f4d4f">OS_TIMER_IS_ACTIVE</a>(timer)&#160;&#160;&#160;xTimerIsTimerActive(timer)</td></tr>
<tr class="memdesc:ga1566ca04ff8d3c2656777803f54f4d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if timer is active.  <a href="#ga1566ca04ff8d3c2656777803f54f4d4f">More...</a><br /></td></tr>
<tr class="separator:ga1566ca04ff8d3c2656777803f54f4d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8867349519f1d3d49e90dc71946d2b24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga8867349519f1d3d49e90dc71946d2b24">OS_TIMER_START</a>(timer,  timeout)&#160;&#160;&#160;xTimerStart((timer), (timeout))</td></tr>
<tr class="memdesc:ga8867349519f1d3d49e90dc71946d2b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start timer.  <a href="#ga8867349519f1d3d49e90dc71946d2b24">More...</a><br /></td></tr>
<tr class="separator:ga8867349519f1d3d49e90dc71946d2b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa365dd8088897672c6831793ab257532"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaa365dd8088897672c6831793ab257532">OS_TIMER_STOP</a>(timer,  timeout)&#160;&#160;&#160;xTimerStop((timer), (timeout))</td></tr>
<tr class="memdesc:gaa365dd8088897672c6831793ab257532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop timer.  <a href="#gaa365dd8088897672c6831793ab257532">More...</a><br /></td></tr>
<tr class="separator:gaa365dd8088897672c6831793ab257532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05137e07905384715f65f14a93e0c23e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga05137e07905384715f65f14a93e0c23e">OS_TIMER_CHANGE_PERIOD</a>(timer,  period,  timeout)&#160;&#160;&#160;xTimerChangePeriod((timer), (period), (timeout))</td></tr>
<tr class="memdesc:ga05137e07905384715f65f14a93e0c23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change timer's period.  <a href="#ga05137e07905384715f65f14a93e0c23e">More...</a><br /></td></tr>
<tr class="separator:ga05137e07905384715f65f14a93e0c23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f2d4705593ca121a18eba61bb4523f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga51f2d4705593ca121a18eba61bb4523f">OS_TIMER_DELETE</a>(timer,  timeout)&#160;&#160;&#160;xTimerDelete((timer), (timeout))</td></tr>
<tr class="memdesc:ga51f2d4705593ca121a18eba61bb4523f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete timer.  <a href="#ga51f2d4705593ca121a18eba61bb4523f">More...</a><br /></td></tr>
<tr class="separator:ga51f2d4705593ca121a18eba61bb4523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf62357077a12d85bed42f15b88e8c772"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaf62357077a12d85bed42f15b88e8c772">OS_TIMER_RESET</a>(timer,  timeout)&#160;&#160;&#160;xTimerReset((timer), (timeout))</td></tr>
<tr class="memdesc:gaf62357077a12d85bed42f15b88e8c772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset timer.  <a href="#gaf62357077a12d85bed42f15b88e8c772">More...</a><br /></td></tr>
<tr class="separator:gaf62357077a12d85bed42f15b88e8c772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06fac74ca16c0a48fd92fecc0d414a1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga06fac74ca16c0a48fd92fecc0d414a1e">OS_TIMER_START_FROM_ISR</a>(timer)</td></tr>
<tr class="memdesc:ga06fac74ca16c0a48fd92fecc0d414a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start timer from ISR.  <a href="#ga06fac74ca16c0a48fd92fecc0d414a1e">More...</a><br /></td></tr>
<tr class="separator:ga06fac74ca16c0a48fd92fecc0d414a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5b4d5fff2947d1806559243e9fcdde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaca5b4d5fff2947d1806559243e9fcdde">OS_TIMER_STOP_FROM_ISR</a>(timer)</td></tr>
<tr class="memdesc:gaca5b4d5fff2947d1806559243e9fcdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop timer from ISR.  <a href="#gaca5b4d5fff2947d1806559243e9fcdde">More...</a><br /></td></tr>
<tr class="separator:gaca5b4d5fff2947d1806559243e9fcdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435ecbfcbe8996f34ac2e237512c1269"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga435ecbfcbe8996f34ac2e237512c1269">OS_TIMER_RESET_FROM_ISR</a>(timer)</td></tr>
<tr class="memdesc:ga435ecbfcbe8996f34ac2e237512c1269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset timer from ISR.  <a href="#ga435ecbfcbe8996f34ac2e237512c1269">More...</a><br /></td></tr>
<tr class="separator:ga435ecbfcbe8996f34ac2e237512c1269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435ecbfcbe8996f34ac2e237512c1269"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga435ecbfcbe8996f34ac2e237512c1269">OS_TIMER_RESET_FROM_ISR</a>(timer)</td></tr>
<tr class="memdesc:ga435ecbfcbe8996f34ac2e237512c1269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset timer from ISR.  <a href="#ga435ecbfcbe8996f34ac2e237512c1269">More...</a><br /></td></tr>
<tr class="separator:ga435ecbfcbe8996f34ac2e237512c1269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3c97a73258c9df80b82bbedaaf76b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gafc3c97a73258c9df80b82bbedaaf76b4">OS_TIMER_CHANGE_PERIOD_FROM_ISR</a>(timer,  period)</td></tr>
<tr class="memdesc:gafc3c97a73258c9df80b82bbedaaf76b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change timer period from ISR.  <a href="#gafc3c97a73258c9df80b82bbedaaf76b4">More...</a><br /></td></tr>
<tr class="separator:gafc3c97a73258c9df80b82bbedaaf76b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82e7c2d285c949df0dbb6fa0b389b4a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga82e7c2d285c949df0dbb6fa0b389b4a9">OS_DELAY</a>(ticks)&#160;&#160;&#160;vTaskDelay(ticks)</td></tr>
<tr class="memdesc:ga82e7c2d285c949df0dbb6fa0b389b4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay execution of task for specified time.  <a href="#ga82e7c2d285c949df0dbb6fa0b389b4a9">More...</a><br /></td></tr>
<tr class="separator:ga82e7c2d285c949df0dbb6fa0b389b4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d74be6b64086261aaa2c50db552c389"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga4d74be6b64086261aaa2c50db552c389">OS_GET_TICK_COUNT</a>()&#160;&#160;&#160;xTaskGetTickCount()</td></tr>
<tr class="memdesc:ga4d74be6b64086261aaa2c50db552c389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current tick count.  <a href="#ga4d74be6b64086261aaa2c50db552c389">More...</a><br /></td></tr>
<tr class="separator:ga4d74be6b64086261aaa2c50db552c389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4773c79590cb37558d7a116bf7bc90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga6d4773c79590cb37558d7a116bf7bc90">OS_TICKS_2_MS</a>(ticks)&#160;&#160;&#160;portCONVERT_TICKS_2_MS(ticks)</td></tr>
<tr class="memdesc:ga6d4773c79590cb37558d7a116bf7bc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from OS ticks to ms.  <a href="#ga6d4773c79590cb37558d7a116bf7bc90">More...</a><br /></td></tr>
<tr class="separator:ga6d4773c79590cb37558d7a116bf7bc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede42a5688918815691a6e6636ace839"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaede42a5688918815691a6e6636ace839">OS_MS_2_TICKS</a>(ms)&#160;&#160;&#160;portCONVERT_MS_2_TICKS(ms)</td></tr>
<tr class="memdesc:gaede42a5688918815691a6e6636ace839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from ms to OS ticks.  <a href="#gaede42a5688918815691a6e6636ace839">More...</a><br /></td></tr>
<tr class="separator:gaede42a5688918815691a6e6636ace839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ae742e5ba520e18dad2bc0d6b583f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga66ae742e5ba520e18dad2bc0d6b583f0">OS_DELAY_MS</a>(ms)&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#ga82e7c2d285c949df0dbb6fa0b389b4a9">OS_DELAY</a>(<a class="el" href="group___o_s_a_l.html#gaede42a5688918815691a6e6636ace839">OS_MS_2_TICKS</a>(ms))</td></tr>
<tr class="memdesc:ga66ae742e5ba520e18dad2bc0d6b583f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay execution of task for specified time.  <a href="#ga66ae742e5ba520e18dad2bc0d6b583f0">More...</a><br /></td></tr>
<tr class="separator:ga66ae742e5ba520e18dad2bc0d6b583f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597975f3d5d3682d317e275b1881a240"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga597975f3d5d3682d317e275b1881a240">OS_ENTER_CRITICAL_SECTION</a>()&#160;&#160;&#160;portENTER_CRITICAL()</td></tr>
<tr class="memdesc:ga597975f3d5d3682d317e275b1881a240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter critical section.  <a href="#ga597975f3d5d3682d317e275b1881a240">More...</a><br /></td></tr>
<tr class="separator:ga597975f3d5d3682d317e275b1881a240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efbc6587b1537847833b16eb891b75d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga2efbc6587b1537847833b16eb891b75d">OS_LEAVE_CRITICAL_SECTION</a>()&#160;&#160;&#160;portEXIT_CRITICAL()</td></tr>
<tr class="memdesc:ga2efbc6587b1537847833b16eb891b75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave critical section.  <a href="#ga2efbc6587b1537847833b16eb891b75d">More...</a><br /></td></tr>
<tr class="separator:ga2efbc6587b1537847833b16eb891b75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae013d6d0b27ad84dc89024c5dd827b0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gae013d6d0b27ad84dc89024c5dd827b0b">OS_MALLOC_FUNC</a>&#160;&#160;&#160;pvPortMalloc</td></tr>
<tr class="memdesc:gae013d6d0b27ad84dc89024c5dd827b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for OS memory allocation function.  <a href="#gae013d6d0b27ad84dc89024c5dd827b0b">More...</a><br /></td></tr>
<tr class="separator:gae013d6d0b27ad84dc89024c5dd827b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21743caf8af2c722bdd8a670192f8881"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga21743caf8af2c722bdd8a670192f8881">OS_MALLOC_NORET_FUNC</a>&#160;&#160;&#160;pvPortMalloc</td></tr>
<tr class="memdesc:ga21743caf8af2c722bdd8a670192f8881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for non-retain memory allocation function.  <a href="#ga21743caf8af2c722bdd8a670192f8881">More...</a><br /></td></tr>
<tr class="separator:ga21743caf8af2c722bdd8a670192f8881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1765b1b6fb9f9e7f550dfb671637f0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c">OS_MALLOC</a>(size)&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#gae013d6d0b27ad84dc89024c5dd827b0b">OS_MALLOC_FUNC</a>(size)</td></tr>
<tr class="memdesc:gac1765b1b6fb9f9e7f550dfb671637f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from OS provided heap.  <a href="#gac1765b1b6fb9f9e7f550dfb671637f0c">More...</a><br /></td></tr>
<tr class="separator:gac1765b1b6fb9f9e7f550dfb671637f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa518cdd7ba27ea28b30ed4e2e2d59a5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d">OS_MALLOC_NORET</a>(size)&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#ga21743caf8af2c722bdd8a670192f8881">OS_MALLOC_NORET_FUNC</a>(size)</td></tr>
<tr class="memdesc:gaa518cdd7ba27ea28b30ed4e2e2d59a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from non-retain heap.  <a href="#gaa518cdd7ba27ea28b30ed4e2e2d59a5d">More...</a><br /></td></tr>
<tr class="separator:gaa518cdd7ba27ea28b30ed4e2e2d59a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3512d548e2a84afa6fe2a8be6937074"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gae3512d548e2a84afa6fe2a8be6937074">OS_FREE_FUNC</a>&#160;&#160;&#160;vPortFree</td></tr>
<tr class="memdesc:gae3512d548e2a84afa6fe2a8be6937074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for OS free memory function.  <a href="#gae3512d548e2a84afa6fe2a8be6937074">More...</a><br /></td></tr>
<tr class="separator:gae3512d548e2a84afa6fe2a8be6937074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3115e8af8ac7eec38217271311ed9d34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga3115e8af8ac7eec38217271311ed9d34">OS_FREE_NORET_FUNC</a>&#160;&#160;&#160;vPortFree</td></tr>
<tr class="memdesc:ga3115e8af8ac7eec38217271311ed9d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name for non-retain memory free function.  <a href="#ga3115e8af8ac7eec38217271311ed9d34">More...</a><br /></td></tr>
<tr class="separator:ga3115e8af8ac7eec38217271311ed9d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd363022ea0bfcadacf515b2e34985d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gabbd363022ea0bfcadacf515b2e34985d">OS_FREE</a>(addr)&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#gae3512d548e2a84afa6fe2a8be6937074">OS_FREE_FUNC</a>(addr)</td></tr>
<tr class="memdesc:gabbd363022ea0bfcadacf515b2e34985d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated by <a class="el" href="group___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap. ">OS_MALLOC()</a>  <a href="#gabbd363022ea0bfcadacf515b2e34985d">More...</a><br /></td></tr>
<tr class="separator:gabbd363022ea0bfcadacf515b2e34985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bfdb04b48a504f559e42125fc43186d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga3bfdb04b48a504f559e42125fc43186d">OS_FREE_NORET</a>(addr)&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#ga3115e8af8ac7eec38217271311ed9d34">OS_FREE_NORET_FUNC</a>(addr)</td></tr>
<tr class="memdesc:ga3bfdb04b48a504f559e42125fc43186d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated by <a class="el" href="group___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d" title="Allocate memory from non-retain heap. ">OS_MALLOC_NORET()</a>  <a href="#ga3bfdb04b48a504f559e42125fc43186d">More...</a><br /></td></tr>
<tr class="separator:ga3bfdb04b48a504f559e42125fc43186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f98d7d32b4d4028cdad10a4fef22e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gab4f98d7d32b4d4028cdad10a4fef22e0">OS_POISON_AREA_CHECK</a>(control,  errmem)</td></tr>
<tr class="memdesc:gab4f98d7d32b4d4028cdad10a4fef22e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assertions to check if the stack or heap is compromised.  <a href="#gab4f98d7d32b4d4028cdad10a4fef22e0">More...</a><br /></td></tr>
<tr class="separator:gab4f98d7d32b4d4028cdad10a4fef22e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f148a5cf9ea2d24b9397ad5e21fe80d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga9f148a5cf9ea2d24b9397ad5e21fe80d">OS_GET_HEAP_WATERMARK</a>()&#160;&#160;&#160;xPortGetMinimumEverFreeHeapSize()</td></tr>
<tr class="memdesc:ga9f148a5cf9ea2d24b9397ad5e21fe80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get heap min water mark size.  <a href="#ga9f148a5cf9ea2d24b9397ad5e21fe80d">More...</a><br /></td></tr>
<tr class="separator:ga9f148a5cf9ea2d24b9397ad5e21fe80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c1232634084cd90cffd32cfbe29d9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga47c1232634084cd90cffd32cfbe29d9c">OS_GET_FREE_HEAP_SIZE</a>()&#160;&#160;&#160;xPortGetFreeHeapSize()</td></tr>
<tr class="memdesc:ga47c1232634084cd90cffd32cfbe29d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current free heap size.  <a href="#ga47c1232634084cd90cffd32cfbe29d9c">More...</a><br /></td></tr>
<tr class="separator:ga47c1232634084cd90cffd32cfbe29d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f60f4f66eeaf11537490392f33016e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga48f60f4f66eeaf11537490392f33016e">OS_GET_TASKS_NUMBER</a>()&#160;&#160;&#160;uxTaskGetNumberOfTasks()</td></tr>
<tr class="memdesc:ga48f60f4f66eeaf11537490392f33016e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current number OS tasks.  <a href="#ga48f60f4f66eeaf11537490392f33016e">More...</a><br /></td></tr>
<tr class="separator:ga48f60f4f66eeaf11537490392f33016e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f3930730a3bec33ab282c72a7796dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa3f3930730a3bec33ab282c72a7796dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gaa3f3930730a3bec33ab282c72a7796dd">OS_PTR_TO_UINT</a>(p)&#160;&#160;&#160;((unsigned) (void *) (p))</td></tr>
<tr class="memdesc:gaa3f3930730a3bec33ab282c72a7796dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any pointer to unsigned int value. <br /></td></tr>
<tr class="separator:gaa3f3930730a3bec33ab282c72a7796dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3356801fef2a1e61c65631a60f5497d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3356801fef2a1e61c65631a60f5497d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gad3356801fef2a1e61c65631a60f5497d">OS_PTR_TO_INT</a>(p)&#160;&#160;&#160;((int) (void *) (p))</td></tr>
<tr class="memdesc:gad3356801fef2a1e61c65631a60f5497d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any pointer to signed int value. <br /></td></tr>
<tr class="separator:gad3356801fef2a1e61c65631a60f5497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64494b18cfa2d9d95df93e16372107e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae64494b18cfa2d9d95df93e16372107e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gae64494b18cfa2d9d95df93e16372107e">OS_UINT_TO_PTR</a>(u)&#160;&#160;&#160;((void *) (unsigned) (u))</td></tr>
<tr class="memdesc:gae64494b18cfa2d9d95df93e16372107e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any unsigned int value to pointer. <br /></td></tr>
<tr class="separator:gae64494b18cfa2d9d95df93e16372107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga117b1997eb33b5a7e1538c1e0d516338"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga117b1997eb33b5a7e1538c1e0d516338"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga117b1997eb33b5a7e1538c1e0d516338">OS_INT_TO_PTR</a>(i)&#160;&#160;&#160;((void *) (int) (i))</td></tr>
<tr class="memdesc:ga117b1997eb33b5a7e1538c1e0d516338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any signed int value to pointer. <br /></td></tr>
<tr class="separator:ga117b1997eb33b5a7e1538c1e0d516338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga82c3bbd9de03b5b7e6fe31ee17189b28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82c3bbd9de03b5b7e6fe31ee17189b28"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga82c3bbd9de03b5b7e6fe31ee17189b28">OS_MEM_ERR_TYPE_ENUM</a> </td></tr>
<tr class="memdesc:ga82c3bbd9de03b5b7e6fe31ee17189b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS Memory Overrun Type. <br /></td></tr>
<tr class="separator:ga82c3bbd9de03b5b7e6fe31ee17189b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91db83d76f11008246e38e80bfeb24cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#ga91db83d76f11008246e38e80bfeb24cd">OS_NOTIFY_ACTION</a> { <br />
&#160;&#160;<a class="el" href="group___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cdacf8af7394792ac07a6fb45b6966322ed">OS_NOTIFY_NO_ACTION</a> = eNoAction, 
<a class="el" href="group___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cda707e11498965fb2a27d28003922eb33a">OS_NOTIFY_SET_BITS</a> = eSetBits, 
<a class="el" href="group___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cdadcdfb5913c4529e5673b6c2ae65ab1f3">OS_NOTIFY_INCREMENT</a> = eIncrement, 
<a class="el" href="group___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cda63b4d57115eb7e18e77dda410c8c8d16">OS_NOTIFY_VAL_WITH_OVERWRITE</a> = eSetValueWithOverwrite, 
<br />
&#160;&#160;<a class="el" href="group___o_s_a_l.html#gga91db83d76f11008246e38e80bfeb24cda4236b135cee8aa0ea383216a2a6600f3">OS_NOTIFY_VAL_WITHOUT_OVERWRITE</a> = eSetValueWithoutOverwrite
<br />
 }</td></tr>
<tr class="memdesc:ga91db83d76f11008246e38e80bfeb24cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS Notification action.  <a href="group___o_s_a_l.html#ga91db83d76f11008246e38e80bfeb24cd">More...</a><br /></td></tr>
<tr class="separator:ga91db83d76f11008246e38e80bfeb24cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe06d898bcd0410afc12cd1164cdb658"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_s_a_l.html#gabe06d898bcd0410afc12cd1164cdb658">OS_TASK_STATE</a> { <br />
&#160;&#160;<a class="el" href="group___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658ae6721aefc70c2f731dd95976c86e2d08">OS_TASK_RUNNING</a> = eRunning, 
<a class="el" href="group___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658a529cd0e1f131f501efe7cc3d1122d002">OS_TASK_READY</a> = eReady, 
<a class="el" href="group___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658a4705e6f6965e05b68e1fd805005f1fed">OS_TASK_BLOCKED</a> = eBlocked, 
<a class="el" href="group___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658a62ddebcd9f9807614278e7999168ec7e">OS_TASK_SUSPENDED</a> = eSuspended, 
<br />
&#160;&#160;<a class="el" href="group___o_s_a_l.html#ggabe06d898bcd0410afc12cd1164cdb658af3928fd43595cf4864252be0d5a0fd27">OS_TASK_DELETED</a> = eDeleted
<br />
 }</td></tr>
<tr class="memdesc:gabe06d898bcd0410afc12cd1164cdb658"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS Task state.  <a href="group___o_s_a_l.html#gabe06d898bcd0410afc12cd1164cdb658">More...</a><br /></td></tr>
<tr class="separator:gabe06d898bcd0410afc12cd1164cdb658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>OS Abstraction Layer. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga82e7c2d285c949df0dbb6fa0b389b4a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_DELAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ticks</td><td>)</td>
          <td>&#160;&#160;&#160;vTaskDelay(ticks)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay execution of task for specified time. </p>
<p>This function delays in OS specific way execution of current task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ticks</td><td>number of ticks to wait </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga66ae742e5ba520e18dad2bc0d6b583f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_DELAY_MS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ms</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#ga82e7c2d285c949df0dbb6fa0b389b4a9">OS_DELAY</a>(<a class="el" href="group___o_s_a_l.html#gaede42a5688918815691a6e6636ace839">OS_MS_2_TICKS</a>(ms))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay execution of task for specified time. </p>
<p>This function delays in OS specific way execution of current task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>number of ms to wait </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga597975f3d5d3682d317e275b1881a240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_ENTER_CRITICAL_SECTION</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;portENTER_CRITICAL()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter critical section. </p>
<p>This allows to enter critical section. Implementation will disable interrupts with nesting counter. This function can be called several time by task but requires same number of OS_LEAVE_CRITICAL_SECTION calls to allow task switching and interrupts again.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#ga2efbc6587b1537847833b16eb891b75d" title="Leave critical section. ">OS_LEAVE_CRITICAL_SECTION</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c99697a636be93943260708124dd0e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;xSemaphoreTake((event), OS_EVENT_NO_WAIT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if event is signaled without waiting. </p>
<p>This function will return immediately with OS_EVENT_SIGNALED if event was in signaled state already. In case the event is signaled, its state changes to not signaled after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>if of event to wait on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_EVENT_SIGNALED if event was signaled other value if not </dd></dl>

</div>
</div>
<a class="anchor" id="ga09506ad35a4182108374f79d60c7b054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;do { (event) = xSemaphoreCreateBinary(); } while(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OS event. </p>
<p>Function creates OS event that can be used to synchronize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">event</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1c77555a99448ebe9cd25bd390f92d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;vSemaphoreDelete(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete OS event. </p>
<p>Function destroys OS event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>item to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga46e637dbf5ba23f88d74ea93dafdbe42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_CLEAR_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_clear&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">xEventGroupClearBits((event_group), \</div>
<div class="line">                                                                                    (bits_to_clear))</div>
</div><!-- fragment -->
<p>Clear event group bits. </p>
<p>Function clear bits (flags) within an event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>the event group in which the bits are to be cleared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_clear</td><td>a bitwise value that indicates the bit or bits to clear in the event group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event group before the specified bits were cleared </dd></dl>

</div>
</div>
<a class="anchor" id="gae28c2d7842c556a29e3ce9fb68c20e36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_CLEAR_BITS_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_clear&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xEventGroupClearBitsFromISR((event_group), (bits_to_clear))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear event group bits from an interrupt. </p>
<p>Function clear bits (flags) within an event group from an interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>the event group in which the bits are to be cleared </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_clear</td><td>a bitwise value that indicates the bit or bits to clear in the event group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event group before the specified bits were cleared </dd></dl>

</div>
</div>
<a class="anchor" id="ga88e58ad0b5bae1e7bb80c7114716f3d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_CREATE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;xEventGroupCreate()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OS event group. </p>
<p>Function creates OS event group</p>
<dl class="section return"><dt>Returns</dt><dd>event group handle if successful, otherwise NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gae3ad6b96a7fb19908798426b67779291"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group</td><td>)</td>
          <td>&#160;&#160;&#160;xEventGroupDelete(event_group)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete event group. </p>
<p>Function deletes an event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>the event group being deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc34f47f4c851ffcba18917feafa2422"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_GET_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group</td><td>)</td>
          <td>&#160;&#160;&#160;xEventGroupGetBits(event_group)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get event group bits. </p>
<p>Function returns the current value of the event bits (event flags) in an event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>the event group being queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event bits in the event group at the time <a class="el" href="group___o_s_a_l.html#gabc34f47f4c851ffcba18917feafa2422" title="Get event group bits. ">OS_EVENT_GROUP_GET_BITS()</a> was called </dd></dl>

</div>
</div>
<a class="anchor" id="gaac289748c5e1f388342c1ae54012b806"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_GET_BITS_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group</td><td>)</td>
          <td>&#160;&#160;&#160;xEventGroupGetBitsFromISR(event_group)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get event group bits from an interrupt. </p>
<p>Function returns the current value of the event bits (event flags) in an event group from an interrupt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>the event group being queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event bits in the event group at the time <a class="el" href="group___o_s_a_l.html#gaac289748c5e1f388342c1ae54012b806" title="Get event group bits from an interrupt. ">OS_EVENT_GROUP_GET_BITS_FROM_ISR()</a> was called </dd></dl>

</div>
</div>
<a class="anchor" id="gaba3327457eefae5c693ae54145f1adeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_SET_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_set&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">xEventGroupSetBits((event_group), \</div>
<div class="line">                                                                                      (bits_to_set))</div>
</div><!-- fragment -->
<p>Event group set bits. </p>
<p>Set bits (flags) within an event group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>the event group in which the bits are to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_set</td><td>a bitwise value that indicates the bit or bits to set in the event group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the event group at the time the call to xEventGroupSetBits() returns </dd></dl>

</div>
</div>
<a class="anchor" id="ga8714ef11e52d2057eb1629447209071e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_SET_BITS_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_set&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">        BaseType_t need_switch, ret; \</div>
<div class="line">        ret = xEventGroupSetBitsFromISR((event_group), (bits_to_set), &amp;(need_switch)); \</div>
<div class="line">        portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">        ret; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Set event group bits from ISR. </p>
<p>Set bits (flags) within an RTOS event group that can be called from an ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>the event group in which the bits are to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_set</td><td>a bitwise value that indicates the bit or bits to set in the event group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the message was sent to the RTOS daemon task then OS_OK is returned, otherwise OS_FAIL is returned </dd></dl>

</div>
</div>
<a class="anchor" id="gaa94f4416bf0ac7e69f7b1cef77822dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_SYNC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_set, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_wait, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">xEventGroupSync((event_group), (bits_to_set), \</div>
<div class="line">                                                                          (bits_to_wait), (timeout))</div>
</div><!-- fragment -->
<p>Synchronize event group bits. </p>
<p>Atomically set bits (flags) within an event group, then wait for a combination of bits to be set within the same event group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>event group in which the bits are being set and tested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_set</td><td>bit or bits to set in the event group before determining if all the bits specified by the bits_to_wait parameter are set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_wait</td><td>a bitwise value that indicates the bit or bits to test inside the event group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum amount of time (specified in 'ticks') to wait for all the bits specified by the bits_to_wait parameter value to become set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the event group at the time either the bits being waited for became set, or the block time expired </dd></dl>

</div>
</div>
<a class="anchor" id="ga3bda5fac5b0e69c42c1c8385cd0108a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_GROUP_WAIT_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event_group, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bits_to_wait, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">clear_on_exit, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wait_for_all, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">xEventGroupWaitBits((event_group), (bits_to_wait), \</div>
<div class="line">                                                         (clear_on_exit), (wait_for_all), (timeout))</div>
</div><!-- fragment -->
<p>Event group wait bits. </p>
<p>Function reads bits within event group optionally entering the Blocked state (with a timeout) to wait for a bit or group of bits to become set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_group</td><td>the event group in which the bits are being tested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bits_to_wait</td><td>a bitwise value to test inside the event group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear_on_exit</td><td>= OS_OK: any bits set in the value passed as the bits_to_wait parameter will be cleared in the event group before xEventGroupWaitBits returns OS_FAIL: bits in the event group are not altered when the call to xEventGroupWaitBits() returns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_for_all</td><td>= OS_OK: xEventGroupWaitBits() will return when either <em>all</em> bits set in the value passed as the bits_to_wait parameter are set in the event group OS_FAIL: xEventGroupWaitBits() will return when <em>any</em> of the bits set in the value passed as the bits_to_wait parameter are set in the event group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>maximum amount of time to wait for one/all of the bits specified by bits_to_wait to become set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the event group at the time either the event bits being waited for became set, or the timeout expired </dd></dl>

</div>
</div>
<a class="anchor" id="ga060073d02b4e7fb6b0a5ec588b6b98d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_SIGNAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td>&#160;&#160;&#160;xSemaphoreGive(event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set event in signaled state. </p>
<p>Set event in signaled stated so OS_EVENT_WAIT will release waiting task if any. Event will remain in signaled stated till call to OS_EVENT_WAIT releases one task. This function should not be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1d8de4397bbf225a92c1105a5dadb3ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_SIGNAL_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">                BaseType_t need_switch, ret; \</div>
<div class="line">                ret = xSemaphoreGiveFromISR(event, &amp;need_switch); \</div>
<div class="line">                portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">                ret; \</div>
<div class="line">        })</div>
</div><!-- fragment -->
<p>Set event in signaled state. </p>
<p>Set event in signaled stated so OS_EVENT_WAIT will release waiting task if any. Event will remain in signaled stated till call to OS_EVENT_WAIT releases one task. This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7fb1d31b30a33ccfbfed4cebabf6990a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_EVENT_WAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">event, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xSemaphoreTake((event), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for event. </p>
<p>This function wait for <code>event</code> to be in signaled stated. If event was already in signaled state or become signaled in specified time function will return OS_EVENT_SIGNALED. To check if event is already signaled use OS_EVENT_NO_WAIT as timeout. To wait till event is signaled use OS_EVENT_FOREVERE. This function can't be used in ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>if of event to wait on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>number of ticks to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_EVENT_SIGNALED if event was signaled other value if not </dd></dl>

</div>
</div>
<a class="anchor" id="gabbd363022ea0bfcadacf515b2e34985d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#gae3512d548e2a84afa6fe2a8be6937074">OS_FREE_FUNC</a>(addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated by <a class="el" href="group___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap. ">OS_MALLOC()</a> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap. ">OS_MALLOC</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae3512d548e2a84afa6fe2a8be6937074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_FREE_FUNC&#160;&#160;&#160;vPortFree</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name for OS free memory function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gabbd363022ea0bfcadacf515b2e34985d" title="Free memory allocated by OS_MALLOC() ">OS_FREE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3bfdb04b48a504f559e42125fc43186d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_FREE_NORET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#ga3115e8af8ac7eec38217271311ed9d34">OS_FREE_NORET_FUNC</a>(addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated by <a class="el" href="group___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d" title="Allocate memory from non-retain heap. ">OS_MALLOC_NORET()</a> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d" title="Allocate memory from non-retain heap. ">OS_MALLOC_NORET</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3115e8af8ac7eec38217271311ed9d34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_FREE_NORET_FUNC&#160;&#160;&#160;vPortFree</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name for non-retain memory free function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#ga3bfdb04b48a504f559e42125fc43186d" title="Free memory allocated by OS_MALLOC_NORET() ">OS_FREE_NORET</a> </dd>
<dd>
<a class="el" href="group___o_s_a_l.html#gaa518cdd7ba27ea28b30ed4e2e2d59a5d" title="Allocate memory from non-retain heap. ">OS_MALLOC_NORET</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a1a837adbf0d7c4cd6f4c86c5012563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_CURRENT_TASK</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;xTaskGetCurrentTaskHandle()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current OS task handle. </p>
<dl class="section return"><dt>Returns</dt><dd>current task handle of type OS_TASK </dd></dl>

</div>
</div>
<a class="anchor" id="ga47c1232634084cd90cffd32cfbe29d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_FREE_HEAP_SIZE</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;xPortGetFreeHeapSize()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current free heap size. </p>
<p>Function gets heap current available size</p>
<dl class="section return"><dt>Returns</dt><dd>Current free heap size in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f148a5cf9ea2d24b9397ad5e21fe80d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_HEAP_WATERMARK</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;xPortGetMinimumEverFreeHeapSize()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get heap min water mark size. </p>
<p>Function gets heap min water mark size</p>
<dl class="section return"><dt>Returns</dt><dd>The heap min water mark size in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ga48f60f4f66eeaf11537490392f33016e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TASKS_NUMBER</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;uxTaskGetNumberOfTasks()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current number OS tasks. </p>
<p>Function gets current number OS tasks</p>
<dl class="section return"><dt>Returns</dt><dd>the current number of OS tasks </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d74be6b64086261aaa2c50db552c389"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_GET_TICK_COUNT</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;xTaskGetTickCount()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current tick count. </p>
<dl class="section return"><dt>Returns</dt><dd>current tick count </dd></dl>

</div>
</div>
<a class="anchor" id="ga2efbc6587b1537847833b16eb891b75d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_LEAVE_CRITICAL_SECTION</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;portEXIT_CRITICAL()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave critical section. </p>
<p>Function restores interrupts and task switching. Number of calls to this function must match number of calls to OS_ENTER_CRITICAL_SECTION.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#ga597975f3d5d3682d317e275b1881a240" title="Enter critical section. ">OS_ENTER_CRITICAL_SECTION</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac1765b1b6fb9f9e7f550dfb671637f0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#gae013d6d0b27ad84dc89024c5dd827b0b">OS_MALLOC_FUNC</a>(size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory from OS provided heap. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gabbd363022ea0bfcadacf515b2e34985d" title="Free memory allocated by OS_MALLOC() ">OS_FREE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae013d6d0b27ad84dc89024c5dd827b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MALLOC_FUNC&#160;&#160;&#160;pvPortMalloc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name for OS memory allocation function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gac1765b1b6fb9f9e7f550dfb671637f0c" title="Allocate memory from OS provided heap. ">OS_MALLOC</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa518cdd7ba27ea28b30ed4e2e2d59a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MALLOC_NORET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___o_s_a_l.html#ga21743caf8af2c722bdd8a670192f8881">OS_MALLOC_NORET_FUNC</a>(size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory from non-retain heap. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gabbd363022ea0bfcadacf515b2e34985d" title="Free memory allocated by OS_MALLOC() ">OS_FREE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga21743caf8af2c722bdd8a670192f8881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MALLOC_NORET_FUNC&#160;&#160;&#160;pvPortMalloc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name for non-retain memory allocation function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gae013d6d0b27ad84dc89024c5dd827b0b" title="Name for OS memory allocation function. ">OS_MALLOC_FUNC</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaede42a5688918815691a6e6636ace839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MS_2_TICKS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ms</td><td>)</td>
          <td>&#160;&#160;&#160;portCONVERT_MS_2_TICKS(ms)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from ms to OS ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>milliseconds to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value in OS ticks </dd></dl>

</div>
</div>
<a class="anchor" id="ga112a446b2367e0a86ea65e17b7b001ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">                (mutex) = xSemaphoreCreateRecursiveMutex(); \</div>
<div class="line">                mutex != NULL ? OS_MUTEX_CREATE_SUCCESS : OS_MUTEX_CREATE_FAILED; \</div>
<div class="line">        })</div>
</div><!-- fragment -->
<p>Create OS mutex. </p>
<p>Function creates OS mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mutex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_MUTEX_CREATE_SUCCESS when mutex was created successfully, OS_MUTEX_CREATE_FAILED otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fbc523417b45470fffc0c5b009361b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td>&#160;&#160;&#160;vSemaphoreDelete(mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete OS mutex. </p>
<p>Function deletes OS mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga103665ce82345a6d67cf3b1b68fbcaaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xSemaphoreTakeRecursive((mutex), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire mutex. </p>
<p>Access to shared resource can be guarded by mutex. When task wants to get access to this resource call OS_MUTEX_GET. If mutex was not taken by any task yet it, call will succeed and mutex will be assigned to calling task. Next call to already acquired mutex from same task will succeed. If mutex is already taken by other task calling task will wait for specified time before failing. For non-blocking acquire <code>timeout</code> can be OS_MUTEX_NO_WAIT, for infinite wait till mutex is released OS_MUTEX_FOREVER should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>id of mutex to acquire </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>number of ticks that to acquire mutex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga28f4dfba771ddb5c78b2e9cad9516258"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_MUTEX_PUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mutex</td><td>)</td>
          <td>&#160;&#160;&#160;xSemaphoreGiveRecursive(mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relase mutex. </p>
<p>Decrease mutex count, when numer of calls to OS_MUTEX_GET equals number of calls to OS_MUTEX_PUT, mutex can be acquired by other task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>id of mutex to realse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab4f98d7d32b4d4028cdad10a4fef22e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_POISON_AREA_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">control, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">errmem&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assertions to check if the stack or heap is compromised. </p>
<p>+=====================+=====&gt; __HeapBase</p><ul>
<li>+</li>
<li>HEAP +</li>
<li>+</li>
<li>+</li>
<li>+ +------------------&mdash;+</li>
<li>HEAP_POISON_AREA + +=====================+=====&gt; __HeapLimit</li>
<li>+</li>
<li>+</li>
<li>+ +=====================+=====&gt; __StackLimit</li>
<li>STACK_POISON_AREA + +------------------&mdash;+</li>
<li>+</li>
<li>STACK +</li>
<li>+ +=====================+====&gt; __StackTop</li>
</ul>
<p>The two following macros will check the integrity of the heap and the stack area via a respective assertion or a printed message on std output. An area close to the memory limit is firstly initialized using OS_POISON_AREA_INIT() (see file sdk/bsp/startup/system_ARMCM0.c). Then, provided that configUSE_TICK_HOOK is set to 1 in FreeRTOSConfig.h <a class="el" href="group___o_s_a_l.html#gab4f98d7d32b4d4028cdad10a4fef22e0" title="Assertions to check if the stack or heap is compromised. ">OS_POISON_AREA_CHECK()</a> will test on every tick whether the poison area is compromised or not. User code can be added in each project's main.c file, more specifically in the function vApplicationTickHook(), which is called on every TICK, this way the memory-checking result can be evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>how to proceed after the check</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmem</td><td>indicates if/which memory is messed up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This code snippet is called if dg_configCHECK_HEAP_STACK_OVERRUN is set By default dg_configCHECK_HEAP_STACK_OVERRUN is (0). To use this functionality it is advised to set it (1) in $PROJECT_ROOT/config/custom_config_*.h file. </dd></dl>

</div>
</div>
<a class="anchor" id="gabc8b7bdb6581ede712d825f092ad00ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_items&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;do { (queue) = xQueueCreate((max_items), (item_size)); } while(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OS queue. </p>
<p>Function creates OS queue that can contain <code>max_items</code> of specified size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue</td><td>queue to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_size</td><td>queue element size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_items</td><td>max number of items that queue can store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab4125555127d460161078ddd93b4925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue</td><td>)</td>
          <td>&#160;&#160;&#160;vQueueDelete(queue)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes OS queue. </p>
<p>Function deletes OS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>queue to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga734ae4efa9b0f0648e46d68b39ae9639"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xQueueReceive((queue), (item), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get element from queue. </p>
<p>Function adds element into queue if there is enough room for it. If there is nothing in queue for <code>timeout</code> ticks error is returned. Use OS_QUEUE_NO_WAIT for <code>timeout</code> to get message without waiting. Use OS_QUEUE_FOREVER to wait till message arrives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>id of queue to get item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>pointer to buffer that will receive element from queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait for element in queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_EMPTY if there was nothing in queue OS_QUEUE_OK if message was get from queue </dd></dl>

</div>
</div>
<a class="anchor" id="gacafe3e9f66d7afc396337a95b55eea8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_MESSAGES_WAITING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue</td><td>)</td>
          <td>&#160;&#160;&#160;uxQueueMessagesWaiting((queue))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of messages stored in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>id of the queue to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1631dad9eb268f390e158cff9036ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_PEEK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xQueuePeek((queue), (item), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek element on queue. </p>
<p>Function gets element from queue without removing it. If there is nothing in queue for <code>timeout</code> ticks error is returned. Use OS_QUEUE_NO_WAIT for <code>timeout</code> to get message without waiting. Use OS_QUEUE_FOREVER to wait till message arrives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>id of queue to peek item from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>pointer to buffer that will receive element from queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait for element in queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_EMPTY if there was nothing in queue OS_QUEUE_OK if message was get from queue </dd></dl>

</div>
</div>
<a class="anchor" id="ga28eb0095f405f4a77b70afcb798b6fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_PUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xQueueSend((queue), (item), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put element in queue. </p>
<p>Function adds element into queue if there is enough room for it. If there is no room in queue for <code>timeout</code> ticks element is not put in queue and error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>id of queue to put item to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>pointer to element to enqueue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait for space in queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_FULL if there was no place in queue OS_QUEUE_OK if message was put in queue </dd></dl>

</div>
</div>
<a class="anchor" id="gadee5f52a66b92c1ee3500a92afb3ea2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_QUEUE_PUT_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">item&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">                BaseType_t need_switch, ret; \</div>
<div class="line">                ret = xQueueSendToBackFromISR((queue), (item), &amp;need_switch); \</div>
<div class="line">                portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">                ret; \</div>
<div class="line">        })</div>
</div><!-- fragment -->
<p>Put element in queue. </p>
<p>Function adds element into queue if there is enough room for it. If there is no room in queue error is returned immediately.</p>
<p>This is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>id of queue to put item to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>pointer to element to enqueue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_QUEUE_FULL if there was no place in queue OS_QUEUE_OK if message was put in queue </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2a5564afaf810733986c2326a323be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task_func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">stack_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">priority, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">xTaskCreate((task_func), (name), \</div>
<div class="line">                                                (((stack_size) - 1) / <span class="keyword">sizeof</span>(StackType_t) + 1), \</div>
<div class="line">                                                                        (arg), (priority), &amp;(task))</div>
</div><!-- fragment -->
<p>Create OS task. </p>
<p>Function creates OS task. Task is added to ready list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>task name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_func</td><td>starting point of task </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>parameter past to <code>task_func</code> on task start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_size</td><td>stack size allocated for task in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>number specifying task priority </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>OS specific task handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_CREATE_SUCCESS if task was created successfully </dd></dl>

</div>
</div>
<a class="anchor" id="ga24a73ccb253999f6d79b6985c097fb4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;vTaskDelete(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete OS task. </p>
<p>Function deletes OS task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>OS specific task handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00f2215f0acf1afbe553051eda1972f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xTaskNotify((task), (value), (action))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send an event directly to task. </p>
<p>Must not be called from ISR!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>id of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5eac367a1d83149f77bf4cd28d6a93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_AND_QUERY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prev_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">xTaskNotifyAndQuery((task), \</div>
<div class="line">                                                                (value), (action), (prev_value))</div>
</div><!-- fragment -->
<p>Notify OS task sending an event and return previous notification value. </p>
<p>Must not be called from ISR!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>id of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prev_value</td><td>pointer to previous notification value - optional - can be set to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga41c0bb07f14dea53797a0a922d27dbdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">action&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">                BaseType_t need_switch, ret; \</div>
<div class="line">                ret = xTaskNotifyFromISR(task, value, action, &amp;need_switch); \</div>
<div class="line">                portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">                ret; \</div>
<div class="line">        })</div>
</div><!-- fragment -->
<p>Send an event and unblock OS task with updating notification value. </p>
<p>A version of OS_TASK_NOTIFY that can be called from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>id of task to notify </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>used to update the notification value of the subject <code>task</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>action that performs when notify is occurred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_FAIL if <code>action</code> is set as OS_NOTIFY_VAL_WITHOUT_OVERWRITE and <code>task</code> already had a notification pending, OS_TASK_NOTIFY_SUCCESS otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga922cdffae7bfcabc3e3a29e2521365b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_GIVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;xTaskNotifyGive(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify task and receive OS task notification value. </p>
<p>Must not called from ISR! Use OS_TASK_NOTIFY_GIVE_FROM_ISR instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>id of task to notify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_GIVE calls OS_TASK_NOTIFY with action set to OS_NOTIFY_INCREMENT resulting in all calls returning OS_TASK_NOTIFY_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="ga073a550e64dbb4b8b4acfd9c83370775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_GIVE_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">                BaseType_t need_switch; \</div>
<div class="line">                vTaskNotifyGiveFromISR(task, &amp;need_switch); \</div>
<div class="line">                portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">        })</div>
</div><!-- fragment -->
<p>Notify task from ISR. </p>
<p>Send notification from interrupt service routine (ISR) to <code>task</code> that can unblock the receiving task and optionally update the receiving task's notification value. This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>id of task to notify </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7a3bb58bc89af3bb73c75bb4fa8644e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_TAKE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">clear_on_exit, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">time_to_wait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">ulTaskNotifyTake((clear_on_exit), \</div>
<div class="line">                                                                                (time_to_wait))</div>
</div><!-- fragment -->
<p>Clear to zero or decrement task notification value on exit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clear_on_exit</td><td>= pdFASLE: RTOS task's notification value is decremented before <a class="el" href="group___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e" title="Clear to zero or decrement task notification value on exit. ">OS_TASK_NOTIFY_TAKE()</a> exits, pdTRUE: the RTOS task's notification value is reset to 0 before <a class="el" href="group___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e" title="Clear to zero or decrement task notification value on exit. ">OS_TASK_NOTIFY_TAKE()</a> exits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_to_wait</td><td>maximum time to wait in the blocked state for a notification to be received if a notification is not already pending when <a class="el" href="group___o_s_a_l.html#gaf7a3bb58bc89af3bb73c75bb4fa8644e" title="Clear to zero or decrement task notification value on exit. ">OS_TASK_NOTIFY_TAKE()</a> is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the task's notification value before it is decremented or cleared </dd></dl>

</div>
</div>
<a class="anchor" id="gafbdd8702f6b22611d3cc340602a427d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_NOTIFY_WAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">entry_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exit_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ticks_to_wait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">xTaskNotifyWait((entry_bits), (exit_bits), (value), \</div>
<div class="line">                                                                                (ticks_to_wait))</div>
</div><!-- fragment -->
<p>Wait for the calling task to receive a notification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_bits</td><td>any bits set in entry_bits will be cleared in calling notification value before enters to OS_TASK_NOTIFY_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exit_bits</td><td>any bits set in exit_bits will be cleared in calling notification value before OS_TASK_NOTIFY_WAIT function exits if a notification was received </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>pointer to task's notification value, if not required can be set to NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ticks_to_wait</td><td>maximum time to wait in the blocked state for a notification to be received if a notification is not already pending when OS_TASK_NOTIFY_WAIT is called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TASK_NOTIFY_SUCCESS if notification was received or was already pending when OS_TASK_NOTIFY_WAIT was called OS_TASK_NOTIFY_FAIL if the call OS_TASK_NOTIFY_WAIT timed out before notification was received </dd></dl>

</div>
</div>
<a class="anchor" id="gabd8dafae5ca6f00ee8ce776ae1212fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_PRIORITY_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;uxTaskPriorityGet(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority of an OS task. </p>
<p>Function returns the priority of an OS task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>OS specific task handle. if NULL, the running task is assummed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the priority of the task (OS_UBASE_TYPE) </dd></dl>

</div>
</div>
<a class="anchor" id="ga02bb1b8afdd47bf1031e94aceaf19865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_PRIORITY_SET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prio&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;vTaskPrioritySet(task, prio)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of an OS task. </p>
<p>Function sets the priority of an OS task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>OS specific task handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>OS new priority </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac00c9c3498aa76bf2a427f415a2ef5fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_RESUME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;vTaskResume(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume task. </p>
<p>Make <code>task</code> ready to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>id of task to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2a4dfac299a63b8d1205d72d7268370b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_RESUME_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;xTaskResumeFromISR(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume task. </p>
<p>Make <code>task</code> ready to run. This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>id of task to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa84368282a0e802f529f1423988725fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_SUSPEND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;vTaskSuspend(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend task. </p>
<p>Remove <code>task</code> from execution queue. Task will not be run until OS_TASK_RESUME or OS_TASK_RESUME_FROM_ISR is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>id of task to suspend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab31890b90e25b6460670ffd6357669f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_SUSPEND_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">task</td><td>)</td>
          <td>&#160;&#160;&#160;vTaskSuspendFromISR(task)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend task. </p>
<p>Remove <code>task</code> from execution queue. Task will not be run until OS_TASK_RESUME or OS_TASK_RESUME_FROM_ISR is called. This function is safe to call from ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>id of task to suspend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9b95512f360b2980c30404776efc2a21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TASK_YIELD</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;portYIELD()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The running OS task yields control to the scheduler. </p>
<p>Function requests a context switch to another task. </p>

</div>
</div>
<a class="anchor" id="ga6d4773c79590cb37558d7a116bf7bc90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TICKS_2_MS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ticks</td><td>)</td>
          <td>&#160;&#160;&#160;portCONVERT_TICKS_2_MS(ticks)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from OS ticks to ms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ticks</td><td>tick count to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value in ms </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a68360ed332a7a45f9a44af68f56ac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIME_TO_TICKS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">time_in_ms</td><td>)</td>
          <td>&#160;&#160;&#160;pdMS_TO_TICKS(time_in_ms)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a time in milliseconds to a time in ticks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_in_ms</td><td>time in milliseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time in ticks </dd></dl>

</div>
</div>
<a class="anchor" id="ga05137e07905384715f65f14a93e0c23e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_CHANGE_PERIOD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">period, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xTimerChangePeriod((timer), (period), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change timer's period. </p>
<p>Functions updates timer's period</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>new timer's period </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, or OS_TIMER_FAIL if timeout occur </dd></dl>

</div>
</div>
<a class="anchor" id="gafc3c97a73258c9df80b82bbedaaf76b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_CHANGE_PERIOD_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">period&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">        BaseType_t need_switch, ret; \</div>
<div class="line">        ret = xTimerChangePeriodFromISR((timer), (period), &amp;(need_switch)); \</div>
<div class="line">        portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">        ret; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Change timer period from ISR. </p>
<p>Version of OS_TIMER_CHANGE_PERIOD that can be called from an interrupt service routine</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>new timer period</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, otherwise OS_TIMER_FAIL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#ga05137e07905384715f65f14a93e0c23e" title="Change timer&#39;s period. ">OS_TIMER_CHANGE_PERIOD</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab3ddcaa3765d3322f6c1a5e48c102c61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_CREATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">period, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reload, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">callback&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">xTimerCreate((name), (period), ((reload) ? pdTRUE : pdFALSE), \</div>
<div class="line">                                                        ((<span class="keywordtype">void</span> *) (timer_id)), (callback))</div>
</div><!-- fragment -->
<p>Create software timer. </p>
<p>Function creates software timer with given timeout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>timer name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>timer period in ticks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reload</td><td>indicates if callback will be called once or multiple times </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timer_id</td><td>identifier which can be used to identify timer in callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>callback called when timer expires</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER if timer created successfully, otherwise null </dd></dl>

</div>
</div>
<a class="anchor" id="ga51f2d4705593ca121a18eba61bb4523f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_DELETE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xTimerDelete((timer), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete timer. </p>
<p>Function deletes previously created timer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, or OS_TIMER_FAIL if timeout occur </dd></dl>

</div>
</div>
<a class="anchor" id="ga829f2c08546706de27d74f3d94991e32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_GET_TIMER_ID</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td>&#160;&#160;&#160;pvTimerGetTimerID(timer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timer ID. </p>
<p>Function returns timer_id assigned in OS_TIMER_CREATE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timer id </dd></dl>

</div>
</div>
<a class="anchor" id="ga1566ca04ff8d3c2656777803f54f4d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_IS_ACTIVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td>&#160;&#160;&#160;xTimerIsTimerActive(timer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if timer is active. </p>
<p>Function checks timer status</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if timer is active, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="gaf62357077a12d85bed42f15b88e8c772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_RESET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xTimerReset((timer), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset timer. </p>
<p>Function restarts previously created timer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, or OS_TIMER_FAIL if timeout occur </dd></dl>

</div>
</div>
<a class="anchor" id="ga435ecbfcbe8996f34ac2e237512c1269"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_RESET_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">        BaseType_t need_switch, ret; \</div>
<div class="line">        ret = xTimerResetFromISR((timer), &amp;(need_switch)); \</div>
<div class="line">        portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">        ret; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Reset timer from ISR. </p>
<p>Version of OS_TIMER_RESET that can be called from an interrupt service routine</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, otherwise OS_TIMER_FAIL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gaf62357077a12d85bed42f15b88e8c772" title="Reset timer. ">OS_TIMER_RESET()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga435ecbfcbe8996f34ac2e237512c1269"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_RESET_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">        BaseType_t need_switch, ret; \</div>
<div class="line">        ret = xTimerResetFromISR((timer), &amp;(need_switch)); \</div>
<div class="line">        portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">        ret; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Reset timer from ISR. </p>
<p>Version of OS_TIMER_RESET that can be called from an interrupt service routine</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, otherwise OS_TIMER_FAIL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gaf62357077a12d85bed42f15b88e8c772" title="Reset timer. ">OS_TIMER_RESET()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8867349519f1d3d49e90dc71946d2b24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_START</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xTimerStart((timer), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start timer. </p>
<p>Function starts timer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle returned in OS_TIMER_CREATE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, or OS_TIMER_FAIL if timeout occur </dd></dl>

</div>
</div>
<a class="anchor" id="ga06fac74ca16c0a48fd92fecc0d414a1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_START_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">        BaseType_t need_switch, ret; \</div>
<div class="line">        ret = xTimerStartFromISR((timer), &amp;(need_switch)); \</div>
<div class="line">        portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">        ret; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Start timer from ISR. </p>
<p>Version of OS_TIMER_START that can be called from an interrupt service routine</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, otherwise OS_TIMER_FAIL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#ga8867349519f1d3d49e90dc71946d2b24" title="Start timer. ">OS_TIMER_START()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa365dd8088897672c6831793ab257532"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_STOP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;xTimerStop((timer), (timeout))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop timer. </p>
<p>Function stops timer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle returned in OS_TIMER_CREATE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time in ticks to wait until command is sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, or OS_TIMER_FAIL if timeout occur </dd></dl>

</div>
</div>
<a class="anchor" id="gaca5b4d5fff2947d1806559243e9fcdde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OS_TIMER_STOP_FROM_ISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">timer</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({ \</div>
<div class="line">        BaseType_t need_switch, ret; \</div>
<div class="line">        ret = xTimerStopFromISR((timer), &amp;(need_switch)); \</div>
<div class="line">        portEND_SWITCHING_ISR(need_switch); \</div>
<div class="line">        ret; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Stop timer from ISR. </p>
<p>Version of OS_TIMER_STOP that can be called from an interrupt service routine</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>timer handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OS_TIMER_SUCCESS if command has been sent successfully, otherwise OS_TIMER_FAIL</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_s_a_l.html#gaa365dd8088897672c6831793ab257532" title="Stop timer. ">OS_TIMER_STOP()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga91db83d76f11008246e38e80bfeb24cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_a_l.html#ga91db83d76f11008246e38e80bfeb24cd">OS_NOTIFY_ACTION</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OS Notification action. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga91db83d76f11008246e38e80bfeb24cdacf8af7394792ac07a6fb45b6966322ed"></a>OS_NOTIFY_NO_ACTION&#160;</td><td class="fielddoc">
<p>subject task receives event, but its notification value is not updated </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91db83d76f11008246e38e80bfeb24cda707e11498965fb2a27d28003922eb33a"></a>OS_NOTIFY_SET_BITS&#160;</td><td class="fielddoc">
<p>notification value of subject task will be bitwise ORed with task value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91db83d76f11008246e38e80bfeb24cdadcdfb5913c4529e5673b6c2ae65ab1f3"></a>OS_NOTIFY_INCREMENT&#160;</td><td class="fielddoc">
<p>notification value of subject task will be incremented by one </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91db83d76f11008246e38e80bfeb24cda63b4d57115eb7e18e77dda410c8c8d16"></a>OS_NOTIFY_VAL_WITH_OVERWRITE&#160;</td><td class="fielddoc">
<p>notification value of subject task is unconditionally set to task value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga91db83d76f11008246e38e80bfeb24cda4236b135cee8aa0ea383216a2a6600f3"></a>OS_NOTIFY_VAL_WITHOUT_OVERWRITE&#160;</td><td class="fielddoc">
<p>if subject task has a notification pending then notification value will be set to task value otherwise task value is not updated </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gabe06d898bcd0410afc12cd1164cdb658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___o_s_a_l.html#gabe06d898bcd0410afc12cd1164cdb658">OS_TASK_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OS Task state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggabe06d898bcd0410afc12cd1164cdb658ae6721aefc70c2f731dd95976c86e2d08"></a>OS_TASK_RUNNING&#160;</td><td class="fielddoc">
<p>Task is in running state, a task is querying the state of itself </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabe06d898bcd0410afc12cd1164cdb658a529cd0e1f131f501efe7cc3d1122d002"></a>OS_TASK_READY&#160;</td><td class="fielddoc">
<p>Task is in a ready state </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabe06d898bcd0410afc12cd1164cdb658a4705e6f6965e05b68e1fd805005f1fed"></a>OS_TASK_BLOCKED&#160;</td><td class="fielddoc">
<p>Task is in blocked state </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabe06d898bcd0410afc12cd1164cdb658a62ddebcd9f9807614278e7999168ec7e"></a>OS_TASK_SUSPENDED&#160;</td><td class="fielddoc">
<p>Task is in the suspended state, or is in the blocked state with an infinite time out </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabe06d898bcd0410afc12cd1164cdb658af3928fd43595cf4864252be0d5a0fd27"></a>OS_TASK_DELETED&#160;</td><td class="fielddoc">
<p>Task is deleted, but its TCB has not yet been freed </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:06 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
