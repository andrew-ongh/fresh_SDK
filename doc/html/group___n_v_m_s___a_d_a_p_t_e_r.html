<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: NVMS_ADAPTER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NVMS_ADAPTER<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___a_d_a_p_t_e_r_s.html">ADAPTERS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>NVMS adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__nvms_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__nvms_8h.html">ad_nvms.h</a></td></tr>
<tr class="memdesc:ad__nvms_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMS adapter API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdriver__t.html">driver_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition driver functions.  <a href="structdriver__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpartition__t.html">partition_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition structure for RAM.  <a href="structpartition__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf187cc27b130203f0e87adb1135d81cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf187cc27b130203f0e87adb1135d81cb"></a>
typedef struct <a class="el" href="structdriver__t.html">driver_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gaf187cc27b130203f0e87adb1135d81cb">partition_driver_t</a></td></tr>
<tr class="memdesc:gaf187cc27b130203f0e87adb1135d81cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition driver functions. <br /></td></tr>
<tr class="separator:gaf187cc27b130203f0e87adb1135d81cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa21e162524ac868fa01572e7d4eee33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa21e162524ac868fa01572e7d4eee33"></a>
typedef struct <a class="el" href="structpartition__t.html">partition_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gaaa21e162524ac868fa01572e7d4eee33">partition_t</a></td></tr>
<tr class="memdesc:gaaa21e162524ac868fa01572e7d4eee33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition structure for RAM. <br /></td></tr>
<tr class="separator:gaaa21e162524ac868fa01572e7d4eee33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac31a0333a6b796574bf4a74b292a1dcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac31a0333a6b796574bf4a74b292a1dcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gac31a0333a6b796574bf4a74b292a1dcc">ad_nvms_init</a> (void)</td></tr>
<tr class="memdesc:gac31a0333a6b796574bf4a74b292a1dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize NVMS adapter. <br /></td></tr>
<tr class="separator:gac31a0333a6b796574bf4a74b292a1dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93bde7e38f4a613848d0736772e567b3"><td class="memItemLeft" align="right" valign="top">nvms_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#ga93bde7e38f4a613848d0736772e567b3">ad_nvms_open</a> (<a class="el" href="partition__def_8h.html#a3c13e35b500ea52d2e9a1f5f1d8116c2">nvms_partition_id_t</a> id)</td></tr>
<tr class="memdesc:ga93bde7e38f4a613848d0736772e567b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open partition to read/write access.  <a href="#ga93bde7e38f4a613848d0736772e567b3">More...</a><br /></td></tr>
<tr class="separator:ga93bde7e38f4a613848d0736772e567b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada343ae6741983e42362af18ac69f60f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gada343ae6741983e42362af18ac69f60f">ad_nvms_get_size</a> (nvms_t handle)</td></tr>
<tr class="memdesc:gada343ae6741983e42362af18ac69f60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get partition size.  <a href="#gada343ae6741983e42362af18ac69f60f">More...</a><br /></td></tr>
<tr class="separator:gada343ae6741983e42362af18ac69f60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889f14cc95a2e3bb97d5983cc2196a84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#ga889f14cc95a2e3bb97d5983cc2196a84">ad_nvms_read</a> (nvms_t handle, uint32_t addr, uint8_t *buf, uint32_t len)</td></tr>
<tr class="memdesc:ga889f14cc95a2e3bb97d5983cc2196a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read partition data.  <a href="#ga889f14cc95a2e3bb97d5983cc2196a84">More...</a><br /></td></tr>
<tr class="separator:ga889f14cc95a2e3bb97d5983cc2196a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga281d7b21afa25728d3dbb4cf5ba922ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#ga281d7b21afa25728d3dbb4cf5ba922ce">ad_nvms_write</a> (nvms_t handle, uint32_t addr, const uint8_t *buf, uint32_t size)</td></tr>
<tr class="memdesc:ga281d7b21afa25728d3dbb4cf5ba922ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to partition.  <a href="#ga281d7b21afa25728d3dbb4cf5ba922ce">More...</a><br /></td></tr>
<tr class="separator:ga281d7b21afa25728d3dbb4cf5ba922ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7bef7ec9627d39de00453af40ea5865"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gae7bef7ec9627d39de00453af40ea5865">ad_nvms_erase_region</a> (nvms_t handle, uint32_t addr, size_t size)</td></tr>
<tr class="memdesc:gae7bef7ec9627d39de00453af40ea5865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase partition region.  <a href="#gae7bef7ec9627d39de00453af40ea5865">More...</a><br /></td></tr>
<tr class="separator:gae7bef7ec9627d39de00453af40ea5865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abe17c4055d4113b74363fff39680a7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#ga7abe17c4055d4113b74363fff39680a7">ad_nvms_get_pointer</a> (nvms_t handle, uint32_t addr, size_t size, const void **ptr)</td></tr>
<tr class="memdesc:ga7abe17c4055d4113b74363fff39680a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get direct read buffer pointer.  <a href="#ga7abe17c4055d4113b74363fff39680a7">More...</a><br /></td></tr>
<tr class="separator:ga7abe17c4055d4113b74363fff39680a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad72ad23b604506bca3013132c020231b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gad72ad23b604506bca3013132c020231b">ad_nvms_erase_size</a> (void)</td></tr>
<tr class="memdesc:gad72ad23b604506bca3013132c020231b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get partition erase size.  <a href="#gad72ad23b604506bca3013132c020231b">More...</a><br /></td></tr>
<tr class="separator:gad72ad23b604506bca3013132c020231b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c4064c4ee62bafdf91cd7bf5738ee0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#ga39c4064c4ee62bafdf91cd7bf5738ee0">ad_nvms_get_partition_count</a> (void)</td></tr>
<tr class="memdesc:ga39c4064c4ee62bafdf91cd7bf5738ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get partition count.  <a href="#ga39c4064c4ee62bafdf91cd7bf5738ee0">More...</a><br /></td></tr>
<tr class="separator:ga39c4064c4ee62bafdf91cd7bf5738ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c2fd9c03569570e0533d3637c4dbe6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gac6c2fd9c03569570e0533d3637c4dbe6">ad_nvms_get_partition_info</a> (size_t index, <a class="el" href="structpartition__entry__t.html">partition_entry_t</a> *info)</td></tr>
<tr class="memdesc:gac6c2fd9c03569570e0533d3637c4dbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get partition info.  <a href="#gac6c2fd9c03569570e0533d3637c4dbe6">More...</a><br /></td></tr>
<tr class="separator:gac6c2fd9c03569570e0533d3637c4dbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf40d9a22828ddd030dea819f555b690"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gaaf40d9a22828ddd030dea819f555b690">ad_nvms_no_cache_flushing</a> (nvms_t handle, uint32_t base, uint32_t size)</td></tr>
<tr class="memdesc:gaaf40d9a22828ddd030dea819f555b690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control cache flushing on modifications (writes or erases) to a partition.  <a href="#gaaf40d9a22828ddd030dea819f555b690">More...</a><br /></td></tr>
<tr class="separator:gaaf40d9a22828ddd030dea819f555b690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa15bfa6786a1e12b07d6c6d6b13a7e48"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gaa15bfa6786a1e12b07d6c6d6b13a7e48">ad_nvms_mandatory_cache_flushing</a> (void)</td></tr>
<tr class="separator:gaa15bfa6786a1e12b07d6c6d6b13a7e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga372b4475d2518a6894cb8d784b3036d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#ga372b4475d2518a6894cb8d784b3036d9">ad_nvms_flush</a> (nvms_t handle, bool free_mem)</td></tr>
<tr class="memdesc:ga372b4475d2518a6894cb8d784b3036d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush all data buffered in RAM to partition.  <a href="#ga372b4475d2518a6894cb8d784b3036d9">More...</a><br /></td></tr>
<tr class="separator:ga372b4475d2518a6894cb8d784b3036d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>NVMS adapter. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae7bef7ec9627d39de00453af40ea5865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad_nvms_erase_region </td>
          <td>(</td>
          <td class="paramtype">nvms_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase partition region. </p>
<dl class="section note"><dt>Note</dt><dd>: All sectors that have offset in range of &lt;addr, add + size) will be erased.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>partition handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset of sector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a class="anchor" id="gad72ad23b604506bca3013132c020231b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_nvms_erase_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get partition erase size. </p>
<dl class="section return"><dt>Returns</dt><dd>minimum size that can be erased </dd></dl>

</div>
</div>
<a class="anchor" id="ga372b4475d2518a6894cb8d784b3036d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_nvms_flush </td>
          <td>(</td>
          <td class="paramtype">nvms_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_mem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush all data buffered in RAM to partition. </p>
<p>In order to improve erase/write performance, data may not be written to storage device immediately. Call this function to make sure all data is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>partition handle</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_mem</td><td>true - free allocated memory for cached data, false - flush without freeing memory for cached data. Copy of data still exists in RAM cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga39c4064c4ee62bafdf91cd7bf5738ee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_nvms_get_partition_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get partition count. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of partitions </dd></dl>

</div>
</div>
<a class="anchor" id="gac6c2fd9c03569570e0533d3637c4dbe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad_nvms_get_partition_info </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpartition__entry__t.html">partition_entry_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get partition info. </p>
<dl class="section return"><dt>Returns</dt><dd>true if partition exists, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga7abe17c4055d4113b74363fff39680a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_nvms_get_pointer </td>
          <td>(</td>
          <td class="paramtype">nvms_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get direct read buffer pointer. </p>
<p>Function will fill ptr with CPU address that can be used to directly access partition data. Parameter size specifies how many bytes caller wants to access. Note however that returned size can be smaller if addr + size exceeds partition size. This value can also be smaller if partition uses wear leveling that results in non linear data storage. If partition driver does not support direct mapping function will return 0 and no valid ptr will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>partition handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>requested address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>pointer to store direct address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes that can be accessed with this pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gada343ae6741983e42362af18ac69f60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_nvms_get_size </td>
          <td>(</td>
          <td class="paramtype">nvms_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get partition size. </p>
<dl class="section return"><dt>Returns</dt><dd>size in bytes of partition </dd></dl>

</div>
</div>
<a class="anchor" id="gaa15bfa6786a1e12b07d6c6d6b13a7e48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ad_nvms_mandatory_cache_flushing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turn off any selective cache flushing that may have been enabled by </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gaaf40d9a22828ddd030dea819f555b690" title="Control cache flushing on modifications (writes or erases) to a partition. ">ad_nvms_no_cache_flushing()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf40d9a22828ddd030dea819f555b690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad_nvms_no_cache_flushing </td>
          <td>(</td>
          <td class="paramtype">nvms_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control cache flushing on modifications (writes or erases) to a partition. </p>
<p>This function can be used to define a partition region that will not trigger cache flushing when writes or erases occur in that region. Only one such partition region can be active at any time, in total.</p>
<p>This feature is useful when the programmer knows in advance that a partition region is going to be updated (e.g. firmware update). However, reads from that region should be avoided, as they might lead to cache incoherency.</p>
<dl class="section note"><dt>Note</dt><dd>The effect of this function is at ad_flash_* layer and higher. For example, direct use of the hw_qspi_* API will not be affected by the use of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Partition handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Starting offset of the partition region that should not trigger cache flushes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the partition region that should not trigger cache flushes. If size is such that it would extend beyond the end of the partition, the region size is truncated to match the end of the partition. If size is 0, selective cache flushing is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if partition exists and base , false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___n_v_m_s___a_d_a_p_t_e_r.html#gaa15bfa6786a1e12b07d6c6d6b13a7e48">ad_nvms_mandatory_cache_flushing()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga93bde7e38f4a613848d0736772e567b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nvms_t ad_nvms_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="partition__def_8h.html#a3c13e35b500ea52d2e9a1f5f1d8116c2">nvms_partition_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open partition to read/write access. </p>
<p>There can be only one partition with given id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>partition to get access to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to use for partition access, NULL if partition does not exists </dd></dl>

</div>
</div>
<a class="anchor" id="ga889f14cc95a2e3bb97d5983cc2196a84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_nvms_read </td>
          <td>(</td>
          <td class="paramtype">nvms_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read partition data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>partition handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to read data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, &lt; 0 in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga281d7b21afa25728d3dbb4cf5ba922ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_nvms_write </td>
          <td>(</td>
          <td class="paramtype">nvms_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data to partition. </p>
<p>This function allows to write any number of bytes to partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>partition handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>offset in partition to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<p>return number of bytes written, &lt; 0 if case of error </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:05 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
