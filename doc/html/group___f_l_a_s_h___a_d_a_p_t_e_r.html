<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: FLASH_ADAPTER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FLASH_ADAPTER<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___a_d_a_p_t_e_r_s.html">ADAPTERS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Flash adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__flash_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__flash_8h.html">ad_flash.h</a></td></tr>
<tr class="memdesc:ad__flash_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash adapter API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabb0ff70d27cb795c678201fa6eabb6cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gabb0ff70d27cb795c678201fa6eabb6cb">AD_FLASH_ALWAYS_FLUSH_CACHE</a>&#160;&#160;&#160;((uint32_t)-1)</td></tr>
<tr class="separator:gabb0ff70d27cb795c678201fa6eabb6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga502c902619ade1fd5c7f02538ae3cdc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga502c902619ade1fd5c7f02538ae3cdc8">ad_flash_init</a> (void)</td></tr>
<tr class="memdesc:ga502c902619ade1fd5c7f02538ae3cdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize flash access.  <a href="#ga502c902619ade1fd5c7f02538ae3cdc8">More...</a><br /></td></tr>
<tr class="separator:ga502c902619ade1fd5c7f02538ae3cdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df7b1a1a2c426240ee5d60d6437d880"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga4df7b1a1a2c426240ee5d60d6437d880">ad_flash_read</a> (uint32_t addr, uint8_t *buf, size_t len)</td></tr>
<tr class="memdesc:ga4df7b1a1a2c426240ee5d60d6437d880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read flash memory.  <a href="#ga4df7b1a1a2c426240ee5d60d6437d880">More...</a><br /></td></tr>
<tr class="separator:ga4df7b1a1a2c426240ee5d60d6437d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32898eb36d9af7b716badc7f9909ae9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf32898eb36d9af7b716badc7f9909ae9">ad_flash_write</a> (uint32_t addr, const uint8_t *buf, size_t size)</td></tr>
<tr class="memdesc:gaf32898eb36d9af7b716badc7f9909ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write flash memory.  <a href="#gaf32898eb36d9af7b716badc7f9909ae9">More...</a><br /></td></tr>
<tr class="separator:gaf32898eb36d9af7b716badc7f9909ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc8fadbe7293f7adf1478a480d2f25d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga6bc8fadbe7293f7adf1478a480d2f25d">ad_flash_erase_region</a> (uint32_t addr, size_t size)</td></tr>
<tr class="memdesc:ga6bc8fadbe7293f7adf1478a480d2f25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase flash region.  <a href="#ga6bc8fadbe7293f7adf1478a480d2f25d">More...</a><br /></td></tr>
<tr class="separator:ga6bc8fadbe7293f7adf1478a480d2f25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e12af1147b3b53cdc2756bb4e2ab15"><td class="memItemLeft" align="right" valign="top">static const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga77e12af1147b3b53cdc2756bb4e2ab15">ad_flash_get_ptr</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga77e12af1147b3b53cdc2756bb4e2ab15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to QSPI mapped flash.  <a href="#ga77e12af1147b3b53cdc2756bb4e2ab15">More...</a><br /></td></tr>
<tr class="separator:ga77e12af1147b3b53cdc2756bb4e2ab15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf815e083ba566721b2073b399d4f34d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaf815e083ba566721b2073b399d4f34d4">ad_flash_update_possible</a> (uint32_t addr, const uint8_t *data_to_write, size_t size)</td></tr>
<tr class="memdesc:gaf815e083ba566721b2073b399d4f34d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if update without erase is possible.  <a href="#gaf815e083ba566721b2073b399d4f34d4">More...</a><br /></td></tr>
<tr class="separator:gaf815e083ba566721b2073b399d4f34d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7095a8f40b213ab179119540186a32"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaff7095a8f40b213ab179119540186a32">ad_flash_erase_size</a> (void)</td></tr>
<tr class="memdesc:gaff7095a8f40b213ab179119540186a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flash erase size.  <a href="#gaff7095a8f40b213ab179119540186a32">More...</a><br /></td></tr>
<tr class="separator:gaff7095a8f40b213ab179119540186a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24880551f720c3948bb1c7cbddf96728"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24880551f720c3948bb1c7cbddf96728"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga24880551f720c3948bb1c7cbddf96728">ad_flash_chip_erase</a> (void)</td></tr>
<tr class="memdesc:ga24880551f720c3948bb1c7cbddf96728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase whole flash. <br /></td></tr>
<tr class="separator:ga24880551f720c3948bb1c7cbddf96728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599410ebcbd4ed9926998fc5bd786521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga599410ebcbd4ed9926998fc5bd786521">ad_flash_lock</a> (void)</td></tr>
<tr class="memdesc:ga599410ebcbd4ed9926998fc5bd786521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock access to entire flash.  <a href="#ga599410ebcbd4ed9926998fc5bd786521">More...</a><br /></td></tr>
<tr class="separator:ga599410ebcbd4ed9926998fc5bd786521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf216c3b8d8a1cfefb1a08ab428a2d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gafcf216c3b8d8a1cfefb1a08ab428a2d4">ad_flash_unlock</a> (void)</td></tr>
<tr class="memdesc:gafcf216c3b8d8a1cfefb1a08ab428a2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock access to entire flash.  <a href="#gafcf216c3b8d8a1cfefb1a08ab428a2d4">More...</a><br /></td></tr>
<tr class="separator:gafcf216c3b8d8a1cfefb1a08ab428a2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa461b05c8ba275de7a21a628f562bc61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaa461b05c8ba275de7a21a628f562bc61">ad_flash_skip_cache_flushing</a> (uint32_t base, uint32_t size)</td></tr>
<tr class="memdesc:gaa461b05c8ba275de7a21a628f562bc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control cache flushing on modifications (writes or erases) to flash.  <a href="#gaa461b05c8ba275de7a21a628f562bc61">More...</a><br /></td></tr>
<tr class="separator:gaa461b05c8ba275de7a21a628f562bc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Flash adapter. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gabb0ff70d27cb795c678201fa6eabb6cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AD_FLASH_ALWAYS_FLUSH_CACHE&#160;&#160;&#160;((uint32_t)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Special base address that can be used with </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gaa461b05c8ba275de7a21a628f562bc61" title="Control cache flushing on modifications (writes or erases) to flash. ">ad_flash_skip_cache_flushing</a> to return to default cache flushing mode: all flash writes/erases trigger cache flushing. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6bc8fadbe7293f7adf1478a480d2f25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ad_flash_erase_region </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase flash region. </p>
<dl class="section note"><dt>Note</dt><dd>: All sectors that have offset in range of &lt;addr, addr + size) will be erased. If addr is not sector aligned preceding data on sector that addr belong to will also be erased. If addr + size is not sector aligned whole sector will also be erased.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset of sector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a class="anchor" id="gaff7095a8f40b213ab179119540186a32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_flash_erase_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flash erase size. </p>
<dl class="section return"><dt>Returns</dt><dd>minimum size that can be erased </dd></dl>

</div>
</div>
<a class="anchor" id="ga77e12af1147b3b53cdc2756bb4e2ab15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const void* ad_flash_get_ptr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to QSPI mapped flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>address in flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to QSPI mapped flash </dd></dl>

</div>
</div>
<a class="anchor" id="ga502c902619ade1fd5c7f02538ae3cdc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize flash access. </p>
<p>This function must be called before any other ad_flash_* function </p>

</div>
</div>
<a class="anchor" id="ga599410ebcbd4ed9926998fc5bd786521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock access to entire flash. </p>
<p>Function gets flash for exclusive usage </p>

</div>
</div>
<a class="anchor" id="ga4df7b1a1a2c426240ee5d60d6437d880"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_flash_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read flash memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to read data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read </dd></dl>

</div>
</div>
<a class="anchor" id="gaa461b05c8ba275de7a21a628f562bc61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_skip_cache_flushing </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control cache flushing on modifications (writes or erases) to flash. </p>
<p>This function can be used to enable or disable the triggering of cache flushing when writes or erases occur in a specific flash region. Only one such flash region can be defined.</p>
<p>This feature is useful when the programmer knows in advance that a big flash region is going to be updated (e.g. firmware update). However, flash reads from that region should be avoided, as they might lead to cache incoherency.</p>
<dl class="section note"><dt>Note</dt><dd>The effect of this function is at ad_flash_* layer and higher. For example, direct use of the hw_qspi_* API will not be affected by the use of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Starting offset of the flash region that should not trigger a cache flushing. If </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#gabb0ff70d27cb795c678201fa6eabb6cb">AD_FLASH_ALWAYS_FLUSH_CACHE</a> is passed, selective cache flushing is disabled, regardless of the value of size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the flash region that should not trigger cache flushing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafcf216c3b8d8a1cfefb1a08ab428a2d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_flash_unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock access to entire flash. </p>
<p>Function release lock taken by </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___f_l_a_s_h___a_d_a_p_t_e_r.html#ga599410ebcbd4ed9926998fc5bd786521" title="Lock access to entire flash. ">ad_flash_lock()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf815e083ba566721b2073b399d4f34d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_flash_update_possible </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data_to_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if update without erase is possible. </p>
<p>Update is possible when only "0s" have to be written.</p>
<p>This function test if its possible to write to flash without erase. If function returns size, data did not change no erase needed. If non negative value means that write can be performed some bits will be cleared on write Negative value erase is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset of sector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_to_write</td><td>data to write to flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 - erase is needed &gt;= number of bytes that do not need to be written (same) 0 means that write should start from offset 0 but no erase is needed. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf32898eb36d9af7b716badc7f9909ae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ad_flash_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write flash memory. </p>
<p>This function allows to write any number of bytes to flash. Memory should be erased before.</p>
<dl class="section note"><dt>Note</dt><dd>: Do not pass buf pointing to QSPI mapped memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>offset in flash to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<p>return number of bytes written </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:05 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
