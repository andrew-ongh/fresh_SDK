<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: CLI programmer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">CLI programmer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Overview</h2>
<p><code>cli_programmer</code> is a command line tool for reading &amp; writing to FLASH/OTP/RAM. It also provides some extra functions like loading &amp; executing an image from RAM. The tool communicates with the target device over uart port or jtag interface. It executes on Windows and Linux platforms.</p>
<blockquote class="doxtable">
<p>Note: Writing an image to flash or OTP requires adding a header to the image. This process is handled by the &gt;'bin2image' tool or the 'cli_programmer write_qspi_exec'/'cli_programmer write_otp_exec' commands </p>
</blockquote>
<h2>Usage</h2>
<p>To run cli_programmer user has to specify interface (GDB server of serial port) and requested command. </p><pre class="fragment">cli_programmer [&lt;options&gt;] &lt;interface&gt; &lt;command&gt; [&lt;args&gt;]
</pre><h3>Interface</h3>
<ul>
<li>the serial port file name as presented by the operating system e.g. <b><code>COM5</code></b> (Windows), <b><code>/dev/ttyUSB0</code></b> (Linux), or</li>
<li><b><code>gdbserver</code></b>, if jtag interface is to be used (J-Link debugger with the GDB server)</li>
</ul>
<h3>Commands and arguments</h3>
<pre class="fragment">write_qspi &lt;address&gt; &lt;file&gt; [&lt;size&gt;]
</pre><p>Writes up to <code>size</code> bytes of <code>file</code> into the FLASH at <code>address</code>. If <code>size</code> is omitted, a complete file is written. </p><pre class="fragment">write_qspi_bytes &lt;address&gt; &lt;data1&gt; [&lt;data2&gt; [...]]
</pre><p>Writes bytes specified on command line into the FLASH at <code>address</code>. </p><pre class="fragment">write_qspi_exec &lt;image_file&gt;
</pre><p>Writes binary file (.bin) to flash at address 0, after adding header for execution in place (cached mode). </p><pre class="fragment">write_suota_image &lt;image_file&gt; &lt;version&gt;
</pre><p>Writes SUOTA enabled <code>image_file</code> to executable partition. The user supplied <code>version</code> string goes to image header. </p><pre class="fragment">read_qspi &lt;address&gt; &lt;file&gt; &lt;size&gt;
</pre><p>Reads <code>size</code> bytes from the FLASH memory, starting at <code>address</code> into <code>file</code>. If <code>file</code> is specified as either '-' or '&ndash;', data is output to stdout as hexdump. The hexdump is either 16-bytes (-) or 32-bytes (&ndash;) wide. </p><pre class="fragment">erase_qspi &lt;address&gt; &lt;size&gt;
</pre><p>Erases <code>size</code> bytes of the FLASH, starting at <code>address</code>. Note: an actual erased area may be different due to the size of an erase block. </p><pre class="fragment">chip_erase_qspi
</pre><p>Erases the whole FLASH. </p><pre class="fragment">copy_qspi &lt;address_ram&gt; &lt;address_qspi&gt; &lt;size&gt;
</pre><p>Copies <code>size</code> bytes from the RAM memory, starting at <code>address_ram</code> to FLASH at <code>address_flash</code>. This is an advanced command an is not needed by end user. </p><pre class="fragment">is_empty_qspi [start_address size]
</pre><p>Checks that FLASH contains only 0xFF values. If no arguments are specified starting address is 0 and size is 1M. Command prints whether flash is empty and if offset of first non empty byte. </p><pre class="fragment">read_partition_table
</pre><p>Reads the partition table (if any exists) and prints its contents. </p><pre class="fragment">read_partition &lt;part_name|part_id&gt; &lt;address&gt; &lt;file&gt; &lt;size&gt;
</pre><p>Reads <code>size</code> bytes from partition, selected by <code>part_name</code> or <code>part_id</code> following the below table, starting at <code>address</code> into <code>file</code>. If <code>file</code> is specified as either '-' or '&ndash;', data is output to stdout as hexdump. The hexdump is either 16-bytes (-) or 32-bytes (&ndash;) wide.</p>
<table class="doxtable">
<tr>
<th>part_name </th><th>part_id  </th></tr>
<tr>
<td>NVMS_FIRMWARE_PART </td><td>1 </td></tr>
<tr>
<td>NVMS_PARAM_PART </td><td>2 </td></tr>
<tr>
<td>NVMS_BIN_PART </td><td>3 </td></tr>
<tr>
<td>NVMS_LOG_PART </td><td>4 </td></tr>
<tr>
<td>NVMS_GENERIC_PART </td><td>5 </td></tr>
<tr>
<td>NVMS_PLATFORM_PARAMS_PART </td><td>15 </td></tr>
<tr>
<td>NVMS_PARTITION_TABLE </td><td>16 </td></tr>
<tr>
<td>NVMS_FW_EXEC_PART </td><td>17 </td></tr>
<tr>
<td>NVMS_FW_UPDATE_PART </td><td>18 </td></tr>
<tr>
<td>NVMS_PRODUCT_HEADER_PART </td><td>19 </td></tr>
<tr>
<td>NVMS_IMAGE_HEADER_PART </td><td>20 </td></tr>
</table>
<pre class="fragment">write_partition &lt;part_name|part_id&gt; &lt;address&gt; &lt;file&gt; [&lt;size&gt;]
</pre><p>Writes up to <code>size</code> bytes of <code>file</code> into NVMS partition, selected by <code>part_name</code> or <code>part_id</code> according to the above table, at <code>address</code>. If <code>size</code> is omitted, complete file is written. If <code>file</code> is specified as either '-' or '&ndash;', data is output to stdout as hexdump. The hexdump is either 16-bytes (-) or 32-bytes (&ndash;) wide. </p><pre class="fragment">write_partition_bytes &lt;part_name|part_id&gt; &lt;address&gt; &lt;data1&gt; [&lt;data2&gt; [...]]
</pre><p>Writes bytes specified on command line into the NVMS partition, selected by <code>part_name</code> or <code>part_id</code> according to the above table, at <code>address</code>. </p><pre class="fragment">write &lt;address&gt; &lt;file&gt; [&lt;size&gt;]
</pre><p>Writes up to <code>size</code> bytes of <code>file</code> into the RAM memory at <code>address</code>. If <code>size</code> is omitted, a complete <code>file</code> is written. </p><pre class="fragment">read &lt;address&gt; &lt;file&gt; &lt;size&gt;
</pre><p>Reads <code>size</code> bytes from the RAM memory, starting at <code>address</code> into <code>file</code>. If <code>file</code> is specified as either '-' or '&ndash;', data is output to stdout as hexdump. The hexdump is either 16-bytes (-) or 32-bytes (&ndash;) wide. </p><pre class="fragment">write_otp &lt;address&gt; &lt;length&gt; [&lt;data&gt; [&lt;data&gt; [...]]]
</pre><p>Writes <code>length</code> words to the OTP at <code>address</code>. <code>data</code> are 32-bit words to be written, if less than <code>length</code> words are specified, remaining words are assumed to be 0x00. </p><pre class="fragment">write_otp_raw_file &lt;address&gt; &lt;file&gt; [&lt;size&gt;]
</pre><p>Writes up to <code>size</code> bytes of <code>file</code> into the OTP at <code>address</code>. If <code>size</code> is omitted, the complete file is written. Remaining bytes in the last word are assumed to be 0x00. </p><pre class="fragment">read_otp &lt;address&gt; &lt;length&gt;
</pre><p>Reads <code>length</code> 32-bit words from the OTP address <code>address</code>. </p><pre class="fragment">write_otp_file &lt;file&gt;
</pre><p>Writes data to the OTP as defined in <code>file</code> (default specified values are written). <code>file</code> is a CSV file separated by tabs. <b> <code>example_otp_file.csv</code> </b> is an example file which could be used with this command. Most of columns in this file have only informational purpose. <code>cli_programmer</code> uses only hese 3 columns as follow: address, size and default, but other columns are needed for proper parsing of the file. A short description of each column:</p>
<ul>
<li><b> Address </b> - could be a cell address or cell address combined with <code>OTP_BASE</code> (0x07F80000)</li>
<li><b> Size </b> - number of bytes required by this item</li>
<li><b> Type </b> - type of item, e.g flag, region or byte</li>
<li><b> RW or RO </b> - read/write or read only item (only for information)</li>
<li><b> ShortName </b> - name of item</li>
<li><b> Description </b> - short description about item, it could contain option's values and descriptions</li>
<li><b> Default </b> - value which will be written to OTP</li>
<li><b> Number of Options </b> - this column contains a number of options written in the next columns. Each option contains its description placed in a separate column as follow: option 1 | description 1 | option 2 | description 2 | ...</li>
</ul>
<pre class="fragment">read_otp_file &lt;file&gt;
</pre><p>Reads data from the OTP as defined in <code>file</code> (cells with default value provided are read) contents of each cell is printed to stdout. </p><pre class="fragment">write_otp_exec &lt;binary_file&gt; [CACHED]
</pre><p>Creates image from application binary and writes it to the OTP. Image's length, mode, CRC and non-volatile memory fields in OTP header are set also. If 'CACHED' argument is passed then image is created in cached mode instead of default mirrored mode. </p><pre class="fragment">write_tcs &lt;length&gt; [&lt;reg_addr&gt; &lt;reg_data&gt; [&lt;reg_addr&gt; &lt;reg_data&gt;  [...]]]
</pre><p>Writes <code>length</code> 64-bit words to the OTP TCS section at first available (filled with 0) section of size <code>length</code>.</p>
<p><code>reg_addr</code>: the register address. It will be written as a 64-bit word [<code>reg_addr</code>, <code>~reg_addr</code>]</p>
<p><code>reg_data</code>: the register data. It will be written as a 64-bit word [<code>reg_data</code>, <code>~reg_data</code>] </p><pre class="fragment">boot
</pre><p>Boots the 2nd stage bootloader or the application binary (defined with -b) and exits. </p><pre class="fragment">read_chip_info 
</pre><p>Reads chip information from chip revision registers and otp header. When 'simple' mode is used, only the chip info stored in registers is returned (no OTP header read). 'simple' mode is available with GDB Server interface only. 'simple' mode should be used with '-b attach' option for best performance. </p><pre class="fragment">read_unique_device_id
</pre><p>Reads unique device identifier (16 bytes) from OTP memory. </p><pre class="fragment">write_key &lt;sym|asym&gt; &lt;key_idx&gt; &lt;key&gt;
</pre><p>Writes symmetric or asymmetric key and its bit inversion to the OTP memory. <code>key_idx</code> is a key's (and inverted key's) index in OTP. Valid range for this argument is 0-3 for asymmetric keys and 0-7 for symmetric keys. <code>key</code> is a key hexadecimal string without any prefixes e.g. 00112233AABBCCDD. The asymmetric key must have from 32 to 64 bytes length and the symmetric key must have 32 bytes length. </p><pre class="fragment">read_key [&lt;sym|asym&gt; [key_idx]]
</pre><p> Reads symmetric or asymmetric key. If <code>key_idx</code> is not passed then all asymmetric/symmetric keys are read (type is selected by <code>sym|asym</code>). If <code>sym|asym</code> is not passed then all asymmetric and symmetric keys are read.</p>
<h3>General options</h3>
<pre class="fragment">-h
</pre><p>Prints help screen and exits. </p><pre class="fragment">--save-ini
</pre><p>Saves CLI programmer configuration to the <code>cli_programmer.ini</code> file and exits. </p><pre class="fragment">-b file
</pre><p>Filename of 2nd stage bootloader or application binary. In GDB Server interface mode this could be also 'attach' keyword. This keyword ommits platform reset and loading of bootloader binary. </p><pre class="fragment">--trc &lt;cmd&gt;
</pre><p>Target reset command. May be used if there is a need to replace the default localhost reset command. This option shouldn't be used with '&ndash;check-booter-load' option - in other case this option is ignored.</p>
<h3>GDB server specific options</h3>
<pre class="fragment">-p &lt;port_num&gt;
</pre><p>TCP port number that GDB server listens to. The Default value is 2331. </p><pre class="fragment">-r &lt;host&gt;
</pre><p>GNU server host. The default is `localhost`. </p><pre class="fragment">--no-kill [mode]
</pre><p>Don't stop running GDB Server instances. Available modes: \'0\': Stop GDB Server instances during initialization and closing \'1\': Don't stop GDB Server during initialization \'2\': Don't stop GDB Server during closing \'3\' or none: Don't stop any GDB Server instance (default)</p>
<pre class="fragment">--gdb-cmd &lt;cmd&gt;
</pre><p>GDB server command used for executing and passing the right parameters to GDB server. Without this parameter no GDB server instance will be started or stopped. As GDB server command line can be quite long, it is recommended that it is stored in cli_programmer.ini file using &ndash;save-ini command line option. </p><pre class="fragment">--check-booter-load
</pre><p>Don't force bootloader loading if it is running on the platform already. This option shouldn't be used with '&ndash;trc' option - in other case '&ndash;trc' option is ignored.</p>
<h3>Serial port specific options</h3>
<pre class="fragment">-s &lt;baudrate&gt;
</pre><p>Baud rate used for UART by uartboot. The parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). This can be 9600, 19200, 57600 (default), 115200, 230400, 500000, 1000000. </p><pre class="fragment">-i &lt;baudrate&gt;
</pre><p>Initial baud rate used for uploading the <code>uartboot</code> or a user supplied binary. This depends on the rate used by the bootloader of the device. The default behavior is to use the value passed by '-s' or its default, if the parameter is not given. The argument is ignored by the <code>boot</code> command. '-s' option should be used in this case. </p><pre class="fragment">--tx-port &lt;port_num&gt;
</pre><p>GPIO port used for UART Tx by the <code>uartboot</code>. This parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). The default value is 1. This argument is ignored when the <code>boot</code> command is given. </p><pre class="fragment">--tx-pin &lt;pin_num&gt;
</pre><p>GPIO pin used for UART Tx by uartboot. This parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). The default value is 3. The argument is ignored when the <code>boot</code> command is given. </p><pre class="fragment">--rx-port &lt;port_num&gt;
</pre><p>GPIO port used for UART Rx by uartboot. This parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). The default value is 2. The argument is ignored when the <code>boot</code> command is given. </p><pre class="fragment">--rx-pin &lt;pin_num&gt;
</pre><p>GPIO pin used for UART Rx by uartboot. This parameter is patched to the uploaded uartboot binary (in that way passed as a parameter). The default value is 3. The argument is ignored when the <code>boot</code> command is given. </p><pre class="fragment">-w timeout
</pre><p>Serial port communication timeout is used only during download of uartboot binary, if during this time board will not respond cli_programmer exits with timeout error.</p>
<h3>bin2image options</h3>
<pre class="fragment">--prod-id &lt;id&gt;   Chip product id in the form of DAxxxxx-yy.
</pre><p>It applies only for write_qspi_exec cmd.</p>
<h3>Configuration file</h3>
<p>When cli_programmer is executed it first tries to read cli_programmer.ini file which may contain various cli_programmer options. Instead of creating this file manually, user should use &ndash;save-ini command line option. Format of cli_programmer.ini adheres to standard Windows ini file syntax. The cli_programmer looks for ini file in the following locations:</p>
<ul>
<li>current directory</li>
<li>home directory</li>
<li>cli_programmer executable directory</li>
</ul>
<h2>Usage examples</h2>
<p>Upload binary data to FLASH. </p><pre class="fragment">cli_programmer COM40 write_qspi 0x0 data_i
cli_programmer /dev/ttyUSB0 write_qspi 0x0 data_i
</pre><p>Upload binary data to FLASH using maximum serial port baudrate. </p><pre class="fragment">cli_programmer -s 1000000 -i 57600 COM40 write_qspi 0x0 data_i
</pre><p>Read data from FLASH to local file. </p><pre class="fragment">cli_programmer COM40 read_qspi 0x0 data_o 0x100
</pre><p>Upload custom binary <code>test_api.bin</code> to RAM and execute it. </p><pre class="fragment">cli_programmer -b test_api.bin COM40 boot
</pre><p>Modify FLASH at specified location with arguments passed in command line. </p><pre class="fragment">cli_programmer COM40 write_qspi_bytes 0x80000 0x11 0x22 0x33
</pre><p>Run a few commands with uartboot, using UART Tx/Rx P1_3/P2_3 at baud rate 115200 (initial rate for uartboot uploading is 9600). </p><pre class="fragment">cli_programmer -i 9600 -s 115200 --tx-port 1 --tx-pin 3 --rx-port 2 --rx-pin 3 COM40 write_qspi 0x0 data_i
cli_programmer -i 9600 -s 115200 --tx-port 1 --tx-pin 3 --rx-port 2 --rx-pin 3 COM40 read_qspi 0x0 data_o 0x100
</pre><p>Read FLASH contents (10 bytes at address 0x0). </p><pre class="fragment">cli_programmer gdbserver read_qspi 0 -- 10
</pre><p>Write register 0x50003000 with value 0x00FF and register 0x50003002 with value 0x00AA. </p><pre class="fragment">cli_programmer gdbserver write_tcs 4 0x50003000 0x00FF 0x50003002 0x00AA
</pre><p>Write settings to the <code>cli_programmer.ini</code> file. Long bootloader path is passed with -b option and command line to start GDB server is passed with &ndash;gdb-cmd. In this example GDB server command line contains arguments and path to executable has space so whole command line is put in quotes and quotes required by Windows path are additionally escaped. </p><pre class="fragment">cli_programmer -b c:\users\jon\sdk\bsp\system\loaders\uartboot\Release\uartboot.bin --save-ini --gdb-cmd "\"C:\Program Files\SEGGER\JLink_V510d\JLinkGDBServerCL.exe\" -if SWD -device Cortex-M0 -singlerun -silent -speed auto"
</pre><p>Program a DA14681-01 chip with an executable flash image. </p><pre class="fragment">cli_programmer --prod-id DA14681-01 gdbserver write_qspi_exec ../../../../projects/dk_apps/demos/ble_adv/DA14681-01-Debug_QSPI/ble_adv.bin
</pre><p>Write OTP address 0x07f80128 with the following contents: B0:0x00, B1:0x01, B2:0x02, B3:0x03, B4:0x04, B5:0x05, B6:0x06, B7:0x07 </p><pre class="fragment"> cli_programmer gdbserver write_otp 0x07f80128 2 0x03020100 0x07060504
</pre><p>Read OTP address 0x07f80128. </p><pre class="fragment"> cli_programmer gdbserver read_otp 0x07f80128 2

 If written with the contents from above write example, it should return
 0025   00 01 02 03 04 05 06 07   ........
</pre><h2>Building cli_programmer</h2>
<ul>
<li>'cli_programmer' makes use of the 'libprogrammer' library which implements the underlying functionality on the host side. 'cli_programmer' can be linked either statically or dynamically with 'libprogrammer'.</li>
<li>'cli_programmer' uses 'uartboot' application which acts as a secondary bootloader which cli_programmer downloads to the target for performing the read/write operations.</li>
<li>The project is located in the <code>utilities/cli_programmer/cli</code> folder</li>
<li>Build configurations:<ul>
<li>Debug_dynamic_linux - Debug version for Linux linking dynamically to libprogrammer</li>
<li>Debug_static_linux - Debug version linked with a static version of libprogrammer - recommended for Linux. It also builds uartboot project and includes it in cli_programmer executable</li>
<li>Debug_static_win32 - Debug version for Windows linked with a static version of libprogrammer</li>
<li>Debug_dynamic_win32 - Debug version for Windows linking dynamically to libprogrammer</li>
<li>Release_dynamic_linux - Release version for Linux linking dynamically to libprogrammer</li>
<li>Release_static - Release version linked with a static version of libprogrammer - recommended for Linux. It also builds uartboot project and includes it in cli_programmer executable</li>
<li>Release_static_win32 - Release version for Windows linked with a static version of libprogrammer</li>
<li>Release_dynamic_win32 - Release version for Windows linking dynamically to libprogrammer</li>
</ul>
</li>
<li>Build instructions<ul>
<li>Import <code>libprogrammer</code>, <code>cli_programmer</code> and <code>uartboot</code> into Eclipse</li>
<li>Build <code>libprogrammer</code> , <code>cli_programmer</code> and <code>uartboot</code> in <code>Release_static</code> configuration (recommended)</li>
<li>Run <code>cli_programmer</code> with proper parameters, described in <code>Usage</code> and <code>Commands and arguments</code> sections</li>
</ul>
</li>
</ul>
<blockquote class="doxtable">
<p>Notes:</p><ul>
<li>A prebuilt version of cli_programmer can be found under SDK's <code>binaries</code> folder</li>
<li>Building cli_programmer updates SDK's <code>binaries</code> folder (the new binaries are copied there)</li>
<li>Linux <code>cli_programmer</code> binaries built using dynamic build configurations search for the library file <code>libprogrammer.so</code> explicitely in the <code>binaries</code> folder</li>
</ul>
</blockquote>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:05 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
