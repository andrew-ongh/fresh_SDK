<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: MEMORY</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MEMORY<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___s_y_s_t_e_m.html">SYSTEM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>QSPI flash driver framework.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:qspi__automode_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__automode_8h.html">qspi_automode.h</a></td></tr>
<tr class="memdesc:qspi__automode_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access QSPI flash when running in auto mode. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__common_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__common_8h.html">qspi_common.h</a></td></tr>
<tr class="memdesc:qspi__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver common definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__gd25lq80b_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__gd25lq80b_8h.html">qspi_gd25lq80b.h</a></td></tr>
<tr class="memdesc:qspi__gd25lq80b_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for the GigaDevice GD25LQ80B. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__gigadevice_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__gigadevice_8h.html">qspi_gigadevice.h</a></td></tr>
<tr class="memdesc:qspi__gigadevice_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Gigadevice flashes - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__macronix_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__macronix_8h.html">qspi_macronix.h</a></td></tr>
<tr class="memdesc:qspi__macronix_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Macronix flashes - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__mx25u51245_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__mx25u51245_8h.html">qspi_mx25u51245.h</a></td></tr>
<tr class="memdesc:qspi__mx25u51245_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for the Macronix MX25U51245. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__w25q80ew_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__w25q80ew_8h.html">qspi_w25q80ew.h</a></td></tr>
<tr class="memdesc:qspi__w25q80ew_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for the Winbond W25Q80EW. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi__winbond_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi__winbond_8h.html">qspi_winbond.h</a></td></tr>
<tr class="memdesc:qspi__winbond_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI flash driver for Winbond flashes - common code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qspi___x_x_x__template_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qspi___x_x_x__template_8h.html">qspi_XXX_template.h</a></td></tr>
<tr class="memdesc:qspi___x_x_x__template_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver for flash XXXX. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structqspi__flash__config.html">qspi_flash_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI Flash configuration structure.  <a href="structqspi__flash__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf8cf118323b91b1be085f266a2267c1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8cf118323b91b1be085f266a2267c1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#gaf8cf118323b91b1be085f266a2267c1e">FLASH_SUS_DELAY</a>&#160;&#160;&#160;(20)</td></tr>
<tr class="memdesc:gaf8cf118323b91b1be085f266a2267c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SUS bit delay after SUSPEND command (in Î¼sec) <br /></td></tr>
<tr class="separator:gaf8cf118323b91b1be085f266a2267c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga230871cbef94a3328fdcda1f87dd2bde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga230871cbef94a3328fdcda1f87dd2bde">XXXXX_ID</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga230871cbef94a3328fdcda1f87dd2bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash vendor JEDEC ID.  <a href="#ga230871cbef94a3328fdcda1f87dd2bde">More...</a><br /></td></tr>
<tr class="separator:ga230871cbef94a3328fdcda1f87dd2bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e4a1a837d547365760bd32ebc664e84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga8e4a1a837d547365760bd32ebc664e84">XXXXX</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga8e4a1a837d547365760bd32ebc664e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash type JEDEC ID.  <a href="#ga8e4a1a837d547365760bd32ebc664e84">More...</a><br /></td></tr>
<tr class="separator:ga8e4a1a837d547365760bd32ebc664e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f22a9fb53cdeabb03c8b173b93822ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga6f22a9fb53cdeabb03c8b173b93822ab">XXXXX_SIZE</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga6f22a9fb53cdeabb03c8b173b93822ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Flash density JEDEC ID.  <a href="#ga6f22a9fb53cdeabb03c8b173b93822ab">More...</a><br /></td></tr>
<tr class="separator:ga6f22a9fb53cdeabb03c8b173b93822ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaaca7b42888b10ca3e05786453609d0d3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structqspi__flash__config.html">qspi_flash_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a></td></tr>
<tr class="memdesc:gaaca7b42888b10ca3e05786453609d0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI Flash configuration structure.  <a href="#gaaca7b42888b10ca3e05786453609d0d3">More...</a><br /></td></tr>
<tr class="separator:gaaca7b42888b10ca3e05786453609d0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga794de9e9ab8b395a0126205180619345"><td class="memItemLeft" align="right" valign="top">DEPRECATED uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga794de9e9ab8b395a0126205180619345">qspi_automode_get_code_buffer_size</a> (void)</td></tr>
<tr class="memdesc:ga794de9e9ab8b395a0126205180619345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of RAM buffer needed for code to modify QSPI flash.  <a href="#ga794de9e9ab8b395a0126205180619345">More...</a><br /></td></tr>
<tr class="separator:ga794de9e9ab8b395a0126205180619345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18753e2453fc13a9e6c6f7ef3403e987"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga18753e2453fc13a9e6c6f7ef3403e987">qspi_automode_set_code_buffer</a> (void *ram)</td></tr>
<tr class="memdesc:ga18753e2453fc13a9e6c6f7ef3403e987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer that will be used for code that modifies flash.  <a href="#ga18753e2453fc13a9e6c6f7ef3403e987">More...</a><br /></td></tr>
<tr class="separator:ga18753e2453fc13a9e6c6f7ef3403e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b03b4f5f1a5f150d2a246f707a7255"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#gad7b03b4f5f1a5f150d2a246f707a7255">qspi_automode_write_flash_page</a> (uint32_t addr, const uint8_t *buf, size_t size)</td></tr>
<tr class="memdesc:gad7b03b4f5f1a5f150d2a246f707a7255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write flash memory.  <a href="#gad7b03b4f5f1a5f150d2a246f707a7255">More...</a><br /></td></tr>
<tr class="separator:gad7b03b4f5f1a5f150d2a246f707a7255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd4cecdf5349007b99b3e17e4306f36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#gafcd4cecdf5349007b99b3e17e4306f36">qspi_automode_erase_flash_sector</a> (uint32_t addr)</td></tr>
<tr class="memdesc:gafcd4cecdf5349007b99b3e17e4306f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase flash sector.  <a href="#gafcd4cecdf5349007b99b3e17e4306f36">More...</a><br /></td></tr>
<tr class="separator:gafcd4cecdf5349007b99b3e17e4306f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9defebf9434bef90daeb8bd682c9e0de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9defebf9434bef90daeb8bd682c9e0de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga9defebf9434bef90daeb8bd682c9e0de">qspi_automode_erase_chip</a> (void)</td></tr>
<tr class="memdesc:ga9defebf9434bef90daeb8bd682c9e0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase whole chip. <br /></td></tr>
<tr class="separator:ga9defebf9434bef90daeb8bd682c9e0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81ef72beb9d06ff0a1b6b4ecfb13311e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga81ef72beb9d06ff0a1b6b4ecfb13311e">qspi_automode_read</a> (uint32_t addr, uint8_t *buf, size_t len)</td></tr>
<tr class="memdesc:ga81ef72beb9d06ff0a1b6b4ecfb13311e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read flash memory.  <a href="#ga81ef72beb9d06ff0a1b6b4ecfb13311e">More...</a><br /></td></tr>
<tr class="separator:ga81ef72beb9d06ff0a1b6b4ecfb13311e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143a2376c51ff1d6c6628a22d904ab14"><td class="memItemLeft" align="right" valign="top">static const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga143a2376c51ff1d6c6628a22d904ab14">qspi_automode_addr</a> (uint32_t addr) <a class="el" href="struct____attribute____.html">__attribute__</a>((always_inline))</td></tr>
<tr class="memdesc:ga143a2376c51ff1d6c6628a22d904ab14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of flash.  <a href="#ga143a2376c51ff1d6c6628a22d904ab14">More...</a><br /></td></tr>
<tr class="separator:ga143a2376c51ff1d6c6628a22d904ab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495dbcef4585cf6f54afca7604f62714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga495dbcef4585cf6f54afca7604f62714"></a>
<a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga495dbcef4585cf6f54afca7604f62714">qspi_automode_flash_power_up</a> (void)</td></tr>
<tr class="memdesc:ga495dbcef4585cf6f54afca7604f62714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power up flash. <br /></td></tr>
<tr class="separator:ga495dbcef4585cf6f54afca7604f62714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d2b2e94eb5fe018bb212a76ddaee5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6d2b2e94eb5fe018bb212a76ddaee5d"></a>
<a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#gad6d2b2e94eb5fe018bb212a76ddaee5d">qspi_automode_flash_power_down</a> (void)</td></tr>
<tr class="memdesc:gad6d2b2e94eb5fe018bb212a76ddaee5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set QSPI Flash into power down mode. <br /></td></tr>
<tr class="separator:gad6d2b2e94eb5fe018bb212a76ddaee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae257d1ee1830c6eef0ee9914f5c77fa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae257d1ee1830c6eef0ee9914f5c77fa6"></a>
<a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#gae257d1ee1830c6eef0ee9914f5c77fa6">qspi_automode_init</a> (void)</td></tr>
<tr class="memdesc:gae257d1ee1830c6eef0ee9914f5c77fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init QSPI controller. <br /></td></tr>
<tr class="separator:gae257d1ee1830c6eef0ee9914f5c77fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1bcea40bc4f625c748039ff7589350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#gafe1bcea40bc4f625c748039ff7589350">qspi_check_program_erase_in_progress</a> (void)</td></tr>
<tr class="memdesc:gafe1bcea40bc4f625c748039ff7589350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a program or sector erase operation is in progress.  <a href="#gafe1bcea40bc4f625c748039ff7589350">More...</a><br /></td></tr>
<tr class="separator:gafe1bcea40bc4f625c748039ff7589350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga992ba10562ac726e8bde4d04915ef085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga992ba10562ac726e8bde4d04915ef085">qspi_check_and_suspend</a> (void)</td></tr>
<tr class="memdesc:ga992ba10562ac726e8bde4d04915ef085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a Flash program or erase operation.  <a href="#ga992ba10562ac726e8bde4d04915ef085">More...</a><br /></td></tr>
<tr class="separator:ga992ba10562ac726e8bde4d04915ef085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga430db73748cd4a26e509efaa8edeab25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga430db73748cd4a26e509efaa8edeab25">qspi_resume</a> (void)</td></tr>
<tr class="memdesc:ga430db73748cd4a26e509efaa8edeab25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a Flash program or sector erase operation.  <a href="#ga430db73748cd4a26e509efaa8edeab25">More...</a><br /></td></tr>
<tr class="separator:ga430db73748cd4a26e509efaa8edeab25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a2cc464c5ddb81b4307df949e8e79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga98a2cc464c5ddb81b4307df949e8e79b">flash_erase_sector_manual_mode</a> (uint32_t addr)</td></tr>
<tr class="memdesc:ga98a2cc464c5ddb81b4307df949e8e79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a sector of the Flash in manual mode.  <a href="#ga98a2cc464c5ddb81b4307df949e8e79b">More...</a><br /></td></tr>
<tr class="separator:ga98a2cc464c5ddb81b4307df949e8e79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56285a9439ceb53bc1eac38408399b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga56285a9439ceb53bc1eac38408399b5b">flash_program_page_manual_mode</a> (uint32_t addr, const uint8_t *buf, uint16_t len)</td></tr>
<tr class="memdesc:ga56285a9439ceb53bc1eac38408399b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program data into a page of the Flash in manual mode.  <a href="#ga56285a9439ceb53bc1eac38408399b5b">More...</a><br /></td></tr>
<tr class="separator:ga56285a9439ceb53bc1eac38408399b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cbb8fa84e245aba7dcf72f1ddaf540f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga6cbb8fa84e245aba7dcf72f1ddaf540f">flash_activate_command_entry_mode</a> (void)</td></tr>
<tr class="memdesc:ga6cbb8fa84e245aba7dcf72f1ddaf540f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate Flash command entry mode.  <a href="#ga6cbb8fa84e245aba7dcf72f1ddaf540f">More...</a><br /></td></tr>
<tr class="separator:ga6cbb8fa84e245aba7dcf72f1ddaf540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9731d2ce7094cbb92b62832006d270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#gafd9731d2ce7094cbb92b62832006d270">flash_deactivate_command_entry_mode</a> (void)</td></tr>
<tr class="memdesc:gafd9731d2ce7094cbb92b62832006d270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate Flash command entry mode.  <a href="#gafd9731d2ce7094cbb92b62832006d270">More...</a><br /></td></tr>
<tr class="separator:gafd9731d2ce7094cbb92b62832006d270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd4f0b2853539e49bb3f3d6004c52b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#ga0fd4f0b2853539e49bb3f3d6004c52b6">qspi_automode_sys_clock_cfg</a> (<a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a> sys_clk)</td></tr>
<tr class="memdesc:ga0fd4f0b2853539e49bb3f3d6004c52b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Flash and QSPI controller for system clock frequency.  <a href="#ga0fd4f0b2853539e49bb3f3d6004c52b6">More...</a><br /></td></tr>
<tr class="separator:ga0fd4f0b2853539e49bb3f3d6004c52b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf5ab3f1c42b1b0208cb2eaabd0fd5c"><td class="memItemLeft" align="right" valign="top">const qspi_ucode_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_e_m_o_r_y.html#gadcf5ab3f1c42b1b0208cb2eaabd0fd5c">qspi_automode_get_ucode</a> (void)</td></tr>
<tr class="memdesc:gadcf5ab3f1c42b1b0208cb2eaabd0fd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ucode required for wake-up sequence.  <a href="#gadcf5ab3f1c42b1b0208cb2eaabd0fd5c">More...</a><br /></td></tr>
<tr class="separator:gadcf5ab3f1c42b1b0208cb2eaabd0fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>QSPI flash driver framework. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga8e4a1a837d547365760bd32ebc664e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXXXX&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash type JEDEC ID. </p>
<p>This is the second byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="ga230871cbef94a3328fdcda1f87dd2bde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXXXX_ID&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash vendor JEDEC ID. </p>
<p>This is the first byte returned by the 0x9F command </p>

</div>
</div>
<a class="anchor" id="ga6f22a9fb53cdeabb03c8b173b93822ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XXXXX_SIZE&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Flash density JEDEC ID. </p>
<p>This is the third byte returned by the 0x9F command </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaaca7b42888b10ca3e05786453609d0d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structqspi__flash__config.html">qspi_flash_config</a>  <a class="el" href="group___m_e_m_o_r_y.html#gaaca7b42888b10ca3e05786453609d0d3">qspi_flash_config_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QSPI Flash configuration structure. </p>
<p>This struct is used to define a driver for a specific QSPI flash.</p>
<dl class="section note"><dt>Note</dt><dd>The struct instance must be declared as static const for this to work </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6cbb8fa84e245aba7dcf72f1ddaf540f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_activate_command_entry_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate Flash command entry mode. </p>
<dl class="section note"><dt>Note</dt><dd>After the call to this function, the QSPI controller is set to manual mode and the Flash access to single mode.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="gafd9731d2ce7094cbb92b62832006d270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_deactivate_command_entry_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate Flash command entry mode. </p>
<dl class="section note"><dt>Note</dt><dd>After the call to this function, the QSPI controller is set to auto mode and the Flash access to quad mode (if QUAD_MODE is 1).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98a2cc464c5ddb81b4307df949e8e79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void flash_erase_sector_manual_mode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a sector of the Flash in manual mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address of the sector to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not block until the Flash has processed the command! The QSPI controller is left to manual mode after the call to this function. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56285a9439ceb53bc1eac38408399b5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> size_t flash_program_page_manual_mode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program data into a page of the Flash in manual mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address of the Flash where the data will be written. It may be anywhere in a page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to the beginning of the buffer that contains the data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes written.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The boundary of the page where addr belongs to, will not be crossed! The caller should issue another <a class="el" href="group___m_e_m_o_r_y.html#ga56285a9439ceb53bc1eac38408399b5b" title="Program data into a page of the Flash in manual mode. ">flash_program_page_manual_mode()</a> call in order to write the remaining data to the next page. The QSPI controller is left to manual mode after the call to this function. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga143a2376c51ff1d6c6628a22d904ab14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const void * qspi_automode_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get address of flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address in CPU address space where data is located </dd></dl>

</div>
</div>
<a class="anchor" id="gafcd4cecdf5349007b99b3e17e4306f36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qspi_automode_erase_flash_sector </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase flash sector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset of sector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga794de9e9ab8b395a0126205180619345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DEPRECATED uint32_t qspi_automode_get_code_buffer_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of RAM buffer needed for code to modify QSPI flash. </p>
<p>Called must allocate buffer at least of this size and pass it qspi_set_code_buffer() to allow flash modification.</p>
<dl class="section return"><dt>Returns</dt><dd>size of buffer needed </dd></dl>

</div>
</div>
<a class="anchor" id="gadcf5ab3f1c42b1b0208cb2eaabd0fd5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const qspi_ucode_t* qspi_automode_get_ucode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ucode required for wake-up sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>qspi_ucode_t Pointer to the structure containing the ucode and ucode size </dd></dl>

</div>
</div>
<a class="anchor" id="ga81ef72beb9d06ff0a1b6b4ecfb13311e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qspi_automode_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read flash memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>starting offset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to read data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read </dd></dl>

</div>
</div>
<a class="anchor" id="ga18753e2453fc13a9e6c6f7ef3403e987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qspi_automode_set_code_buffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set buffer that will be used for code that modifies flash. </p>
<p>This function should be called with buffer allocated for flash manipulation code. Size of this buffer should be at least the value returned from qspi_get_code_buffer_size(). If function is called with NULL all further calls to qspi_write_flash_page() or qspi_erase_flash_sector() will crash. To preserve memory it is quite wise to allocate buffer before erase/write, update flash and then call this function with NULL and free memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ram</td><td>buffer for code that will be used for erase and write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0fd4f0b2853539e49bb3f3d6004c52b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void qspi_automode_sys_clock_cfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_p_m.html#ga42297fa8f8149da6ac66c67b57a3704e">sys_clk_t</a>&#160;</td>
          <td class="paramname"><em>sys_clk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Flash and QSPI controller for system clock frequency. </p>
<p>This function is used to change the Flash configuration of the QSPI controller to work with the system clock frequency defined in sys_clk. Dummy clock cycles could be changed here to support higher clock frequencies. QSPI controller clock divider could also be changed if the Flash maximum frequency is smaller than the system clock frequency. This function must be called before changing system clock frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sys_clk</td><td>System clock frequency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad7b03b4f5f1a5f150d2a246f707a7255"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qspi_automode_write_flash_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write flash memory. </p>
<p>This function allows to write up to page size of data to flash. If size is greater than page size, flash can wrap data and overwrite content of page. It's possible to write less then page size. Memory should be erased before.</p>
<dl class="section note"><dt>Note</dt><dd>: Do not pass buf pointing to QSPI mapped memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>offset in flash to write data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to data to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<p>return number of bytes written </p>

</div>
</div>
<a class="anchor" id="ga992ba10562ac726e8bde4d04915ef085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_check_and_suspend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend a Flash program or erase operation. </p>
<p>This function will try to suspend an ongoing program or erase procedure. The SUS bit is checked and the actual status is returned to the caller. Note that the program or erase procedure may have been completed before the suspend command is processed by the Flash. In this case the SUS bit will be left to 0.</p>
<dl class="section return"><dt>Returns</dt><dd>bool True if the procedure has been suspended. False if the procedure was not suspended successfully or had finished before the suspend command was processed by the Flash.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>After the call to this function, the QSPI controller is set to auto mode and the Flash access to quad mode (if QUAD_MODE is 1). The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe1bcea40bc4f625c748039ff7589350"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> bool qspi_check_program_erase_in_progress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a program or sector erase operation is in progress. </p>
<dl class="section return"><dt>Returns</dt><dd>bool True if the BUSY bit is set else false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function checks the value of the BUSY bit in the Status Register 1 of the Flash. It is the responsibility of the caller to call the function in the right context. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
<a class="anchor" id="ga430db73748cd4a26e509efaa8edeab25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___p_l_a_t_f_o_r_m.html#gac1d009c7974fe02aff2c09b7588bf7de">__RETAINED_CODE</a> void qspi_resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a Flash program or sector erase operation. </p>
<dl class="section warning"><dt>Warning</dt><dd>After the call to this function, the QSPI controller is set to manual mode and the Flash access to single mode. The function must be called with interrupts disabled. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:06 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
