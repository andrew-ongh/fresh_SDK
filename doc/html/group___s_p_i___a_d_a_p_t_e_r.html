<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: SPI_ADAPTER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SPI_ADAPTER<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___a_d_a_p_t_e_r_s.html">ADAPTERS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>SPI adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__spi_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__spi_8h.html">ad_spi.h</a></td></tr>
<tr class="memdesc:ad__spi_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI adapter API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__transfer__data.html">spi_transfer_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer structure for complex SPI transaction.  <a href="structspi__transfer__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__bus__dynamic__data.html">spi_bus_dynamic_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI data run time data.  <a href="structspi__bus__dynamic__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__dev__dynamic__data.html">spi_dev_dynamic_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI device data run time data.  <a href="structspi__dev__dynamic__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__device__config.html">spi_device_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI device constant data.  <a href="structspi__device__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga58dd1393569b63315582f974b31abe22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga58dd1393569b63315582f974b31abe22">CONFIG_SPI_ONE_DEVICE_ON_BUS</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga58dd1393569b63315582f974b31abe22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to configure only one device on the SPI bus.  <a href="#ga58dd1393569b63315582f974b31abe22">More...</a><br /></td></tr>
<tr class="separator:ga58dd1393569b63315582f974b31abe22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4edb64ea31eb326a8283fe3d64f48b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa4edb64ea31eb326a8283fe3d64f48b7">CONFIG_SPI_EXCLUSIVE_OPEN</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaa4edb64ea31eb326a8283fe3d64f48b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to configure exclusive use of devices.  <a href="#gaa4edb64ea31eb326a8283fe3d64f48b7">More...</a><br /></td></tr>
<tr class="separator:gaa4edb64ea31eb326a8283fe3d64f48b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bf263f47eae6a5f431bd4b6c9642bb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7bf263f47eae6a5f431bd4b6c9642bb1">CONFIG_SPI_RESOURCE_STATIC_ID</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga7bf263f47eae6a5f431bd4b6c9642bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to configure resource ID assignment for each device.  <a href="#ga7bf263f47eae6a5f431bd4b6c9642bb1">More...</a><br /></td></tr>
<tr class="separator:ga7bf263f47eae6a5f431bd4b6c9642bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7f6d6e9d54be9ef930804210594f5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga5d7f6d6e9d54be9ef930804210594f5b">CONFIG_SPI_USE_RESMGMT</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga5d7f6d6e9d54be9ef930804210594f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether SPI resource acquisition will be used.  <a href="#ga5d7f6d6e9d54be9ef930804210594f5b">More...</a><br /></td></tr>
<tr class="separator:ga5d7f6d6e9d54be9ef930804210594f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eb20e1ef0c0dd977f19c85868a32c4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7eb20e1ef0c0dd977f19c85868a32c4a">CONFIG_SPI_USE_DMA_RESMGMT</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga7eb20e1ef0c0dd977f19c85868a32c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether DMA resource acquisition will be used by the SPI adapter.  <a href="#ga7eb20e1ef0c0dd977f19c85868a32c4a">More...</a><br /></td></tr>
<tr class="separator:ga7eb20e1ef0c0dd977f19c85868a32c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d27ad5bdb4d305d0967f9172566b8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga66d27ad5bdb4d305d0967f9172566b8a">CONFIG_SPI_USE_ASYNC_TRANSACTIONS</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga66d27ad5bdb4d305d0967f9172566b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether SPI asynchronous transaction API will be used.  <a href="#ga66d27ad5bdb4d305d0967f9172566b8a">More...</a><br /></td></tr>
<tr class="separator:ga66d27ad5bdb4d305d0967f9172566b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8fbe8efe0995df3a2eaedf995044d6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa8fbe8efe0995df3a2eaedf995044d6d">SPI_SLAVE_DEVICE</a>(bus_id,  name,  cs_port,  cs_pin,  word_mode,  pol_mode,  phase_mode,  xtal_div,  dma_channel)&#160;&#160;&#160;extern const void *const name;</td></tr>
<tr class="memdesc:gaa8fbe8efe0995df3a2eaedf995044d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry for slave device.  <a href="#gaa8fbe8efe0995df3a2eaedf995044d6d">More...</a><br /></td></tr>
<tr class="separator:gaa8fbe8efe0995df3a2eaedf995044d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922d30d48a654cf204be626d48276cc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga922d30d48a654cf204be626d48276cc4">SPI_SLAVE_TO_EXT_MASTER</a>(bus_id,  name,  ignore_cs,  word_mode,  pol_mode,  phase_mode,  dma_channel)&#160;&#160;&#160;extern const void *const name;</td></tr>
<tr class="memdesc:ga922d30d48a654cf204be626d48276cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry for parameters when SPI is in slave mode.  <a href="#ga922d30d48a654cf204be626d48276cc4">More...</a><br /></td></tr>
<tr class="separator:ga922d30d48a654cf204be626d48276cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a0f4cb4d47cfae401084680fb4fcbe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga50a0f4cb4d47cfae401084680fb4fcbe">SPI_BUS</a>(bus_id)&#160;&#160;&#160;extern <a class="el" href="structspi__bus__dynamic__data.html">spi_bus_dynamic_data</a> dynamic_##bus_id;</td></tr>
<tr class="memdesc:ga50a0f4cb4d47cfae401084680fb4fcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting entry for SPI bus devices.  <a href="#ga50a0f4cb4d47cfae401084680fb4fcbe">More...</a><br /></td></tr>
<tr class="separator:ga50a0f4cb4d47cfae401084680fb4fcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad45c809f610a7a6b90659ce14f7a4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8ad45c809f610a7a6b90659ce14f7a4a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga8ad45c809f610a7a6b90659ce14f7a4a">SPI_BUS_END</a></td></tr>
<tr class="memdesc:ga8ad45c809f610a7a6b90659ce14f7a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ends SPI bus device list started with <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga50a0f4cb4d47cfae401084680fb4fcbe" title="Starting entry for SPI bus devices. ">SPI_BUS()</a> <br /></td></tr>
<tr class="separator:ga8ad45c809f610a7a6b90659ce14f7a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d6e83837e5eed401bce0b45a8d04c9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga6d6e83837e5eed401bce0b45a8d04c9f">SPI_BUS_INIT</a>(bus_id)&#160;&#160;&#160;<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga11dd02f927abfd0010ae5caa7b5638e1">ad_spi_bus_init</a>(&amp;dynamic_##bus_id)</td></tr>
<tr class="memdesc:ga6d6e83837e5eed401bce0b45a8d04c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of SPI bus variables.  <a href="#ga6d6e83837e5eed401bce0b45a8d04c9f">More...</a><br /></td></tr>
<tr class="separator:ga6d6e83837e5eed401bce0b45a8d04c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1570361a6b7dc66e732bb0c72bb812c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa1570361a6b7dc66e732bb0c72bb812c">SPI_DEVICE_INIT</a>(name)&#160;&#160;&#160;<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga9b025eea709195fd77a644dbf8c42154">ad_spi_device_init</a>(name)</td></tr>
<tr class="memdesc:gaa1570361a6b7dc66e732bb0c72bb812c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of SPI bus devices.  <a href="#gaa1570361a6b7dc66e732bb0c72bb812c">More...</a><br /></td></tr>
<tr class="separator:gaa1570361a6b7dc66e732bb0c72bb812c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef744aa93dc36d1ed06fa3efba2df9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7ef744aa93dc36d1ed06fa3efba2df9e">SPI_CSA</a>&#160;&#160;&#160;(uint32_t) SPI_TAG_CS_ACTIVATE</td></tr>
<tr class="separator:ga7ef744aa93dc36d1ed06fa3efba2df9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6451beaba214cef8ee9bda5dddce1b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gae6451beaba214cef8ee9bda5dddce1b2">ad_spi_async_write</a>(dev,  buf,  len,  cb,  ud)&#160;&#160;&#160;<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga094bf04ad3839c4a8b236e7f7673b25c">ad_spi_async_transact</a>(dev, <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7ef744aa93dc36d1ed06fa3efba2df9e">SPI_CSA</a>, SPI_SND(buf, len), SPI_CSD, SPI_CB1(cb, ud), SPI_END)</td></tr>
<tr class="memdesc:gae6451beaba214cef8ee9bda5dddce1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous write SPI transaction.  <a href="#gae6451beaba214cef8ee9bda5dddce1b2">More...</a><br /></td></tr>
<tr class="separator:gae6451beaba214cef8ee9bda5dddce1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a5c589751b638a727c8bf8f00f57aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga98a5c589751b638a727c8bf8f00f57aa">ad_spi_async_write_read</a>(dev,  wbuf,  wlen,  rbuf,  rlen,  cb,  ud)</td></tr>
<tr class="memdesc:ga98a5c589751b638a727c8bf8f00f57aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous write then read SPI transaction.  <a href="#ga98a5c589751b638a727c8bf8f00f57aa">More...</a><br /></td></tr>
<tr class="separator:ga98a5c589751b638a727c8bf8f00f57aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga319721e2f4ba8a5ba2c4b1149889d5a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga319721e2f4ba8a5ba2c4b1149889d5a1"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a></td></tr>
<tr class="memdesc:ga319721e2f4ba8a5ba2c4b1149889d5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device pointer, handle to use with <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga98ceafa3bc609ef9c1739f87be4c970b" title="Perform read only transaction. ">ad_spi_read()</a>, <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gad63e9ef311c855a818e9958d1d8196cb" title="Perform write only transaction. ">ad_spi_write()</a> etc. <br /></td></tr>
<tr class="separator:ga319721e2f4ba8a5ba2c4b1149889d5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12aff349582ab73813755817bcbcf6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae12aff349582ab73813755817bcbcf6d"></a>
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gae12aff349582ab73813755817bcbcf6d">spi_device_id</a></td></tr>
<tr class="memdesc:gae12aff349582ab73813755817bcbcf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device id, those are created by SPI_SLAVE_DEVICE or SPI_SLAVE_TO_EXT_MASTER macro in <a class="el" href="platform__devices_8h.html" title="Configuration of devices connected to board. ">platform_devices.h</a>. <br /></td></tr>
<tr class="separator:gae12aff349582ab73813755817bcbcf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7aa97913b264581d97dc45b350bc027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae7aa97913b264581d97dc45b350bc027"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gae7aa97913b264581d97dc45b350bc027">ad_spi_user_cb</a>) (void *user_data)</td></tr>
<tr class="memdesc:gae7aa97913b264581d97dc45b350bc027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous callback function. <br /></td></tr>
<tr class="separator:gae7aa97913b264581d97dc45b350bc027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace30ed166db32f6c79095581a44bc724"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structspi__device__config.html">spi_device_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gace30ed166db32f6c79095581a44bc724">spi_device_config</a></td></tr>
<tr class="memdesc:gace30ed166db32f6c79095581a44bc724"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI device constant data.  <a href="#gace30ed166db32f6c79095581a44bc724">More...</a><br /></td></tr>
<tr class="separator:gace30ed166db32f6c79095581a44bc724"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7c1b395ea7ac0145fbe72ead8c5e0643"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7c1b395ea7ac0145fbe72ead8c5e0643"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7c1b395ea7ac0145fbe72ead8c5e0643">ad_spi_init</a> (void)</td></tr>
<tr class="memdesc:ga7c1b395ea7ac0145fbe72ead8c5e0643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize adapter. <br /></td></tr>
<tr class="separator:ga7c1b395ea7ac0145fbe72ead8c5e0643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11dd02f927abfd0010ae5caa7b5638e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga11dd02f927abfd0010ae5caa7b5638e1">ad_spi_bus_init</a> (void *bus_data)</td></tr>
<tr class="memdesc:ga11dd02f927abfd0010ae5caa7b5638e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize bus variables.  <a href="#ga11dd02f927abfd0010ae5caa7b5638e1">More...</a><br /></td></tr>
<tr class="separator:ga11dd02f927abfd0010ae5caa7b5638e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b025eea709195fd77a644dbf8c42154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga9b025eea709195fd77a644dbf8c42154">ad_spi_device_init</a> (const <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gae12aff349582ab73813755817bcbcf6d">spi_device_id</a> id)</td></tr>
<tr class="memdesc:ga9b025eea709195fd77a644dbf8c42154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize device variables.  <a href="#ga9b025eea709195fd77a644dbf8c42154">More...</a><br /></td></tr>
<tr class="separator:ga9b025eea709195fd77a644dbf8c42154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a57010db50760061d4d70bfee84f900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7a57010db50760061d4d70bfee84f900">ad_spi_open</a> (const <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gae12aff349582ab73813755817bcbcf6d">spi_device_id</a> dev_id)</td></tr>
<tr class="memdesc:ga7a57010db50760061d4d70bfee84f900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open device connected to SPI bus.  <a href="#ga7a57010db50760061d4d70bfee84f900">More...</a><br /></td></tr>
<tr class="separator:ga7a57010db50760061d4d70bfee84f900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6238a703c170275bb2aee58eb19e1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga1b6238a703c170275bb2aee58eb19e1f">ad_spi_transact</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev, const uint8_t *wbuf, size_t wlen, uint8_t *rbuf, size_t rlen)</td></tr>
<tr class="memdesc:ga1b6238a703c170275bb2aee58eb19e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform typical SPI transaction.  <a href="#ga1b6238a703c170275bb2aee58eb19e1f">More...</a><br /></td></tr>
<tr class="separator:ga1b6238a703c170275bb2aee58eb19e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad63e9ef311c855a818e9958d1d8196cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gad63e9ef311c855a818e9958d1d8196cb">ad_spi_write</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev, const uint8_t *wbuf, size_t wlen)</td></tr>
<tr class="memdesc:gad63e9ef311c855a818e9958d1d8196cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform write only transaction.  <a href="#gad63e9ef311c855a818e9958d1d8196cb">More...</a><br /></td></tr>
<tr class="separator:gad63e9ef311c855a818e9958d1d8196cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ceafa3bc609ef9c1739f87be4c970b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga98ceafa3bc609ef9c1739f87be4c970b">ad_spi_read</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev, uint8_t *rbuf, size_t rlen)</td></tr>
<tr class="memdesc:ga98ceafa3bc609ef9c1739f87be4c970b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read only transaction.  <a href="#ga98ceafa3bc609ef9c1739f87be4c970b">More...</a><br /></td></tr>
<tr class="separator:ga98ceafa3bc609ef9c1739f87be4c970b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1031945079b5a0d955f9e3d6914a08ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga1031945079b5a0d955f9e3d6914a08ce">ad_spi_complex_transact</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev, <a class="el" href="structspi__transfer__data.html">spi_transfer_data</a> *transfers, size_t count)</td></tr>
<tr class="memdesc:ga1031945079b5a0d955f9e3d6914a08ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform complex transaction.  <a href="#ga1031945079b5a0d955f9e3d6914a08ce">More...</a><br /></td></tr>
<tr class="separator:ga1031945079b5a0d955f9e3d6914a08ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1614f71139e561c8cac61168c48ec64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaf1614f71139e561c8cac61168c48ec64">ad_spi_bus_activate_cs</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev)</td></tr>
<tr class="memdesc:gaf1614f71139e561c8cac61168c48ec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate chip select for a specific device.  <a href="#gaf1614f71139e561c8cac61168c48ec64">More...</a><br /></td></tr>
<tr class="separator:gaf1614f71139e561c8cac61168c48ec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6a2a344ae7e38824d8cd5ae312a9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaba6a2a344ae7e38824d8cd5ae312a9b1">ad_spi_bus_deactivate_cs</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev)</td></tr>
<tr class="memdesc:gaba6a2a344ae7e38824d8cd5ae312a9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivate chip select for a specific device.  <a href="#gaba6a2a344ae7e38824d8cd5ae312a9b1">More...</a><br /></td></tr>
<tr class="separator:gaba6a2a344ae7e38824d8cd5ae312a9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ff238ada37b8aa3ca3aba796ad64d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga65ff238ada37b8aa3ca3aba796ad64d4">ad_spi_bus_acquire</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev)</td></tr>
<tr class="memdesc:ga65ff238ada37b8aa3ca3aba796ad64d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire access to SPI bus.  <a href="#ga65ff238ada37b8aa3ca3aba796ad64d4">More...</a><br /></td></tr>
<tr class="separator:ga65ff238ada37b8aa3ca3aba796ad64d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423d8d6c5ea7f380bad847192cace041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga423d8d6c5ea7f380bad847192cace041">ad_spi_bus_release</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev)</td></tr>
<tr class="memdesc:ga423d8d6c5ea7f380bad847192cace041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release access to SPI bus.  <a href="#ga423d8d6c5ea7f380bad847192cace041">More...</a><br /></td></tr>
<tr class="separator:ga423d8d6c5ea7f380bad847192cace041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904aa3c3fdb99c4c259d11669717c574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga904aa3c3fdb99c4c259d11669717c574">ad_spi_device_acquire</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev)</td></tr>
<tr class="memdesc:ga904aa3c3fdb99c4c259d11669717c574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire access to SPI device.  <a href="#ga904aa3c3fdb99c4c259d11669717c574">More...</a><br /></td></tr>
<tr class="separator:ga904aa3c3fdb99c4c259d11669717c574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad00b8a69fbb2cf0dc671766ce69b7ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gad00b8a69fbb2cf0dc671766ce69b7ba4">ad_spi_device_release</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev)</td></tr>
<tr class="memdesc:gad00b8a69fbb2cf0dc671766ce69b7ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire access to SPI device.  <a href="#gad00b8a69fbb2cf0dc671766ce69b7ba4">More...</a><br /></td></tr>
<tr class="separator:gad00b8a69fbb2cf0dc671766ce69b7ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96b59c2a5e6328ea91bd9240bbe46195"><td class="memItemLeft" align="right" valign="top">HW_SPI_ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga96b59c2a5e6328ea91bd9240bbe46195">ad_spi_get_hw_spi_id</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev)</td></tr>
<tr class="memdesc:ga96b59c2a5e6328ea91bd9240bbe46195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SPI controller id.  <a href="#ga96b59c2a5e6328ea91bd9240bbe46195">More...</a><br /></td></tr>
<tr class="separator:ga96b59c2a5e6328ea91bd9240bbe46195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094bf04ad3839c4a8b236e7f7673b25c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga094bf04ad3839c4a8b236e7f7673b25c">ad_spi_async_transact</a> (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev,...)</td></tr>
<tr class="memdesc:ga094bf04ad3839c4a8b236e7f7673b25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous SPI transaction.  <a href="#ga094bf04ad3839c4a8b236e7f7673b25c">More...</a><br /></td></tr>
<tr class="separator:ga094bf04ad3839c4a8b236e7f7673b25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>SPI adapter. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gae6451beaba214cef8ee9bda5dddce1b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ad_spi_async_write</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ud&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga094bf04ad3839c4a8b236e7f7673b25c">ad_spi_async_transact</a>(dev, <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7ef744aa93dc36d1ed06fa3efba2df9e">SPI_CSA</a>, SPI_SND(buf, len), SPI_CSD, SPI_CB1(cb, ud), SPI_END)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous write SPI transaction. </p>
<p>This is convenience macro that builds typical write only transaction and executes it. After all is done user callback is executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ud</td><td>user data to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The callback is called from within SPI ISR and at that time resources (device and bus) are released</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supplied buffer must be be SPI-word-aligned (no alignment needed for 9-bit SPI word configurations). </dd></dl>

</div>
</div>
<a class="anchor" id="ga98a5c589751b638a727c8bf8f00f57aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ad_spi_async_write_read</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wbuf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wlen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rbuf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rlen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ud&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga094bf04ad3839c4a8b236e7f7673b25c">ad_spi_async_transact</a>(dev, <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7ef744aa93dc36d1ed06fa3efba2df9e">SPI_CSA</a>, SPI_SND(wbuf, wlen), SPI_RCV(rbuf, rlen), SPI_CSD, \</div>
<div class="line">                                                                        SPI_CB1(cb, ud), SPI_END)</div>
<div class="ttc" id="group___s_p_i___a_d_a_p_t_e_r_html_ga094bf04ad3839c4a8b236e7f7673b25c"><div class="ttname"><a href="group___s_p_i___a_d_a_p_t_e_r.html#ga094bf04ad3839c4a8b236e7f7673b25c">ad_spi_async_transact</a></div><div class="ttdeci">void ad_spi_async_transact(spi_device dev,...)</div><div class="ttdoc">Start asynchronous SPI transaction. </div></div>
<div class="ttc" id="group___s_p_i___a_d_a_p_t_e_r_html_ga7ef744aa93dc36d1ed06fa3efba2df9e"><div class="ttname"><a href="group___s_p_i___a_d_a_p_t_e_r.html#ga7ef744aa93dc36d1ed06fa3efba2df9e">SPI_CSA</a></div><div class="ttdeci">#define SPI_CSA</div><div class="ttdef"><b>Definition:</b> ad_spi.h:628</div></div>
</div><!-- fragment -->
<p>Start asynchronous write then read SPI transaction. </p>
<p>This is convenience macro that builds typical write then read transaction and executes it. After all is done user callback is executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>number of bytes to write </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ud</td><td>user data to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<p>Example usage: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev = <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7a57010db50760061d4d70bfee84f900">ad_spi_open</a>(PRESSURE_SENSOR);</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga98a5c589751b638a727c8bf8f00f57aa">ad_spi_async_write_read</a>(dev, command, <span class="keyword">sizeof</span>(command), response, <span class="keyword">sizeof</span>(response),</div>
<div class="line">                                                                     final_callbak, cb_arg));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// wait here for final callback notification</span></div>
<div class="line">    <span class="comment">// do something with response</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The callback is called from within SPI ISR and at that time resources (device and bus) are released</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supplied buffers must be be SPI-word-aligned (no alignment needed for 9-bit SPI word configurations). </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4edb64ea31eb326a8283fe3d64f48b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_SPI_EXCLUSIVE_OPEN&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to configure exclusive use of devices. </p>
<p>Set this macro to 1 in order to enable preventing multiple tasks opening the same device. When set to 1, <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga904aa3c3fdb99c4c259d11669717c574" title="Acquire access to SPI device. ">ad_spi_device_acquire()</a> and <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gad00b8a69fbb2cf0dc671766ce69b7ba4" title="Acquire access to SPI device. ">ad_spi_device_release()</a> are no longer necessary.</p>
<dl class="section note"><dt>Note</dt><dd>The setting of this macro is irrelevant if <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga5d7f6d6e9d54be9ef930804210594f5b">CONFIG_SPI_USE_RESMGMT</a> is unset.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga5d7f6d6e9d54be9ef930804210594f5b" title="Controls whether SPI resource acquisition will be used. ">CONFIG_SPI_USE_RESMGMT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga58dd1393569b63315582f974b31abe22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_SPI_ONE_DEVICE_ON_BUS&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to configure only one device on the SPI bus. </p>
<p>Set this macro to 1 if only one SPI device exists on the bus to reduce code size and improve performance. </p>

</div>
</div>
<a class="anchor" id="ga7bf263f47eae6a5f431bd4b6c9642bb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_SPI_RESOURCE_STATIC_ID&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to configure resource ID assignment for each device. </p>
<p>Set this macro to 1 to enable unique resource ID assignment per device. </p>

</div>
</div>
<a class="anchor" id="ga66d27ad5bdb4d305d0967f9172566b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_SPI_USE_ASYNC_TRANSACTIONS&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether SPI asynchronous transaction API will be used. </p>
<p>SPI transaction API maintains state in retention RAM for every SPI bus declared. If the API is not to be used, setting this macro to 0 will save retention RAM. </p>

</div>
</div>
<a class="anchor" id="ga7eb20e1ef0c0dd977f19c85868a32c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_SPI_USE_DMA_RESMGMT&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether DMA resource acquisition will be used by the SPI adapter. </p>
<p>SPI adapter provides DMA resource access management in order to protect DMA resources from being used by multiple tasks simultaneously. Unsetting this macro will remove this feature, improving performance and potentially reducing code size (if the resource management API is not used by other modules). Unset this macro if, for example, you have exclusively assigned DMA channels to the SPI interface. </p>

</div>
</div>
<a class="anchor" id="ga5d7f6d6e9d54be9ef930804210594f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_SPI_USE_RESMGMT&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether SPI resource acquisition will be used. </p>
<p>SPI adapter provides resource access management in order to protect SPI resources (devices and buses) from being used by multiple tasks simultaneously. Unsetting this macro will remove this feature, improving performance and potentially reducing code size (if the resource management API is not used by other modules). All acquisition and release SPI adapter calls omit calls to the resource management API when this this macro is unset.</p>
<dl class="section note"><dt>Note</dt><dd>Unsetting this macro will not affect DMA resource management see <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7eb20e1ef0c0dd977f19c85868a32c4a">CONFIG_SPI_USE_DMA_RESMGMT</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga50a0f4cb4d47cfae401084680fb4fcbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_BUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id</td><td>)</td>
          <td>&#160;&#160;&#160;extern <a class="el" href="structspi__bus__dynamic__data.html">spi_bus_dynamic_data</a> dynamic_##bus_id;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting entry for SPI bus devices. </p>
<p>Here is an example how to use macros to define devices connected to SPI lines. </p><div class="fragment"><div class="line"><a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga50a0f4cb4d47cfae401084680fb4fcbe">SPI_BUS</a>(SPI2)</div>
<div class="line">     <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa8fbe8efe0995df3a2eaedf995044d6d">SPI_SLAVE_DEVICE</a>(SPI2, AT45DB011D, <a class="code" href="group___g_p_i_o.html#gga6b6280da85f0ebea3621e5bd2a575673a813525c9b6a040bb56069551201efd79">HW_GPIO_PORT_2</a>, <a class="code" href="group___g_p_i_o.html#ggae3241bac0025e5aacbd86e819aa3eea0a0b60d0f733256a81d9557cab169795e1">HW_GPIO_PIN_0</a>, <a class="code" href="group___s_p_i.html#gga700cecce4e0a953f8e95405af62838e5a004f380ce5228ff60b0dbbae20e48bad">HW_SPI_WORD_8BIT</a>,</div>
<div class="line">                                     HW_SPI_POL_LOW, HW_SPI_PHA_MODE_0, <a class="code" href="group___s_p_i.html#ggac66380a9439e8651f77f018acf5dd4e4aa5c09f98d578efc7f470e3deefe78869">HW_SPI_FREQ_DIV_2</a>);</div>
<div class="line">     <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa8fbe8efe0995df3a2eaedf995044d6d">SPI_SLAVE_DEVICE</a>(SPI2, TC77, HW_SPI_WORD_8BIT, HW_SPI_POL_LOW, HW_SPI_PHA_MODE_0,</div>
<div class="line">                                                                             <a class="code" href="group___s_p_i.html#ggac66380a9439e8651f77f018acf5dd4e4a3af9fb6bb1cb8198910db07725873b47">HW_SPI_FREQ_DIV_14</a>);</div>
<div class="line"><a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga8ad45c809f610a7a6b90659ce14f7a4a">SPI_BUS_END</a></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>identifies SPI bus SPI1 or SPI2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6d6e83837e5eed401bce0b45a8d04c9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_BUS_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga11dd02f927abfd0010ae5caa7b5638e1">ad_spi_bus_init</a>(&amp;dynamic_##bus_id)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization of SPI bus variables. </p>
<p>This macro must be invoked somewhere during system startup to initialize variables needed to manage SPI bus. It will create some OS specific synchronization primitives. Each bus created with <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga50a0f4cb4d47cfae401084680fb4fcbe" title="Starting entry for SPI bus devices. ">SPI_BUS()</a> must have corresponding call to this macro. If both SPIs are used somewhere in initialization sequence must be: <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga6d6e83837e5eed401bce0b45a8d04c9f" title="Initialization of SPI bus variables. ">SPI_BUS_INIT(SPI1)</a>; <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga6d6e83837e5eed401bce0b45a8d04c9f" title="Initialization of SPI bus variables. ">SPI_BUS_INIT(SPI2)</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>identifies SPI bus SPI1 or SPI2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7ef744aa93dc36d1ed06fa3efba2df9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_CSA&#160;&#160;&#160;(uint32_t) SPI_TAG_CS_ACTIVATE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronous SPI transactions</p>
<p>SPI adapter allows to create asynchronous transaction that consist of number of reads, writes, chip select manipulation and callback calls. This allow to create time efficient way to manage all SPI related actions. Most of the actions will be executed in ISR context. There are following asynchronous actions:</p>
<table class="doxtable">
<tr>
<th>Action </th><th>Macro  </th></tr>
<tr>
<td>Chip select activation </td><td>SPI_CSA </td></tr>
<tr>
<td>Chip select de-activation </td><td>SPI_CSD </td></tr>
<tr>
<td>Sending data </td><td>SPI_SND </td></tr>
<tr>
<td>Receiving data </td><td>SPI_RCV </td></tr>
<tr>
<td>Sending and receiving data </td><td>SPI_SRCV </td></tr>
<tr>
<td>Callback execution </td><td>SPI_CB0 </td></tr>
<tr>
<td>Callback execution with user data </td><td>SPI_CB1 </td></tr>
</table>
<p>Typical SPI transaction steps: CS activation, sending command, receiving response, CS de-activation</p>
<p>Asynchronous SPI transaction allows to build this sequence, start it and wait for final callback after everything is done. Following macros are used to construct asynchronous transactions on SPI device. </p>

</div>
</div>
<a class="anchor" id="gaa1570361a6b7dc66e732bb0c72bb812c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_DEVICE_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga9b025eea709195fd77a644dbf8c42154">ad_spi_device_init</a>(name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization of SPI bus devices. </p>
<p>This macro must be invoked somewhere during system startup to initialize variables needed to manage access to SPI devices. This is important if CONFIG_SPI_RESOURCE_STATIC_ID is not defined or equals 0, because resource id required for device access needs to be created at some point. Each device created with <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa8fbe8efe0995df3a2eaedf995044d6d" title="Entry for slave device. ">SPI_SLAVE_DEVICE()</a> and <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga922d30d48a654cf204be626d48276cc4" title="Entry for parameters when SPI is in slave mode. ">SPI_SLAVE_TO_EXT_MASTER()</a> must have corresponding call to this macro. Example: <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga6d6e83837e5eed401bce0b45a8d04c9f" title="Initialization of SPI bus variables. ">SPI_BUS_INIT(SPI1)</a>; <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa1570361a6b7dc66e732bb0c72bb812c" title="Initialization of SPI bus devices. ">SPI_DEVICE_INIT(AT45DB011D)</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>identifies SPI device connected to bus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa8fbe8efe0995df3a2eaedf995044d6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_SLAVE_DEVICE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cs_port, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cs_pin, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">word_mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pol_mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">phase_mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xtal_div, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;extern const void *const name;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry for slave device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>value must match <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga50a0f4cb4d47cfae401084680fb4fcbe" title="Starting entry for SPI bus devices. ">SPI_BUS()</a> argument valid values: SPI1, SPI2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name that will be used later to open device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs_port</td><td>port id for chip select </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs_pin</td><td>pin number for chip select </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">word_mode</td><td>SPI word size from HW_SPI_WORD enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pol_mode</td><td>idle state of clock line from HW_SPI_POL enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase_mode</td><td>which edge of clock is used for latching data from HW_SPI_PHA enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xtal_div</td><td>divisor of main clock, used for generating SPI clock from HW_SPI_FREQ enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel</td><td>DMA number for rx channel, tx will have next number, pass -1 for no DMA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga922d30d48a654cf204be626d48276cc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_SLAVE_TO_EXT_MASTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ignore_cs, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">word_mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pol_mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">phase_mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;extern const void *const name;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry for parameters when SPI is in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>value must match <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga50a0f4cb4d47cfae401084680fb4fcbe" title="Starting entry for SPI bus devices. ">SPI_BUS()</a> argument valid values: SPI1, SPI2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name that will be used later to open device only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_cs</td><td>specifies if chip select pin should be ignored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">word_mode</td><td>SPI word size from HW_SPI_WORD enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pol_mode</td><td>idle state of clock line from HW_SPI_POL enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase_mode</td><td>which edge of clock is used for latching data from HW_SPI_PHA enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel</td><td>DMA number for rx channel, tx will have next number, pass -1 for no DMA</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Slave mode is currently unsupported. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gace30ed166db32f6c79095581a44bc724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structspi__device__config.html">spi_device_config</a>  <a class="el" href="structspi__device__config.html">spi_device_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI device constant data. </p>
<p>Variable of this type keeps static configuration needed to access device on SPI bus. Those variables are generated by </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gaa8fbe8efe0995df3a2eaedf995044d6d" title="Entry for slave device. ">SPI_SLAVE_DEVICE()</a> and </dd>
<dd>
<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga922d30d48a654cf204be626d48276cc4" title="Entry for parameters when SPI is in slave mode. ">SPI_SLAVE_TO_EXT_MASTER()</a> macros. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga094bf04ad3839c4a8b236e7f7673b25c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_async_transact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous SPI transaction. </p>
<p>Arguments are actions that should be taken to perform full transaction. Arguments usually should start with SPI_CSA and have SPI_CSD after all transfer are done. It is possible to have multiply callback but usually callback should be execute after CS is deactivated. It is possible to create transaction without CS activation though.</p>
<p>It is important to now that transaction start from acquiring device and SPI bus and this is done synchronously meaning that that function can wait for device and bus access. It is possible to acquire device and bus before and then <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga094bf04ad3839c4a8b236e7f7673b25c" title="Start asynchronous SPI transaction. ">ad_spi_async_transact()</a> will not block. Buffers passed to this function should not be reused before final callback is called.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev = <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7a57010db50760061d4d70bfee84f900">ad_spi_open</a>(PRESSURE_SENSOR);</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga094bf04ad3839c4a8b236e7f7673b25c">ad_spi_async_transact</a>(dev, <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7ef744aa93dc36d1ed06fa3efba2df9e">SPI_CSA</a>, SPI_SND(command, <span class="keyword">sizeof</span>(command)),</div>
<div class="line">                           SPI_RCV(response, <span class="keyword">sizeof</span>(response), SPI_CSD, SPI_CB0(final_callbak));</div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Wait here for final callback notification</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Do something with the response</span></div>
<div class="line"></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Callbacks are called from within SPI ISRs.</dd>
<dd>
If the callback is the last action, resources (device and bus) will be released before the callback is called.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga65ff238ada37b8aa3ca3aba796ad64d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_bus_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire access to SPI bus. </p>
<p>This function waits for SPI bus to available, and locks it for <code>dev</code> use only. This function can be called several times, but number of <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga423d8d6c5ea7f380bad847192cace041" title="Release access to SPI bus. ">ad_spi_bus_release()</a> calls must match number of calls to this function.</p>
<p>This function should be used if normal <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga1b6238a703c170275bb2aee58eb19e1f" title="Perform typical SPI transaction. ">ad_spi_transact()</a>, <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga98ceafa3bc609ef9c1739f87be4c970b" title="Perform read only transaction. ">ad_spi_read()</a>, <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gad63e9ef311c855a818e9958d1d8196cb" title="Perform write only transaction. ">ad_spi_write()</a> are not enough and some other SPI controller calls are required. In this case typical usage for this function would look like this:</p>
<p>ad_spi_bus_acquire(dev); id = ad_spi_get_hw_spi_id(dev); ... hw_spi_set...(id, ...); hw_spi_write_buf(id, ...) hw_spi_wait_while_busy(id), ... ad_spi_bus_relase(dev);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The device must be already acquired through <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga904aa3c3fdb99c4c259d11669717c574" title="Acquire access to SPI device. ">ad_spi_device_acquire()</a> before calling this function. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1614f71139e561c8cac61168c48ec64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_bus_activate_cs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate chip select for a specific device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The device must own the bus before calling this function (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga904aa3c3fdb99c4c259d11669717c574" title="Acquire access to SPI device. ">ad_spi_device_acquire()</a> and <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga65ff238ada37b8aa3ca3aba796ad64d4" title="Acquire access to SPI bus. ">ad_spi_bus_acquire()</a> must be called previously from task execution context). </dd></dl>

</div>
</div>
<a class="anchor" id="gaba6a2a344ae7e38824d8cd5ae312a9b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_bus_deactivate_cs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivate chip select for a specific device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The device must own the bus before calling this function (<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga904aa3c3fdb99c4c259d11669717c574" title="Acquire access to SPI device. ">ad_spi_device_acquire()</a> and <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga65ff238ada37b8aa3ca3aba796ad64d4" title="Acquire access to SPI bus. ">ad_spi_bus_acquire()</a> must be called previously from task execution context). </dd></dl>

</div>
</div>
<a class="anchor" id="ga11dd02f927abfd0010ae5caa7b5638e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_bus_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bus_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize bus variables. </p>
<p>Don't call this function directly use SPI_BUS_INIT macro. </p>

</div>
</div>
<a class="anchor" id="ga423d8d6c5ea7f380bad847192cace041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_bus_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release access to SPI bus. </p>
<p>This function decrements acquire counter for this device and when it reaches 0 SPI bus is released and can be used by other devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga65ff238ada37b8aa3ca3aba796ad64d4" title="Acquire access to SPI bus. ">ad_spi_bus_acquire</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1031945079b5a0d955f9e3d6914a08ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_complex_transact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structspi__transfer__data.html">spi_transfer_data</a> *&#160;</td>
          <td class="paramname"><em>transfers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform complex transaction. </p>
<p>This function performs complex transaction on SPI bus. It can do several transaction in one chip select activation. It can do duplex transmission if element in <code>transfers</code> array has both wbuf and rbuf setup.</p>
<p>First chip select is activated for slave device. Then it performs all sub transaction from <code>transfer</code> array. Chip select is deactivated after all transaction finish.</p>
<p>This function is blocking. It can wait first for bus access, than it wait till transaction is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transfers</td><td>pointer to array of reads and writes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements in <code>transfer</code> array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7a57010db50760061d4d70bfee84f900" title="Open device connected to SPI bus. ">ad_spi_open()</a> </dd>
<dd>
ad_spi_close() </dd></dl>

</div>
</div>
<a class="anchor" id="ga904aa3c3fdb99c4c259d11669717c574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_device_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire access to SPI device. </p>
<p>This function grants exclusive access to SPI device (not bus). When access is granted no other task can use this device till <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gad00b8a69fbb2cf0dc671766ce69b7ba4" title="Acquire access to SPI device. ">ad_spi_device_release()</a> is called. When platform is compiled with <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7a57010db50760061d4d70bfee84f900" title="Open device connected to SPI bus. ">ad_spi_open()</a> exclusive access this function does nothing. When this function ends, other tasks can still use SPI bus to access different devices. For normal SPI transaction there is no need to call this function it will be called from <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga98ceafa3bc609ef9c1739f87be4c970b" title="Perform read only transaction. ">ad_spi_read()</a> <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gad63e9ef311c855a818e9958d1d8196cb" title="Perform write only transaction. ">ad_spi_write()</a> etc.. Explicit call to this is required when several transactions must be executed in sequence, i.e. modifying part of flash memory can require reading it to flash internal RAM buffer, overwriting flash RAM buffer, and writing flash RAM buffer to main flash memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gad00b8a69fbb2cf0dc671766ce69b7ba4" title="Acquire access to SPI device. ">ad_spi_device_release</a> </dd>
<dd>
<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga65ff238ada37b8aa3ca3aba796ad64d4" title="Acquire access to SPI bus. ">ad_spi_bus_acquire</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b025eea709195fd77a644dbf8c42154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_device_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gae12aff349582ab73813755817bcbcf6d">spi_device_id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize device variables. </p>
<p>Don't call this function directly use SPI_DEVICE_INIT macro. </p>

</div>
</div>
<a class="anchor" id="gad00b8a69fbb2cf0dc671766ce69b7ba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_device_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire access to SPI device. </p>
<p>This function release exclusive access to SPI device (not bus). Number of function calls must match number of <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga904aa3c3fdb99c4c259d11669717c574" title="Acquire access to SPI device. ">ad_spi_device_acquire()</a> calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga904aa3c3fdb99c4c259d11669717c574" title="Acquire access to SPI device. ">ad_spi_device_acquire</a> </dd>
<dd>
<a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga423d8d6c5ea7f380bad847192cace041" title="Release access to SPI bus. ">ad_spi_bus_release</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga96b59c2a5e6328ea91bd9240bbe46195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HW_SPI_ID ad_spi_get_hw_spi_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SPI controller id. </p>
<p>This function returns id that can be used to get SPI controller id. This id is argument for lower level functions starting with hw_spi_ prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id that can be used with hw_spi_... functions </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a57010db50760061d4d70bfee84f900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> ad_spi_open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#gae12aff349582ab73813755817bcbcf6d">spi_device_id</a>&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open device connected to SPI bus. </p>
<p>If system is configured for single device on each SPI bus (defined CONFIG_SPI_ONE_DEVICE_ON_BUS) This function will setup configuration parameters to SPI controller. If bus is not dedicated to single device only, configuration is performed during call to <a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga65ff238ada37b8aa3ca3aba796ad64d4" title="Acquire access to SPI bus. ">ad_spi_bus_acquire()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>identifier of device connected to SPI bus (name should match entries defined by SPI_SLAVE_DEVICE or SPI_SLAVE_TO_EXT_MASTER</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>device handle that can be used with other functions </dd></dl>

</div>
</div>
<a class="anchor" id="ga98ceafa3bc609ef9c1739f87be4c970b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform read only transaction. </p>
<p>This function performs read only transaction on SPI bus. First chip select is activated for slave device. Then data is read from SPI bus. Chip select is deactivated after transaction is finished.</p>
<p>This function is blocking. It can wait first for bus access, than it wait till transaction is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>pointer to data to be read from device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7a57010db50760061d4d70bfee84f900" title="Open device connected to SPI bus. ">ad_spi_open()</a> </dd>
<dd>
ad_spi_close()</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supplied buffer address and length must be be SPI-word-aligned (no alignment needed for 9-bit SPI word configurations). </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b6238a703c170275bb2aee58eb19e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_transact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform typical SPI transaction. </p>
<p>This function performs most typical transaction on SPI bus. First chip select is activated for slave device. Then buffer is sent over SPI bus. Then it changes to read mode and reads data from connected device. Chip select is deactivated after transaction is finished.</p>
<p>This function is blocking. It can wait first for bus access, than it wait till transaction is completed.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a> dev = <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7a57010db50760061d4d70bfee84f900">ad_spi_open</a>(PRESSURE_SENSOR);</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <span class="comment">// No CS necessary will be activated when needed</span></div>
<div class="line">    <a class="code" href="group___s_p_i___a_d_a_p_t_e_r.html#ga1b6238a703c170275bb2aee58eb19e1f">ad_spi_transact</a>(dev, command, <span class="keyword">sizeof</span>(command), response, <span class="keyword">sizeof</span>(response));</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>pointer to data to be sent to device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>pointer to data to be read from device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7a57010db50760061d4d70bfee84f900" title="Open device connected to SPI bus. ">ad_spi_open()</a> </dd>
<dd>
ad_spi_close()</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supplied buffer addresses and lengths must be be SPI-word-aligned (no alignment needed for 9-bit SPI word configurations). </dd></dl>

</div>
</div>
<a class="anchor" id="gad63e9ef311c855a818e9958d1d8196cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_spi_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga319721e2f4ba8a5ba2c4b1149889d5a1">spi_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform write only transaction. </p>
<p>This function performs write only transaction on SPI bus. First chip select is activated for slave device. Then buffer is sent over SPI bus. Chip select is deactivated after transaction is finished.</p>
<p>This function is blocking. It can wait first for bus access, than it wait till transaction is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to SPI device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>pointer to data to be sent to device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___a_d_a_p_t_e_r.html#ga7a57010db50760061d4d70bfee84f900" title="Open device connected to SPI bus. ">ad_spi_open()</a> </dd>
<dd>
ad_spi_close()</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supplied buffer address and length must be be SPI-word-aligned (no alignment needed for 9-bit SPI word configurations). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:05 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
