<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: I2C_ADAPTER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C_ADAPTER<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___a_d_a_p_t_e_r_s.html">ADAPTERS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>I2C adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__i2c_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__i2c_8h.html">ad_i2c.h</a></td></tr>
<tr class="memdesc:ad__i2c_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C device access API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__bus__dynamic__data.html">i2c_bus_dynamic_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C data run time data.  <a href="structi2c__bus__dynamic__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__dev__dynamic__data.html">i2c_dev_dynamic_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C device data run time data.  <a href="structi2c__dev__dynamic__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__dev__slave__event__callbacks.html">i2c_dev_slave_event_callbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave event callbacks.  <a href="structi2c__dev__slave__event__callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__dev__dynamic__data__slave.html">i2c_dev_dynamic_data_slave</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave state data.  <a href="structi2c__dev__dynamic__data__slave.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__device__config__t.html">i2c_device_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C device constant data.  <a href="structi2c__device__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa20598593de2e2dd808637e8ea06cc9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaa20598593de2e2dd808637e8ea06cc9d">CONFIG_I2C_ONE_DEVICE_ON_BUS</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaa20598593de2e2dd808637e8ea06cc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to configure only one device on the I2C bus.  <a href="#gaa20598593de2e2dd808637e8ea06cc9d">More...</a><br /></td></tr>
<tr class="separator:gaa20598593de2e2dd808637e8ea06cc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56d96467b542fc086369a4f049733b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab56d96467b542fc086369a4f049733b8">CONFIG_I2C_EXCLUSIVE_OPEN</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gab56d96467b542fc086369a4f049733b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to configure exclusive use of devices.  <a href="#gab56d96467b542fc086369a4f049733b8">More...</a><br /></td></tr>
<tr class="separator:gab56d96467b542fc086369a4f049733b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac435de8aa55a97979af693decf3705"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gabac435de8aa55a97979af693decf3705">CONFIG_I2C_RESOURCE_STATIC_ID</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gabac435de8aa55a97979af693decf3705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to configure resource ID assignment for each device.  <a href="#gabac435de8aa55a97979af693decf3705">More...</a><br /></td></tr>
<tr class="separator:gabac435de8aa55a97979af693decf3705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e541094b59475b0e27b71ad11cc9c7d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga9e541094b59475b0e27b71ad11cc9c7d">CONFIG_I2C_ENABLE_CRITICAL_SECTION</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga9e541094b59475b0e27b71ad11cc9c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable critical sections within some I2C adapter functions.  <a href="#ga9e541094b59475b0e27b71ad11cc9c7d">More...</a><br /></td></tr>
<tr class="separator:ga9e541094b59475b0e27b71ad11cc9c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ea113649ff626de4173a4ba95541b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gae1ea113649ff626de4173a4ba95541b7">CONFIG_I2C_USE_ASYNC_TRANSACTIONS</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gae1ea113649ff626de4173a4ba95541b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether I2C asynchronous transaction API will be used.  <a href="#gae1ea113649ff626de4173a4ba95541b7">More...</a><br /></td></tr>
<tr class="separator:gae1ea113649ff626de4173a4ba95541b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga865ca910fba5d5fd372753142d46e35c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga865ca910fba5d5fd372753142d46e35c">CONFIG_I2C_USE_RESMGMT</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga865ca910fba5d5fd372753142d46e35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether I2C resource acquisition will be used.  <a href="#ga865ca910fba5d5fd372753142d46e35c">More...</a><br /></td></tr>
<tr class="separator:ga865ca910fba5d5fd372753142d46e35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11636d2c9822adb00b1cab1bd8ce5ef4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga11636d2c9822adb00b1cab1bd8ce5ef4">CONFIG_I2C_USE_DMA_RESMGMT</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga11636d2c9822adb00b1cab1bd8ce5ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether DMA resource acquisition will be used by the I2C adapter.  <a href="#ga11636d2c9822adb00b1cab1bd8ce5ef4">More...</a><br /></td></tr>
<tr class="separator:ga11636d2c9822adb00b1cab1bd8ce5ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75d0df6ad0b14015c4846d672e78460e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga75d0df6ad0b14015c4846d672e78460e">I2C_SLAVE_DEVICE</a>(bus_id,  name,  addr,  addr_mode,  speed)&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga125f68c47bbad74256ae0ef8aec01901">I2C_SLAVE_DEVICE_DMA</a>(bus_id, name, addr, addr_mode, speed, -1)</td></tr>
<tr class="memdesc:ga75d0df6ad0b14015c4846d672e78460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry for slave device.  <a href="#ga75d0df6ad0b14015c4846d672e78460e">More...</a><br /></td></tr>
<tr class="separator:ga75d0df6ad0b14015c4846d672e78460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125f68c47bbad74256ae0ef8aec01901"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga125f68c47bbad74256ae0ef8aec01901">I2C_SLAVE_DEVICE_DMA</a>(bus_id,  name,  addr,  addr_mode,  speed,  dma_channel)&#160;&#160;&#160;extern const void *const name;</td></tr>
<tr class="memdesc:ga125f68c47bbad74256ae0ef8aec01901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry for slave device with DMA.  <a href="#ga125f68c47bbad74256ae0ef8aec01901">More...</a><br /></td></tr>
<tr class="separator:ga125f68c47bbad74256ae0ef8aec01901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ebd68c3f255c095c5a69fcddeba510"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga98ebd68c3f255c095c5a69fcddeba510">I2C_SLAVE_TO_EXT_MASTER</a>(bus_id,  name,  addr,  addr_mode,  speed,  dma_channel)&#160;&#160;&#160;extern const void *const name;</td></tr>
<tr class="memdesc:ga98ebd68c3f255c095c5a69fcddeba510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry for device representing I2C controller in slave mode.  <a href="#ga98ebd68c3f255c095c5a69fcddeba510">More...</a><br /></td></tr>
<tr class="separator:ga98ebd68c3f255c095c5a69fcddeba510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3555af36589f9708a524f6226beee771"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3555af36589f9708a524f6226beee771">I2C_BUS</a>(bus_id)&#160;&#160;&#160;extern <a class="el" href="structi2c__bus__dynamic__data.html">i2c_bus_dynamic_data</a> dynamic_##bus_id;</td></tr>
<tr class="memdesc:ga3555af36589f9708a524f6226beee771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting entry for I2C bus devices.  <a href="#ga3555af36589f9708a524f6226beee771">More...</a><br /></td></tr>
<tr class="separator:ga3555af36589f9708a524f6226beee771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41edcd9452939c7816c2f26b59ba21d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41edcd9452939c7816c2f26b59ba21d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga41edcd9452939c7816c2f26b59ba21d7">I2C_BUS_END</a></td></tr>
<tr class="memdesc:ga41edcd9452939c7816c2f26b59ba21d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ends I2C bus device list started with <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3555af36589f9708a524f6226beee771" title="Starting entry for I2C bus devices. ">I2C_BUS()</a> <br /></td></tr>
<tr class="separator:ga41edcd9452939c7816c2f26b59ba21d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07cf39f9d0b3d3d0965d7e3d19a7d115"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga07cf39f9d0b3d3d0965d7e3d19a7d115">I2C_BUS_INIT</a>(bus_id)&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga62681d91a18677298bddf5b4132708f7">ad_i2c_bus_init</a>(&amp;dynamic_##bus_id)</td></tr>
<tr class="memdesc:ga07cf39f9d0b3d3d0965d7e3d19a7d115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of I2C bus variables.  <a href="#ga07cf39f9d0b3d3d0965d7e3d19a7d115">More...</a><br /></td></tr>
<tr class="separator:ga07cf39f9d0b3d3d0965d7e3d19a7d115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55edd1515d4b4fd45050799a31d7bc50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga55edd1515d4b4fd45050799a31d7bc50">I2C_DEVICE_INIT</a>(name)&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga4172de562b2e86a018a5d96e8580926d">ad_i2c_device_init</a>(name)</td></tr>
<tr class="memdesc:ga55edd1515d4b4fd45050799a31d7bc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization of I2C bus devices.  <a href="#ga55edd1515d4b4fd45050799a31d7bc50">More...</a><br /></td></tr>
<tr class="separator:ga55edd1515d4b4fd45050799a31d7bc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4760d7b3a05663bcde939ae164a24c19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga4760d7b3a05663bcde939ae164a24c19">I2C_SND</a>(wbuf,  len)&#160;&#160;&#160;(uint32_t) ((len) | I2C_TAG_SEND), (uint32_t) (wbuf)</td></tr>
<tr class="memdesc:ga4760d7b3a05663bcde939ae164a24c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data and wait until all data are placed in FIFO.  <a href="#ga4760d7b3a05663bcde939ae164a24c19">More...</a><br /></td></tr>
<tr class="separator:ga4760d7b3a05663bcde939ae164a24c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d67edfe4a39750a669f4ad1b1dbeea3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8d67edfe4a39750a669f4ad1b1dbeea3">I2C_SND_ST</a>(wbuf,  len)&#160;&#160;&#160;(uint32_t) ((len) | I2C_TAG_SEND_STOP), (uint32_t) (wbuf)</td></tr>
<tr class="memdesc:ga8d67edfe4a39750a669f4ad1b1dbeea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data and wait until STOP condition is detected.  <a href="#ga8d67edfe4a39750a669f4ad1b1dbeea3">More...</a><br /></td></tr>
<tr class="separator:ga8d67edfe4a39750a669f4ad1b1dbeea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083ed110d68fb7d9bfc47b90d3d95843"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga083ed110d68fb7d9bfc47b90d3d95843">I2C_RCV</a>(rbuf,  len)&#160;&#160;&#160;(uint32_t) ((len) | I2C_TAG_RECEIVE_STOP), (uint32_t) (rbuf)</td></tr>
<tr class="memdesc:ga083ed110d68fb7d9bfc47b90d3d95843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data, generate stop condition after last byte.  <a href="#ga083ed110d68fb7d9bfc47b90d3d95843">More...</a><br /></td></tr>
<tr class="separator:ga083ed110d68fb7d9bfc47b90d3d95843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10c63d826bc67aeadad5bf5c11fffe0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga10c63d826bc67aeadad5bf5c11fffe0d">I2C_RCV_NS</a>(rbuf,  len)&#160;&#160;&#160;(uint32_t) ((len) | I2C_TAG_RECEIVE), (uint32_t) (rbuf)</td></tr>
<tr class="memdesc:ga10c63d826bc67aeadad5bf5c11fffe0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data, do not generate stop condition.  <a href="#ga10c63d826bc67aeadad5bf5c11fffe0d">More...</a><br /></td></tr>
<tr class="separator:ga10c63d826bc67aeadad5bf5c11fffe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8677d1993c9245da5f9e83e8f64f3163"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8677d1993c9245da5f9e83e8f64f3163">I2C_CB</a>(cb)&#160;&#160;&#160;(uint32_t) I2C_TAG_CALLBACK0, (uint32_t) (cb)</td></tr>
<tr class="memdesc:ga8677d1993c9245da5f9e83e8f64f3163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to call after transaction completes.  <a href="#ga8677d1993c9245da5f9e83e8f64f3163">More...</a><br /></td></tr>
<tr class="separator:ga8677d1993c9245da5f9e83e8f64f3163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed3ebb7980876e666053c55bd3cf49c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3ed3ebb7980876e666053c55bd3cf49c">I2C_CB1</a>(cb,  arg)&#160;&#160;&#160;(uint32_t) I2C_TAG_CALLBACK1, (uint32_t) (cb), (uint32_t) (arg)</td></tr>
<tr class="memdesc:ga3ed3ebb7980876e666053c55bd3cf49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback with arguments to call after transaction completes.  <a href="#ga3ed3ebb7980876e666053c55bd3cf49c">More...</a><br /></td></tr>
<tr class="separator:ga3ed3ebb7980876e666053c55bd3cf49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc551cf153061a8f672861064f29ed0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8fc551cf153061a8f672861064f29ed0">I2C_END</a>&#160;&#160;&#160;(uint32_t) 0</td></tr>
<tr class="memdesc:ga8fc551cf153061a8f672861064f29ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark end of transactions.  <a href="#ga8fc551cf153061a8f672861064f29ed0">More...</a><br /></td></tr>
<tr class="separator:ga8fc551cf153061a8f672861064f29ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb5fc0566095db4ee4e73d9047f2a9a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafbb5fc0566095db4ee4e73d9047f2a9a">ad_i2c_async_write</a>(dev,  wbuf,  wlen,  cb,  ud)&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb">ad_i2c_async_transact</a>(dev, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8d67edfe4a39750a669f4ad1b1dbeea3">I2C_SND_ST</a>(wbuf, wlen), <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3ed3ebb7980876e666053c55bd3cf49c">I2C_CB1</a>(cb, ud), <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8fc551cf153061a8f672861064f29ed0">I2C_END</a>)</td></tr>
<tr class="memdesc:gafbb5fc0566095db4ee4e73d9047f2a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous write I2C transaction.  <a href="#gafbb5fc0566095db4ee4e73d9047f2a9a">More...</a><br /></td></tr>
<tr class="separator:gafbb5fc0566095db4ee4e73d9047f2a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f55cdd8f53073925fe0da958add1277"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga1f55cdd8f53073925fe0da958add1277">i2c_async_write</a>(dev,  wbuf,  wlen,  cb,  ud)&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafbb5fc0566095db4ee4e73d9047f2a9a">ad_i2c_async_write</a>(dev, wbuf, wlen, cb, ud)</td></tr>
<tr class="memdesc:ga1f55cdd8f53073925fe0da958add1277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafbb5fc0566095db4ee4e73d9047f2a9a">ad_i2c_async_write</a>.  <a href="#ga1f55cdd8f53073925fe0da958add1277">More...</a><br /></td></tr>
<tr class="separator:ga1f55cdd8f53073925fe0da958add1277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23245cae7d9ebb5a9eb6e9f755159aa1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga23245cae7d9ebb5a9eb6e9f755159aa1">ad_i2c_async_read</a>(dev,  rbuf,  rlen,  cb,  ud)&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb">ad_i2c_async_transact</a>(dev, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga083ed110d68fb7d9bfc47b90d3d95843">I2C_RCV</a>(rbuf, rlen), <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3ed3ebb7980876e666053c55bd3cf49c">I2C_CB1</a>(cb, ud), <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8fc551cf153061a8f672861064f29ed0">I2C_END</a>)</td></tr>
<tr class="memdesc:ga23245cae7d9ebb5a9eb6e9f755159aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous read I2C transaction.  <a href="#ga23245cae7d9ebb5a9eb6e9f755159aa1">More...</a><br /></td></tr>
<tr class="separator:ga23245cae7d9ebb5a9eb6e9f755159aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac2b1009a190f54c11a17049b323bd0a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac2b1009a190f54c11a17049b323bd0a3"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a></td></tr>
<tr class="memdesc:gac2b1009a190f54c11a17049b323bd0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device pointer, handle to use with <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga9e4c1c40e5bc5a902cfeac36ba36cfcb" title="Perform read only transaction. ">ad_i2c_read()</a>, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga7f4cffcc64e70376e5ac61e55751e211" title="Perform write only transaction. ">ad_i2c_write()</a> etc. <br /></td></tr>
<tr class="separator:gac2b1009a190f54c11a17049b323bd0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32dfa1d0c5e347877b7b88505e98138"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac32dfa1d0c5e347877b7b88505e98138"></a>
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac32dfa1d0c5e347877b7b88505e98138">i2c_device_id</a></td></tr>
<tr class="memdesc:gac32dfa1d0c5e347877b7b88505e98138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device id, those are created by I2C_SLAVE_DEVICE or I2C_SLAVE_TO_EXT_MASTER macro in <a class="el" href="platform__devices_8h.html" title="Configuration of devices connected to board. ">platform_devices.h</a>. <br /></td></tr>
<tr class="separator:gac32dfa1d0c5e347877b7b88505e98138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b665bf082202d3e106611b9fa0e260"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9b665bf082202d3e106611b9fa0e260"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab9b665bf082202d3e106611b9fa0e260">ad_i2c_user_cb</a>) (void *user_data, <a class="el" href="group___i2_c.html#gaf7ef8a80c9c6e53c3edf28cc5bf2007e">HW_I2C_ABORT_SOURCE</a> error)</td></tr>
<tr class="memdesc:gab9b665bf082202d3e106611b9fa0e260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous callback function. <br /></td></tr>
<tr class="separator:gab9b665bf082202d3e106611b9fa0e260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2237d87b63cc713fcdd0d629cb21152a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structi2c__device__config__t.html">i2c_device_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga2237d87b63cc713fcdd0d629cb21152a">i2c_device_config</a></td></tr>
<tr class="memdesc:ga2237d87b63cc713fcdd0d629cb21152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C device constant data.  <a href="#ga2237d87b63cc713fcdd0d629cb21152a">More...</a><br /></td></tr>
<tr class="separator:ga2237d87b63cc713fcdd0d629cb21152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac1af8a888eeb7893994ff10bdd900055"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac1af8a888eeb7893994ff10bdd900055">AD_I2C_SLAVE_STATE</a> { <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ggac1af8a888eeb7893994ff10bdd900055a2e0595e500ca11cbdf5f9e7e15b32dfe">AD_I2C_SLAVE_STATE_STOPPED</a> = 0, 
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ggac1af8a888eeb7893994ff10bdd900055a5e17ab5541f692eb95da27bc8c912b51">AD_I2C_SLAVE_STATE_INIT</a> = 0x1, 
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ggac1af8a888eeb7893994ff10bdd900055a98dd6508b2e9e65e2cf69f63c9e8c4d3">AD_I2C_SLAVE_STATE_READ_PENDING</a> = 0x2, 
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ggac1af8a888eeb7893994ff10bdd900055a727d46eb6a915303f05ca923a1b07161">AD_I2C_SLAVE_STATE_WRITE_PENDING</a> = 0x4
 }</td></tr>
<tr class="memdesc:gac1af8a888eeb7893994ff10bdd900055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave state bits.  <a href="group___i2_c___a_d_a_p_t_e_r.html#gac1af8a888eeb7893994ff10bdd900055">More...</a><br /></td></tr>
<tr class="separator:gac1af8a888eeb7893994ff10bdd900055"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1b3105a748890da0dec74c504185819a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b3105a748890da0dec74c504185819a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga1b3105a748890da0dec74c504185819a">ad_i2c_init</a> (void)</td></tr>
<tr class="memdesc:ga1b3105a748890da0dec74c504185819a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize adapter. <br /></td></tr>
<tr class="separator:ga1b3105a748890da0dec74c504185819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62681d91a18677298bddf5b4132708f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga62681d91a18677298bddf5b4132708f7">ad_i2c_bus_init</a> (void *bus_data)</td></tr>
<tr class="memdesc:ga62681d91a18677298bddf5b4132708f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize bus variables.  <a href="#ga62681d91a18677298bddf5b4132708f7">More...</a><br /></td></tr>
<tr class="separator:ga62681d91a18677298bddf5b4132708f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4172de562b2e86a018a5d96e8580926d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga4172de562b2e86a018a5d96e8580926d">ad_i2c_device_init</a> (const <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac32dfa1d0c5e347877b7b88505e98138">i2c_device_id</a> id)</td></tr>
<tr class="memdesc:ga4172de562b2e86a018a5d96e8580926d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize device variables.  <a href="#ga4172de562b2e86a018a5d96e8580926d">More...</a><br /></td></tr>
<tr class="separator:ga4172de562b2e86a018a5d96e8580926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0282c5291f6a2af9929d302f1506eb7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c">ad_i2c_open</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac32dfa1d0c5e347877b7b88505e98138">i2c_device_id</a> dev_id)</td></tr>
<tr class="memdesc:ga0282c5291f6a2af9929d302f1506eb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open device connected to I2C bus.  <a href="#ga0282c5291f6a2af9929d302f1506eb7c">More...</a><br /></td></tr>
<tr class="separator:ga0282c5291f6a2af9929d302f1506eb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1e6350bdf0a4d6c22239743ebfb706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gadf1e6350bdf0a4d6c22239743ebfb706">ad_i2c_close</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> device)</td></tr>
<tr class="memdesc:gadf1e6350bdf0a4d6c22239743ebfb706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close I2C device.  <a href="#gadf1e6350bdf0a4d6c22239743ebfb706">More...</a><br /></td></tr>
<tr class="separator:gadf1e6350bdf0a4d6c22239743ebfb706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73400878e7a372d1e2da559c44fda74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaa73400878e7a372d1e2da559c44fda74">ad_i2c_transact</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev, const uint8_t *wbuf, size_t wlen, uint8_t *rbuf, size_t rlen)</td></tr>
<tr class="memdesc:gaa73400878e7a372d1e2da559c44fda74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an I2C read after write transaction.  <a href="#gaa73400878e7a372d1e2da559c44fda74">More...</a><br /></td></tr>
<tr class="separator:gaa73400878e7a372d1e2da559c44fda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f4cffcc64e70376e5ac61e55751e211"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga7f4cffcc64e70376e5ac61e55751e211">ad_i2c_write</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev, const uint8_t *wbuf, size_t wlen)</td></tr>
<tr class="memdesc:ga7f4cffcc64e70376e5ac61e55751e211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform write only transaction.  <a href="#ga7f4cffcc64e70376e5ac61e55751e211">More...</a><br /></td></tr>
<tr class="separator:ga7f4cffcc64e70376e5ac61e55751e211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e4c1c40e5bc5a902cfeac36ba36cfcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga9e4c1c40e5bc5a902cfeac36ba36cfcb">ad_i2c_read</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev, uint8_t *rbuf, size_t rlen)</td></tr>
<tr class="memdesc:ga9e4c1c40e5bc5a902cfeac36ba36cfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read only transaction.  <a href="#ga9e4c1c40e5bc5a902cfeac36ba36cfcb">More...</a><br /></td></tr>
<tr class="separator:ga9e4c1c40e5bc5a902cfeac36ba36cfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ddfc544b69572794f1a665a86a3639a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8ddfc544b69572794f1a665a86a3639a">ad_i2c_bus_acquire</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev)</td></tr>
<tr class="memdesc:ga8ddfc544b69572794f1a665a86a3639a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire access to I2C bus.  <a href="#ga8ddfc544b69572794f1a665a86a3639a">More...</a><br /></td></tr>
<tr class="separator:ga8ddfc544b69572794f1a665a86a3639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123e1b6992f681b503dca7aeccb08d66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga123e1b6992f681b503dca7aeccb08d66">ad_i2c_bus_release</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev)</td></tr>
<tr class="memdesc:ga123e1b6992f681b503dca7aeccb08d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release access to I2C bus.  <a href="#ga123e1b6992f681b503dca7aeccb08d66">More...</a><br /></td></tr>
<tr class="separator:ga123e1b6992f681b503dca7aeccb08d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa50e58c448145fa5b16ce9dd47a596d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaaa50e58c448145fa5b16ce9dd47a596d">ad_i2c_device_acquire</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev)</td></tr>
<tr class="memdesc:gaaa50e58c448145fa5b16ce9dd47a596d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire access to I2C device.  <a href="#gaaa50e58c448145fa5b16ce9dd47a596d">More...</a><br /></td></tr>
<tr class="separator:gaaa50e58c448145fa5b16ce9dd47a596d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8acf2fbeb44f5fa8a77e90082de9e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga5b8acf2fbeb44f5fa8a77e90082de9e9">ad_i2c_device_release</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev)</td></tr>
<tr class="memdesc:ga5b8acf2fbeb44f5fa8a77e90082de9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release access to I2C device.  <a href="#ga5b8acf2fbeb44f5fa8a77e90082de9e9">More...</a><br /></td></tr>
<tr class="separator:ga5b8acf2fbeb44f5fa8a77e90082de9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd1cabf2f0249535b76a5d48f6a8643"><td class="memItemLeft" align="right" valign="top">HW_I2C_ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8fd1cabf2f0249535b76a5d48f6a8643">ad_i2c_get_hw_i2c_id</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev)</td></tr>
<tr class="memdesc:ga8fd1cabf2f0249535b76a5d48f6a8643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I2C controller id.  <a href="#ga8fd1cabf2f0249535b76a5d48f6a8643">More...</a><br /></td></tr>
<tr class="separator:ga8fd1cabf2f0249535b76a5d48f6a8643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7399faee4e087a23320486e29a3fe8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaa7399faee4e087a23320486e29a3fe8b">ad_i2c_get_device_by_hw_id</a> (HW_I2C_ID id)</td></tr>
<tr class="memdesc:gaa7399faee4e087a23320486e29a3fe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current device for I2C controller.  <a href="#gaa7399faee4e087a23320486e29a3fe8b">More...</a><br /></td></tr>
<tr class="separator:gaa7399faee4e087a23320486e29a3fe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f48332646488454fb93bfffbdcf98bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb">ad_i2c_async_transact</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev,...)</td></tr>
<tr class="memdesc:ga6f48332646488454fb93bfffbdcf98bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous I2C transaction.  <a href="#ga6f48332646488454fb93bfffbdcf98bb">More...</a><br /></td></tr>
<tr class="separator:ga6f48332646488454fb93bfffbdcf98bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab244b18886ebfd78f97669bf29898af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab244b18886ebfd78f97669bf29898af3">ad_i2c_start_slave</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev, const uint8_t *wbuf, uint16_t wlen, uint8_t *rbuf, uint16_t rlen, const <a class="el" href="structi2c__dev__slave__event__callbacks.html">i2c_dev_slave_event_callbacks</a> *events, void *user_data)</td></tr>
<tr class="memdesc:gab244b18886ebfd78f97669bf29898af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start slave transmission/reception.  <a href="#gab244b18886ebfd78f97669bf29898af3">More...</a><br /></td></tr>
<tr class="separator:gab244b18886ebfd78f97669bf29898af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d7fc6b6e1d63a6f95a488caae0e2c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga72d7fc6b6e1d63a6f95a488caae0e2c1">ad_i2c_stop_slave</a> (<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev)</td></tr>
<tr class="memdesc:ga72d7fc6b6e1d63a6f95a488caae0e2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop slave response.  <a href="#ga72d7fc6b6e1d63a6f95a488caae0e2c1">More...</a><br /></td></tr>
<tr class="separator:ga72d7fc6b6e1d63a6f95a488caae0e2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>I2C adapter. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga23245cae7d9ebb5a9eb6e9f755159aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ad_i2c_async_read</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rbuf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rlen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ud&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb">ad_i2c_async_transact</a>(dev, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga083ed110d68fb7d9bfc47b90d3d95843">I2C_RCV</a>(rbuf, rlen), <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3ed3ebb7980876e666053c55bd3cf49c">I2C_CB1</a>(cb, ud), <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8fc551cf153061a8f672861064f29ed0">I2C_END</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous read I2C transaction. </p>
<p>This is convenience macro that builds read transaction and executes it. After all is done user callback is executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ud</td><td>user data passed to cb callback</td></tr>
  </table>
  </dd>
</dl>
<p>Example usage: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev = <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c">ad_i2c_open</a>(PRESSURE_SENSOR);</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga23245cae7d9ebb5a9eb6e9f755159aa1">ad_i2c_async_read</a>(dev, response, <span class="keyword">sizeof</span>(response), final_callback, cb_arg);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// wait here for final callback notification</span></div>
<div class="line">    <span class="comment">// do something with response</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The callback is called from within I2C ISR and at that time resources (device and bus) are released</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API. </dd></dl>

</div>
</div>
<a class="anchor" id="gafbb5fc0566095db4ee4e73d9047f2a9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ad_i2c_async_write</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wbuf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wlen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ud&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb">ad_i2c_async_transact</a>(dev, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8d67edfe4a39750a669f4ad1b1dbeea3">I2C_SND_ST</a>(wbuf, wlen), <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3ed3ebb7980876e666053c55bd3cf49c">I2C_CB1</a>(cb, ud), <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8fc551cf153061a8f672861064f29ed0">I2C_END</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous write I2C transaction. </p>
<p>This is convenience macro that builds typical write only transaction and executes it. After all is done and stop condition is detected user callback is executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>data to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>number of bytes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>callback to call after transaction is over (from ISR context) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ud</td><td>user data to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The callback is called from within I2C ISR and at that time resources (device and bus) are released</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e541094b59475b0e27b71ad11cc9c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_ENABLE_CRITICAL_SECTION&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable critical sections within some I2C adapter functions. </p>
<p>Some I2C peripherals do not respond well to a write-read transaction if a STOP condition occurs after the write operation. By setting this macro to 1, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaa73400878e7a372d1e2da559c44fda74" title="Perform an I2C read after write transaction. ">ad_i2c_transact()</a> will execute the write and the setup of read within a critical section, thus ensuring that no STOP condition will occur after write due to I2C FIFO underflow. </p>

</div>
</div>
<a class="anchor" id="gab56d96467b542fc086369a4f049733b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_EXCLUSIVE_OPEN&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to configure exclusive use of devices. </p>
<p>Set this macro to 1 in order to enable preventing multiple tasks opening the same device. When set to 1, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaaa50e58c448145fa5b16ce9dd47a596d" title="Acquire access to I2C device. ">ad_i2c_device_acquire()</a> and <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga5b8acf2fbeb44f5fa8a77e90082de9e9" title="Release access to I2C device. ">ad_i2c_device_release()</a> are no longer necessary.</p>
<dl class="section note"><dt>Note</dt><dd>The setting of this macro is irrelevant if <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga865ca910fba5d5fd372753142d46e35c">CONFIG_I2C_USE_RESMGMT</a> is unset. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa20598593de2e2dd808637e8ea06cc9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_ONE_DEVICE_ON_BUS&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to configure only one device on the I2C bus. </p>
<p>Set this macro to 1 if only one I2C device exists on the bus to reduce code size and improve performance. </p>

</div>
</div>
<a class="anchor" id="gabac435de8aa55a97979af693decf3705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_RESOURCE_STATIC_ID&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to configure resource ID assignment for each device. </p>
<p>Set this macro to 1 to enable unique resource ID assignment per device. </p>

</div>
</div>
<a class="anchor" id="gae1ea113649ff626de4173a4ba95541b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_USE_ASYNC_TRANSACTIONS&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether I2C asynchronous transaction API will be used. </p>
<p>I2C asynchronous transaction API (see "ad_i2c_async_*" API) maintains state in retention RAM for every I2C bus declared. If the API is not to be used, setting this macro to 0 will save retention RAM. </p>

</div>
</div>
<a class="anchor" id="ga11636d2c9822adb00b1cab1bd8ce5ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_USE_DMA_RESMGMT&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether DMA resource acquisition will be used by the I2C adapter. </p>
<p>I2C adapter provides DMA resource access management in order to protect DMA resources from being used by multiple tasks simultaneously. Unsetting this macro will remove this feature, improving performance and potentially reducing code size (if the resource management API is not used by other modules). Unset this macro if, for example, you have exclusively assigned DMA channels to the I2C interface. </p>

</div>
</div>
<a class="anchor" id="ga865ca910fba5d5fd372753142d46e35c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_I2C_USE_RESMGMT&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether I2C resource acquisition will be used. </p>
<p>I2C adapter provides resource access management in order to protect I2C resources (devices and buses) from being used by multiple tasks simultaneously. Unsetting this macro will remove this feature, improving performance and potentially reducing code size (if the resource management API is not used by other modules). All acquisition and release I2C adapter calls omit calls to the resource management API when this this macro is unset.</p>
<dl class="section note"><dt>Note</dt><dd>Unsetting this macro will not affect DMA resource management see <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga11636d2c9822adb00b1cab1bd8ce5ef4">CONFIG_I2C_USE_DMA_RESMGMT</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f55cdd8f53073925fe0da958add1277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define i2c_async_write</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wbuf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wlen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ud&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafbb5fc0566095db4ee4e73d9047f2a9a">ad_i2c_async_write</a>(dev, wbuf, wlen, cb, ud)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafbb5fc0566095db4ee4e73d9047f2a9a">ad_i2c_async_write</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gafbb5fc0566095db4ee4e73d9047f2a9a">ad_i2c_async_write()</a> directly. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3555af36589f9708a524f6226beee771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_BUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id</td><td>)</td>
          <td>&#160;&#160;&#160;extern <a class="el" href="structi2c__bus__dynamic__data.html">i2c_bus_dynamic_data</a> dynamic_##bus_id;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting entry for I2C bus devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>identifies I2C bus I2C1 or I2C2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga07cf39f9d0b3d3d0965d7e3d19a7d115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_BUS_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga62681d91a18677298bddf5b4132708f7">ad_i2c_bus_init</a>(&amp;dynamic_##bus_id)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization of I2C bus variables. </p>
<p>This macro must be invoked somewhere during system startup to initialize variables needed to manage I2C bus. It will create some OS specific synchronization primitives. Each bus created with <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3555af36589f9708a524f6226beee771" title="Starting entry for I2C bus devices. ">I2C_BUS()</a> must have corresponding call to this macro. If both I2Cs are used somewhere in initialization sequence must be: <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga07cf39f9d0b3d3d0965d7e3d19a7d115" title="Initialization of I2C bus variables. ">I2C_BUS_INIT(I2C1)</a>; <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga07cf39f9d0b3d3d0965d7e3d19a7d115" title="Initialization of I2C bus variables. ">I2C_BUS_INIT(I2C2)</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>identifies I2C bus I2C or I2C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8677d1993c9245da5f9e83e8f64f3163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb</td><td>)</td>
          <td>&#160;&#160;&#160;(uint32_t) I2C_TAG_CALLBACK0, (uint32_t) (cb)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to call after transaction completes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb" title="Start asynchronous I2C transaction. ">ad_i2c_async_transact</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ed3ebb7980876e666053c55bd3cf49c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CB1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(uint32_t) I2C_TAG_CALLBACK1, (uint32_t) (cb), (uint32_t) (arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback with arguments to call after transaction completes. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb" title="Start asynchronous I2C transaction. ">ad_i2c_async_transact</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga55edd1515d4b4fd45050799a31d7bc50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_DEVICE_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga4172de562b2e86a018a5d96e8580926d">ad_i2c_device_init</a>(name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization of I2C bus devices. </p>
<p>This macro must be invoked somewhere during system startup to initialize variables needed to manage access to I2C devices. This is important if CONFIG_I2C_RESOURCE_STATIC_ID is defined as 0, because resource id required for device access needs to be created at some point. Each device created with <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga75d0df6ad0b14015c4846d672e78460e" title="Entry for slave device. ">I2C_SLAVE_DEVICE()</a> and <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga98ebd68c3f255c095c5a69fcddeba510" title="Entry for device representing I2C controller in slave mode. ">I2C_SLAVE_TO_EXT_MASTER()</a> must have corresponding call to this macro. Example: </p><div class="fragment"><div class="line"><a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga07cf39f9d0b3d3d0965d7e3d19a7d115">I2C_BUS_INIT</a>(I2C1);</div>
<div class="line"><a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga55edd1515d4b4fd45050799a31d7bc50">I2C_DEVICE_INIT</a>(MEM_24LC256);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>identifies I2C device connected to bus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8fc551cf153061a8f672861064f29ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_END&#160;&#160;&#160;(uint32_t) 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark end of transactions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb" title="Start asynchronous I2C transaction. ">ad_i2c_async_transact</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga083ed110d68fb7d9bfc47b90d3d95843"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_RCV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rbuf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(uint32_t) ((len) | I2C_TAG_RECEIVE_STOP), (uint32_t) (rbuf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data, generate stop condition after last byte. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb" title="Start asynchronous I2C transaction. ">ad_i2c_async_transact</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga10c63d826bc67aeadad5bf5c11fffe0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_RCV_NS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rbuf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(uint32_t) ((len) | I2C_TAG_RECEIVE), (uint32_t) (rbuf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data, do not generate stop condition. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb" title="Start asynchronous I2C transaction. ">ad_i2c_async_transact</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga75d0df6ad0b14015c4846d672e78460e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SLAVE_DEVICE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr_mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">speed&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga125f68c47bbad74256ae0ef8aec01901">I2C_SLAVE_DEVICE_DMA</a>(bus_id, name, addr, addr_mode, speed, -1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry for slave device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>value must match <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3555af36589f9708a524f6226beee771" title="Starting entry for I2C bus devices. ">I2C_BUS()</a> argument valid values: I2C1, I2C2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name that will be used later to open device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>slave device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>slave device address mode from HW_I2C_ADDRESSING enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>I2C clock speed from HW_I2C_SPEED enum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga125f68c47bbad74256ae0ef8aec01901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SLAVE_DEVICE_DMA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr_mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">speed, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;extern const void *const name;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry for slave device with DMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>value must match <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3555af36589f9708a524f6226beee771" title="Starting entry for I2C bus devices. ">I2C_BUS()</a> argument valid values: I2C1, I2C2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name that will be used later to open device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>slave device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>slave device address mode from HW_I2C_ADDRESSING enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>I2C clock speed from HW_I2C_SPEED enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel</td><td>DMA channel to use, -1 for no DMA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98ebd68c3f255c095c5a69fcddeba510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SLAVE_TO_EXT_MASTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr_mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">speed, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;extern const void *const name;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry for device representing I2C controller in slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>value must match <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga3555af36589f9708a524f6226beee771" title="Starting entry for I2C bus devices. ">I2C_BUS()</a> argument valid values: I2C1, I2C2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name that will be used later to open device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>slave device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_mode</td><td>slave device address mode from HW_I2C_ADDRESSING enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>I2C clock speed from HW_I2C_SPEED enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel</td><td>DMA channel to use, -1 for no DMA</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Slave mode is currently unsupported. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4760d7b3a05663bcde939ae164a24c19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wbuf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(uint32_t) ((len) | I2C_TAG_SEND), (uint32_t) (wbuf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data and wait until all data are placed in FIFO. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb" title="Start asynchronous I2C transaction. ">ad_i2c_async_transact</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d67edfe4a39750a669f4ad1b1dbeea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SND_ST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">wbuf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(uint32_t) ((len) | I2C_TAG_SEND_STOP), (uint32_t) (wbuf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data and wait until STOP condition is detected. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb" title="Start asynchronous I2C transaction. ">ad_i2c_async_transact</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga2237d87b63cc713fcdd0d629cb21152a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structi2c__device__config__t.html">i2c_device_config_t</a>  <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga2237d87b63cc713fcdd0d629cb21152a">i2c_device_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C device constant data. </p>
<p>Variable of this type keeps static configuration needed to access device on I2C bus. Those variables are generated by </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga75d0df6ad0b14015c4846d672e78460e" title="Entry for slave device. ">I2C_SLAVE_DEVICE()</a> and </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga98ebd68c3f255c095c5a69fcddeba510" title="Entry for device representing I2C controller in slave mode. ">I2C_SLAVE_TO_EXT_MASTER()</a> macros. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac1af8a888eeb7893994ff10bdd900055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac1af8a888eeb7893994ff10bdd900055">AD_I2C_SLAVE_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave state bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggac1af8a888eeb7893994ff10bdd900055a2e0595e500ca11cbdf5f9e7e15b32dfe"></a>AD_I2C_SLAVE_STATE_STOPPED&#160;</td><td class="fielddoc">
<p>Slave stopped or uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac1af8a888eeb7893994ff10bdd900055a5e17ab5541f692eb95da27bc8c912b51"></a>AD_I2C_SLAVE_STATE_INIT&#160;</td><td class="fielddoc">
<p>Initial state. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac1af8a888eeb7893994ff10bdd900055a98dd6508b2e9e65e2cf69f63c9e8c4d3"></a>AD_I2C_SLAVE_STATE_READ_PENDING&#160;</td><td class="fielddoc">
<p>Slave read pending. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac1af8a888eeb7893994ff10bdd900055a727d46eb6a915303f05ca923a1b07161"></a>AD_I2C_SLAVE_STATE_WRITE_PENDING&#160;</td><td class="fielddoc">
<p>Slave write pending. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6f48332646488454fb93bfffbdcf98bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_async_transact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous I2C transaction. </p>
<p>Arguments are actions that should be taken to perform full transaction.</p>
<p>It is important to know that transaction starts from acquiring device and I2C bus and this is done synchronously meaning that function can wait for device and bus access. It is possible to acquire device and bus in advance and then <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb" title="Start asynchronous I2C transaction. ">ad_i2c_async_transact()</a> will not block. Buffers passed to this function should not be reused before final callback is called.</p>
<p>I2C adapter allows to create asynchronous transaction that consists of a number of reads, writes, and callback calls. This allows to create a time efficient way to manage all I2C related actions. Most of the actions will be executed in ISR context. These are the possible asynchronous transactions, passed in a form of arguments:</p>
<table class="doxtable">
<tr>
<th>Action </th><th>Macro  </th></tr>
<tr>
<td>Send data </td><td>I2C_SND </td></tr>
<tr>
<td>Send data and wait for STOP </td><td>I2C_SND_ST </td></tr>
<tr>
<td>Receive data </td><td>I2C_RCV </td></tr>
<tr>
<td>Callback execution </td><td>I2C_CB </td></tr>
<tr>
<td>Callback with data </td><td>I2C_CB1 </td></tr>
<tr>
<td>Mark end of transactions </td><td>I2C_END </td></tr>
</table>
<p>Typical I2C transaction steps: sending command/receiving response</p>
<p>Asynchronous I2C transaction allows to build this sequence, start it and wait for final callback after everything is done.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev = <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c">ad_i2c_open</a>(PRESSURE_SENSOR);</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga6f48332646488454fb93bfffbdcf98bb">ad_i2c_async_transact</a>(dev, <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga4760d7b3a05663bcde939ae164a24c19">I2C_SND</a>(command, <span class="keyword">sizeof</span>(command)),</div>
<div class="line">                               <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga083ed110d68fb7d9bfc47b90d3d95843">I2C_RCV</a>(response, <span class="keyword">sizeof</span>(response),</div>
<div class="line">                               <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga8677d1993c9245da5f9e83e8f64f3163">I2C_CB</a>(final_callback),</div>
<div class="line">                               <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga8fc551cf153061a8f672861064f29ed0">I2C_END</a>);</div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Wait here for final callback notification</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Do something with the response</span></div>
<div class="line"></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Callbacks are called from within I2C ISRs.</dd>
<dd>
If the callback is the last action, resources (device and bus) will be released before the callback is called.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ddfc544b69572794f1a665a86a3639a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_bus_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire access to I2C bus. </p>
<p>This function waits for I2C bus to available, and locks it for <code>dev's</code> use only. This function can be called several times, but number of <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga123e1b6992f681b503dca7aeccb08d66" title="Release access to I2C bus. ">ad_i2c_bus_release()</a> calls must match number of calls to this function.</p>
<p>This function should be used if normal <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaa73400878e7a372d1e2da559c44fda74" title="Perform an I2C read after write transaction. ">ad_i2c_transact()</a>, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga9e4c1c40e5bc5a902cfeac36ba36cfcb" title="Perform read only transaction. ">ad_i2c_read()</a>, <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga7f4cffcc64e70376e5ac61e55751e211" title="Perform write only transaction. ">ad_i2c_write()</a> are not enough and some other I2C controller calls are required. In this case typical usage for this function would look like this:</p>
<div class="fragment"><div class="line"><a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga8ddfc544b69572794f1a665a86a3639a">ad_i2c_bus_acquire</a>(dev);</div>
<div class="line"><span class="keywordtype">id</span> = <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga8fd1cabf2f0249535b76a5d48f6a8643">ad_i2c_get_hw_i2c_id</a>(dev);</div>
<div class="line">...</div>
<div class="line">hw_i2c_set...(id, ...);</div>
<div class="line"><a class="code" href="group___i2_c.html#gaa38e4a5363f57d5503e2207401f6e6c0">hw_i2c_write_buffer</a>(<span class="keywordtype">id</span>, ...)</div>
<div class="line">...</div>
<div class="line">ad_i2c_bus_release(dev);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The device must be already acquired through <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaaa50e58c448145fa5b16ce9dd47a596d" title="Acquire access to I2C device. ">ad_i2c_device_acquire()</a> before calling this function. </dd>
<dd>
This function shouldn't be used for Slave I2C devices when dg_configI2C_ADAPTER_SLAVE_SUPPORT is enabled. Its functionality is included in <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab244b18886ebfd78f97669bf29898af3" title="Start slave transmission/reception. ">ad_i2c_start_slave()</a> function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab244b18886ebfd78f97669bf29898af3" title="Start slave transmission/reception. ">ad_i2c_start_slave</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga62681d91a18677298bddf5b4132708f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_bus_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>bus_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize bus variables. </p>
<dl class="section warning"><dt>Warning</dt><dd>Don't call this function directly use I2C_BUS_INIT macro. </dd></dl>

</div>
</div>
<a class="anchor" id="ga123e1b6992f681b503dca7aeccb08d66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_bus_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release access to I2C bus. </p>
<p>This function decrements acquire counter for this device and when it reaches 0 I2C bus is released and can be used by other devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function shouldn't be used for Slave I2C devices when dg_configI2C_ADAPTER_SLAVE_SUPPORT is enabled. Its functionality is included in <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga72d7fc6b6e1d63a6f95a488caae0e2c1" title="Stop slave response. ">ad_i2c_stop_slave()</a> function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga72d7fc6b6e1d63a6f95a488caae0e2c1" title="Stop slave response. ">ad_i2c_stop_slave</a> </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8ddfc544b69572794f1a665a86a3639a" title="Acquire access to I2C bus. ">ad_i2c_bus_acquire</a> </dd>
<dd>
dg_configI2C_ADAPTER_SLAVE_SUPPORT </dd></dl>

</div>
</div>
<a class="anchor" id="gadf1e6350bdf0a4d6c22239743ebfb706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close I2C device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>handle to device opened with <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c" title="Open device connected to I2C bus. ">ad_i2c_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c" title="Open device connected to I2C bus. ">ad_i2c_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa50e58c448145fa5b16ce9dd47a596d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_device_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire access to I2C device. </p>
<p>This function waits for device to be available, and locks it for current task use only. This function can be called several times, but number of <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga5b8acf2fbeb44f5fa8a77e90082de9e9" title="Release access to I2C device. ">ad_i2c_device_release()</a> calls must match number of calls to this function.</p>
<p>This function should be used if several transaction on this device should not be interrupted. If writing to part of flash memory require reading and erasing, call to <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaaa50e58c448145fa5b16ce9dd47a596d" title="Acquire access to I2C device. ">ad_i2c_device_acquire()</a> will reserve device for current task not necessarily blocking whole I2C bus.</p>
<div class="fragment"><div class="line"><a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gaaa50e58c448145fa5b16ce9dd47a596d">ad_i2c_device_acquire</a>(dev);</div>
<div class="line">...</div>
<div class="line">ad_i2c_transact(<span class="keywordtype">id</span>, read_page_commad...);</div>
<div class="line"><a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga7f4cffcc64e70376e5ac61e55751e211">ad_i2c_write</a>(<span class="keywordtype">id</span>, write_enable_command...);</div>
<div class="line"><a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gaa73400878e7a372d1e2da559c44fda74">ad_i2c_transact</a>(<span class="keywordtype">id</span>, erase_page_command...);</div>
<div class="line"><a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga7f4cffcc64e70376e5ac61e55751e211">ad_i2c_write</a>(<span class="keywordtype">id</span>, write_enable_command...);</div>
<div class="line"><a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gaa73400878e7a372d1e2da559c44fda74">ad_i2c_transact</a>(<span class="keywordtype">id</span>, write_page_command...);</div>
<div class="line">...</div>
<div class="line">ad_i2c_device_release(dev);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function shouldn't be used for Slave I2C devices when dg_configI2C_ADAPTER_SLAVE_SUPPORT is enabled. Its functionality is included in <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab244b18886ebfd78f97669bf29898af3" title="Start slave transmission/reception. ">ad_i2c_start_slave()</a> function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab244b18886ebfd78f97669bf29898af3" title="Start slave transmission/reception. ">ad_i2c_start_slave</a> </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga5b8acf2fbeb44f5fa8a77e90082de9e9" title="Release access to I2C device. ">ad_i2c_device_release</a> </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab56d96467b542fc086369a4f049733b8" title="Macro to configure exclusive use of devices. ">CONFIG_I2C_EXCLUSIVE_OPEN</a> </dd>
<dd>
dg_configI2C_ADAPTER_SLAVE_SUPPORT </dd></dl>

</div>
</div>
<a class="anchor" id="ga4172de562b2e86a018a5d96e8580926d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_device_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac32dfa1d0c5e347877b7b88505e98138">i2c_device_id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize device variables. </p>
<dl class="section warning"><dt>Warning</dt><dd>Don't call this function directly use I2C_DEVICE_INIT macro. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b8acf2fbeb44f5fa8a77e90082de9e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_device_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release access to I2C device. </p>
<p>This function decrements acquire counter for this device and when it reaches 0 device is released and can be used by other tasks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function shouldn't be used for Slave I2C devices when dg_configI2C_ADAPTER_SLAVE_SUPPORT is enabled. Its functionality is included in <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga72d7fc6b6e1d63a6f95a488caae0e2c1" title="Stop slave response. ">ad_i2c_stop_slave()</a> function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga72d7fc6b6e1d63a6f95a488caae0e2c1" title="Stop slave response. ">ad_i2c_stop_slave</a> </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gaaa50e58c448145fa5b16ce9dd47a596d" title="Acquire access to I2C device. ">ad_i2c_device_acquire</a> </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab56d96467b542fc086369a4f049733b8" title="Macro to configure exclusive use of devices. ">CONFIG_I2C_EXCLUSIVE_OPEN</a> </dd>
<dd>
dg_configI2C_ADAPTER_SLAVE_SUPPORT </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7399faee4e087a23320486e29a3fe8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> ad_i2c_get_device_by_hw_id </td>
          <td>(</td>
          <td class="paramtype">HW_I2C_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current device for I2C controller. </p>
<p>This function returns i2c_device that is currently configured in I2C controller. Function is intended to use to retrieve i2c_device from interrupt context where only HW_I2C_ID is passed from hw_i2c driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>identifier of I2C bus (HW_I2C1 or HW_I2C2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>device that was used during <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8ddfc544b69572794f1a665a86a3639a" title="Acquire access to I2C bus. ">ad_i2c_bus_acquire()</a> function </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fd1cabf2f0249535b76a5d48f6a8643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HW_I2C_ID ad_i2c_get_hw_i2c_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I2C controller id. </p>
<p>This function returns id that can be used to get I2C controller id. This id is argument for lower level functions starting with hw_i2c_ prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id that can be used with hw_i2c_... functions </dd></dl>

</div>
</div>
<a class="anchor" id="ga0282c5291f6a2af9929d302f1506eb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> ad_i2c_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac32dfa1d0c5e347877b7b88505e98138">i2c_device_id</a>&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open device connected to I2C bus. </p>
<p>If system is configured for single device on each I2C bus (defined CONFIG_I2C_ONE_DEVICE_ON_BUS as 1) This function will setup configuration parameters to I2C controller. If bus is not dedicated to single device only, configuration is performed during call to <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga8ddfc544b69572794f1a665a86a3639a" title="Acquire access to I2C bus. ">ad_i2c_bus_acquire()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>identifier of device connected to I2C bus (name should match entries defined by I2C_SLAVE_DEVICE or I2C_SLAVE_TO_EXT_MASTER</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>device handle that can be used with other functions </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e4c1c40e5bc5a902cfeac36ba36cfcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform read only transaction. </p>
<p>This function performs a read only transaction on I2C bus. It waits first for device and bus resources to become available and then it will wait until the read transaction is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer to store the data read from the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c" title="Open device connected to I2C bus. ">ad_i2c_open()</a> </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gadf1e6350bdf0a4d6c22239743ebfb706" title="Close I2C device. ">ad_i2c_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab244b18886ebfd78f97669bf29898af3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_start_slave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi2c__dev__slave__event__callbacks.html">i2c_dev_slave_event_callbacks</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start slave transmission/reception. </p>
<p>When I2C is configured in slave mode, this function sets up input and/or output buffers to use for master initiated transmission and/or reception. It also specifies user callbacks that will be called when transmission or reception starts or finishes.</p>
<p>If the user specifies valid (wbuf, wlen) pair, data will be sent on incoming read request from master. After reception, data_sent() callback will be called. If wbuf is NULL or wlen is 0, read_request() callback will be called to notify the user about master read request.</p>
<p>If (rbuf, rlen) pair is specified, data will be received when master starts writing. When data is received, callback data_received() will be called. If rbuf is NULL or rlen is 0, data_ready() callback will be called to notify user about master write. If the user fails to read from the Rx FIFO before it becomes full then data loss may occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer for outgoing data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>number of bytes to write in case master wants to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer for incoming data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>structure with callback to call after transaction is over (from ISR context), if NULL, no callbacks will be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>user data to pass to each callback in events</td></tr>
  </table>
  </dd>
</dl>
<p>Example usage: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev = <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c">ad_i2c_open</a>(I2C_IN_SLAVE_MODE);</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    uint8_t cmd[4];</div>
<div class="line">    uint8_t response[6];</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gab244b18886ebfd78f97669bf29898af3">ad_i2c_start_slave</a>(dev, NULL, 0, cmd, <span class="keyword">sizeof</span>(cmd), slave_callbacks, NULL);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// wait while callbacks handle write request</span></div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// prepare response in out buffer</span></div>
<div class="line">    <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gab244b18886ebfd78f97669bf29898af3">ad_i2c_start_slave</a>(dev, response, <span class="keyword">sizeof</span>(response), NULL, 0, slave_callbacks, NULL);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// wait for master to read response</span></div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga72d7fc6b6e1d63a6f95a488caae0e2c1">ad_i2c_stop_slave</a>(dev);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>All callbacks are called from within I2C ISR </dd></dl>

</div>
</div>
<a class="anchor" id="ga72d7fc6b6e1d63a6f95a488caae0e2c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_i2c_stop_slave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop slave response. </p>
<p>This function will make a slave device stop responding to external master requests for read or write operations. If such an operation is ongoing, the function will wait for its completion before returning. The bus and device are released by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should only be called only if <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab244b18886ebfd78f97669bf29898af3" title="Start slave transmission/reception. ">ad_i2c_start_slave()</a> has been already used for starting the slave operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gab244b18886ebfd78f97669bf29898af3" title="Start slave transmission/reception. ">ad_i2c_start_slave()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa73400878e7a372d1e2da559c44fda74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_transact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an I2C read after write transaction. </p>
<p>This function performs a write transaction followed by a read transaction, an operation which is typical when reading data from I2C peripherals where an address needs to be specified through a write, before reading the data. The function will first wait for the device and bus resources to become available. It then proceeds with the write, without waiting for the STOP condition. If no error occurs by the time the last byte is placed in the transmit FIFO the function continues with the read operation and waits until it is completed.</p>
<p>Example usage: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a> dev = <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c">ad_i2c_open</a>(PRESSURE_SENSOR);</div>
<div class="line">  <span class="keywordflow">while</span> (1) {</div>
<div class="line">    <a class="code" href="group___i2_c___a_d_a_p_t_e_r.html#gaa73400878e7a372d1e2da559c44fda74">ad_i2c_transact</a>(dev, command, <span class="keyword">sizeof</span>(command), response, <span class="keyword">sizeof</span>(response));</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>buffer to store the data read from the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c" title="Open device connected to I2C bus. ">ad_i2c_open()</a> </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gadf1e6350bdf0a4d6c22239743ebfb706" title="Close I2C device. ">ad_i2c_close()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga9e541094b59475b0e27b71ad11cc9c7d" title="Enable critical sections within some I2C adapter functions. ">CONFIG_I2C_ENABLE_CRITICAL_SECTION</a> is enabled, it must be noted that the time within the critical section depends on the value of <em>wlen</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f4cffcc64e70376e5ac61e55751e211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_i2c_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gac2b1009a190f54c11a17049b323bd0a3">i2c_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform write only transaction. </p>
<p>This function performs a write only transaction on I2C bus. It waits first for device and bus resources to become available and then it will wait until the write transaction is completed and the STOP condition is detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to I2C device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>buffer containing the data to be sent to the device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent to the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, value from HW_I2C_ABORT_SOURCE enum on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#ga0282c5291f6a2af9929d302f1506eb7c" title="Open device connected to I2C bus. ">ad_i2c_open()</a> </dd>
<dd>
<a class="el" href="group___i2_c___a_d_a_p_t_e_r.html#gadf1e6350bdf0a4d6c22239743ebfb706" title="Close I2C device. ">ad_i2c_close()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:05 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
