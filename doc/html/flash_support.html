<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: DA1468x QSPI Flash Support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">DA1468x QSPI Flash Support </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Overview</h2>
<p>This document describes the QSPI Flash support in DA14681 SDK and the steps required to add support for new Flash types.</p>
<h2>Modes of operation and configuration</h2>
<p>The SDK supports two modes of operation: <b>Autodetect</b> mode and <b>Manual</b> mode. The <em>Autodetect</em> mode is able to detect the flash type on runtime, while the <em>Manual</em> mode involves explicitly declaring the used flash in the project.</p>
<p><b>Warning</b>: The default and recommended mode is the <b>Manual Mode</b>. The Autodetect Mode will greatly increase code size and Retained RAM usage, up to the point that a project may possibly not fit in RAM anymore.</p>
<h3>Autodetect Mode</h3>
<p>The Autodetect mode detects the flash that is used in runtime, and selects the proper flash driver to use. The Autodetect mode can only detect among the flash devices officially supported by the SDK. If no match is found, a default driver will be used (that may or may not work). Since the Autodetect mode needs to select the driver to use in runtime, it has to keep the code for all the drivers in the binary. Moreover, it has to keep the selected driver's configuration parameters in Retained RAM. Therefore, the Autodetect mode is <b>NOT recommended for production builds</b>.</p>
<h3>Manual Mode</h3>
<p>The Manual mode simply consists of a hardcoded declaration of the flash driver to use. Therefore, only the code of the selected driver needs to be compiled in the binary, and there is no need to retain the driver parameters in Retained RAM, since the compiler optimizes them out. This mode is <b>suitable for Production builds</b>.</p>
<h3>Flash Configuration</h3>
<p>The Flash subsystem is configured using the following macros (that must be defined in custom_config.h of the project):</p>
<ul>
<li>dg_configFLASH_AUTODETECT (Default: 0): This macro, if set, enables the Autodetect Mode. Please note, that <b>use of this macro is NOT recommended.</b></li>
<li>dg_configFLASH_HEADER_FILE: This macro must be defined as a string named after the header file to use for the specific flash driver. E.g. "<a class="el" href="qspi__w25q80ew_8h.html" title="QSPI flash driver for the Winbond W25Q80EW. ">qspi_w25q80ew.h</a>". This header file must be either one of the qspi_&lt;part_nr&gt;.h header files found under &lt;SDK ROOT&gt;/sdk/bsp/memory/include/, or a header file under the project's folder, <b>as long as this path is the compiler include path</b> (see the document section about adding support for new flash devices).</li>
<li>dg_configFLASH_MANUFACTURER_ID: This macro must be defined to the Flash manufacturer ID, as defined in the respective driver header file (e.g. WINBOND_ID)</li>
<li>dg_configFLASH_DEVICE_TYPE: This macro must be defined to the corresponding device type macro, as defined in the driver header file (e.g. W25Q80EW).</li>
<li>dg_configFLASH_DENSITY: This macro must be defined to the corresponding device density macro, as defined in the driver header file (W25Q_8Mb_SIZE).</li>
</ul>
<p>When the system is in <em>Manual Mode</em> (dg_configFLASH_AUTODETECT == 0), which is the default, all the three macros above are implicitly defined to enable the default flash used, which is the <b>Winbond W25Q80EW</b>.</p>
<h2>Code Structure</h2>
<p>The QSPI Flash access functionality is implemented in files qspi_automode.[ch]. Common command definitions and functions needed for all devices are declared in <a class="el" href="qspi__common_8h.html" title="QSPI flash driver common definitions. ">qspi_common.h</a>. Device specific code is defined in header files named qspi_&lt;flash device name&gt;.h.</p>
<p>The code in qspi_automode.c (and in some other parts of the SDK, as well), calls device-specific functions and uses device-specific values in order to properly initialize the flash device. Each driver header file provides an instance of the structure <em>qspi_flash_config_t</em> to the main driver, containing all the device-specific function pointers and variables.</p>
<h3>The flash configuration structure qspi_flash_config_t</h3>
<p>Each driver header file must provide its own instance of qspi_flash_config_t. Please note that <b>this instance must be named with a distinctive name</b>, like flash_&lt;device name&gt;_config, since all the device header files are included by qspi_automode.c, and, therefore, there is a single, global namespace. Also, please note that the struct instance <b>must be declared as const</b> in order to be optimized by the compiler.</p>
<p>The <em>qspi_flash_config_t</em> structure has the following fields (see <a class="el" href="qspi__common_8h.html" title="QSPI flash driver common definitions. ">qspi_common.h</a> for more information):</p>
<ul>
<li><em>initialize</em>: Pointer to the flash-specific initialization function.</li>
<li><em>is_suspended</em>: Pointer to a flash-specific function that checks if flash is in erase/program suspend state.</li>
<li><em>deactivate_command_entry_mode</em>: Pointer to a flash-specific function that performs extra steps needed when command entry mode is deactivated</li>
<li><em>sys_clk_cfg</em>: Pointer to a flash-specific function that performs Flash configuration when system clock is changed (e.g. change dummy bytes or QSPIC clock divider).</li>
<li><em>get_dummy_bytes</em>: Pointer to a flash-specific function that returns the number of dummy bytes currently needed (they may e.g. change when the clock changes).</li>
<li><em>manufacturer_id</em>: The Flash JEDEC vendor ID (Cmd 0x9F, 1st byte). This (and the device_type/device_density) are needed for flash autodetection, when on Autodetect mode.</li>
<li><em>device_type</em>: The Flash JEDEC device type (Cmd 0x9F, 2nd byte).</li>
<li><em>device_density</em>: The Flash JEDEC device type (Cmd 0x9F, 3rd byte).</li>
<li><em>erase_opcode</em>: The Flash erase opcode to use.</li>
<li><em>erase_suspend_opcode</em>: The Flash erase suspend opcode to use.</li>
<li><em>erase_resume_opcode</em>: The Flash erase resume opcode to use.</li>
<li><em>page_program_opcode</em>: The Flash page program opcode to use.</li>
<li><em>quad_page_program_address</em>: If true, the address will be transmitted in QUAD mode when writing a page. Otherwise, it will be transmitted in serial mode.</li>
<li><em>read_erase_progress_opcode</em>: The opcode to use to check if erase is in progress (Usually the Read Status Reg opcode (0x5).</li>
<li><em>erase_in_progress_bit</em>: The bit to check when reading the erase progress.</li>
<li><em>erase_in_progress_bit_high_level</em>: The active state (true: high, false: low) of the bit above.</li>
<li><em>send_once</em>: If set to 1, the "Performance mode" (or burst, or continuous; differs per vendor) will be used for read accesses. In this mode, the read opcode is only sent once, and subsequent accesses only transfer the address.</li>
<li><em>extra_byte</em>: The extra byte to transmit, when in "Performance mode" (send once is 1), that tells the flash that it should stay in this continuous, performance mode.</li>
<li><em>address_size</em>: Whether the flash works in 24- or 32-bit addressing mode.</li>
<li><em>break_seq_size</em>: Whether the break sequence, that puts flash out of the continuous mode, is one or two bytes long (the break byte is 0xFF).</li>
<li><em>ucode_wakeup</em>: The QSPIC microcode to use to setup the flash on wakeup. This is automatically used by the QSPI Controller after wakeup, and before CPU starts code execution. This is different based on whether flash was active, in deep power down or completely off while the system was sleeping.</li>
<li><em>power_down_delay</em>: This is the time, in usec, needed for the flash to go to power down, after the Power Down command is issued.</li>
<li><em>release_power_down_delay</em>: This is the time, in usec, needed for the flash to exit the power down mode, after the Release Power Down command is issued.</li>
</ul>
<p>When on <em>Autodetect mode</em>, these structures reside in the .rodata section of the code. As soon as the flash subsystem is initialized, it reads the flash JEDEC ID (command 0x9F) to find out which is the actual flash that is used. It then uses the JEDEC ID to select the corresponding flash_&lt;flash device&gt;_config structure, and copies it in the Retained RAM. It then uses it for all the flash operations that need it.</p>
<p>When on "Manual mode", no JEDED ID is read and no copy is performed to the Retained RAM. Instead, the constant pointer flash_config is directly initialized (inside the flash-specific driver file) to the specific (and constant) flash_&lt;device name&gt;_config structure. The compiler then optimizes out the entire structure.</p>
<h2>Adding support for a new flash device</h2>
<p>The SDK driver subsystem currently supports a specific set of QSPI flash devices. It provides, however, the capability to add support for other flash devices as well.</p>
<p>Each device driver must reside on its own header file, that should be named qspi_&lt;device name&gt;.h. The programmer can either use the <a class="el" href="qspi___x_x_x__template_8h.html" title="Driver for flash XXXX. ">qspi_XXX_template.h</a>, or start from an existing driver file. The new flash driver file should be placed inside the project's path, in a folder that is in the compiler's include path (an obvious choice is the config/ folder, but others can be used as well).</p>
<p>Common code among flash families or vendors can be factored out in common header file per family/vendor. There are currently such common header files, like <a class="el" href="qspi__macronix_8h.html" title="QSPI flash driver for Macronix flashes - common code. ">qspi_macronix.h</a> and <a class="el" href="qspi__winbond_8h.html" title="QSPI flash driver for Winbond flashes - common code. ">qspi_winbond.h</a> . However, this is NOT necessary; moreover, it is the responsibility of the device driver header file to include the common header file, if needed.</p>
<p>Please note that a custom flash driver <b>can ONLY be used in Manual mode</b>, that is, the four macros described in a previous section <b>MUST be defined in custom_config.h</b>.</p>
<p>The following steps are usually needed to create the new flash driver:</p>
<ol type="1">
<li>Copy and rename the template header file, or an existing driver file, into place.</li>
<li>Rename all the functions and variables accordingly. It is important to remember that <b>all the drivers reside in the same namespace, and, therefore, all function and variable names must be unique</b>.</li>
<li>Define the proper JEDEC ID values for the Manufacturer code, the device type and the device density</li>
<li>Verify that the suspend, resume, exit power-down, enter power-down, fast read, write enable, read status register are valid for the new device type.</li>
<li>Guard the header file using an #if preprocessor macro that checks for the specific driver selection.</li>
<li>Define any other driver-specific macros that are needed (like timings etc).</li>
<li>Define the constant wakeup microcode arrays that will be needed, per configuration mode that will be supported (dg_configFLASH_POWER_OFF, dg_configFLASH_POWER_DOWN or none of them). The microcode will be copied during the driver initialization in a special memory in the QSPI controller, and will be used after system wakeup to initialize the QSPI (since the CPU isn't yet running code at this time). Please see the DA1468x Datasheet for the uCode format.</li>
<li>Declare the constant struct instance, of type qspi_flash_config_t, named flash_&lt;device name&gt;_config, and initialize it with proper values. Please note that this <b>must be declared as const</b>.</li>
<li>Extend the function flash_&lt;device name&gt;_initialize() if needed, e.g. to write some special QSPI configuration registers or the QUAD enable bit. Otherwise, leave empty.</li>
<li>Extend the function flash_&lt;device name&gt;_sys_clock_cfg() function if needed. This can included modifying the dummy bytes when the system (and hence the QSPI clock) changes, or changing the QSPI clock divider (if, for example, the flash device cannot cope with 96MHz). Otherwise, leave empty.</li>
<li>The function is_suspended() should read the flash Status Register and return true if Erase or Write is suspended on the device.</li>
<li>If <em>Continuous Read Mode</em> (sometimes referred to as <em>Performance Mode</em>) is used, make sure to set <b>send_once</b> to 1, and set <b>extra_byte</b> to a proper value for the flash to keep working in this mode. This is flash-specific</li>
<li>If the flash supports <em>32-bit addressing</em>, make sure to use the proper <b>ucode for wakeup</b>, as well as the corresponding <b>page_program_opcode</b>, <b>erase_opcode</b>, <b>break_seq_size</b> (this should also take into consideration whether the device will be working in Continuous Read mode as well) and <b>address_size</b>.</li>
<li>If the address, during write, will be provided in QUAD mode, set <b>quad_page_program_address</b> to true.</li>
</ol>
<p>Please note that the SDK supports reading in QUAD I/O mode (where the address and data are read in QUAD mode, and only the command is transferred in serial mode), both in Continuous Read and normal mode. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:05 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
