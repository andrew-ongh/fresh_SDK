<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SmartSnippets DA1468x/DA15xxx SDK: UART_ADAPTER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x/DA15xxx SDK
   &#160;<span id="projectnumber">Version 1.0.14.1081</span>
   </div>
   <div id="projectbrief">Combo Bluetooth Smart and 802.15.4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART_ADAPTER<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___a_d_a_p_t_e_r_s.html">ADAPTERS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>UART adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__uart_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__uart_8h.html">ad_uart.h</a></td></tr>
<tr class="memdesc:ad__uart_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART adapter API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__bus__dynamic__data.html">uart_bus_dynamic_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART device data run time data.  <a href="structuart__bus__dynamic__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__device__config.html">uart_device_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART bus constant data.  <a href="structuart__device__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9a8228786b4220f081ce6176a93a2aab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga9a8228786b4220f081ce6176a93a2aab">CONFIG_UART_USE_RESMGMT</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga9a8228786b4220f081ce6176a93a2aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether UART resource acquisition will be used.  <a href="#ga9a8228786b4220f081ce6176a93a2aab">More...</a><br /></td></tr>
<tr class="separator:ga9a8228786b4220f081ce6176a93a2aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be01d68948b21d2210899e60784bb2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga5be01d68948b21d2210899e60784bb2f">CONFIG_UART_USE_DMA_RESMGMT</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga5be01d68948b21d2210899e60784bb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether DMA resource acquisition will be used by the UART adapter.  <a href="#ga5be01d68948b21d2210899e60784bb2f">More...</a><br /></td></tr>
<tr class="separator:ga5be01d68948b21d2210899e60784bb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161928ae516033cbe707cac5633861ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga161928ae516033cbe707cac5633861ce">AD_UART_FLAGS_LOCKING_ASYNC</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:ga161928ae516033cbe707cac5633861ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls to <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9">ad_uart_read_async()</a>, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gae193afb0033c24fbcdd28fb75a2d6683">ad_uart_write_async()</a> acquire bus.  <a href="#ga161928ae516033cbe707cac5633861ce">More...</a><br /></td></tr>
<tr class="separator:ga161928ae516033cbe707cac5633861ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e617d96d1ccd9d442b62be87ca345c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga60e617d96d1ccd9d442b62be87ca345c">UART_BUS</a>(bus_id,  name,  _baud_rate,  data_bits,  _parity,  _stop,  _auto_flow_control,  _use_fifo,  dma_channel_tx,  dma_channel_rx,  tx_fifo_tr_lvl,  rx_fifo_tr_lvl)&#160;&#160;&#160;extern const void *const name;</td></tr>
<tr class="memdesc:ga60e617d96d1ccd9d442b62be87ca345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry for slave device.  <a href="#ga60e617d96d1ccd9d442b62be87ca345c">More...</a><br /></td></tr>
<tr class="separator:ga60e617d96d1ccd9d442b62be87ca345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b122f24a1fedd200f145e3fabe53f55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga6b122f24a1fedd200f145e3fabe53f55">UART_DEV</a>(bus_id,  name,  _baud_rate,  data_bits,  _parity,  _stop,  _auto_flow_control,  _use_fifo,  dma_channel_tx,  dma_channel_rx,  tx_fifo_tr_lvl,  rx_fifo_tr_lvl,  _flags)&#160;&#160;&#160;extern const void *const name;</td></tr>
<tr class="memdesc:ga6b122f24a1fedd200f145e3fabe53f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry for serial device.  <a href="#ga6b122f24a1fedd200f145e3fabe53f55">More...</a><br /></td></tr>
<tr class="separator:ga6b122f24a1fedd200f145e3fabe53f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga59d3ae66a401dd3921cf2775ffa78439"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59d3ae66a401dd3921cf2775ffa78439"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a></td></tr>
<tr class="memdesc:ga59d3ae66a401dd3921cf2775ffa78439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device pointer, handle to use with <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga2035b1344458d57da35b1a459b83ff7f" title="Read from UART. ">ad_uart_read()</a>, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad3161397e053e5230fca67febc9e2147" title="Write to UART. ">ad_uart_write()</a> etc. <br /></td></tr>
<tr class="separator:ga59d3ae66a401dd3921cf2775ffa78439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9957354b1c342143b9b03457533fef3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9957354b1c342143b9b03457533fef3"></a>
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad9957354b1c342143b9b03457533fef3">uart_device_id</a></td></tr>
<tr class="memdesc:gad9957354b1c342143b9b03457533fef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device id, those are created by UART_BUS macro in <a class="el" href="platform__devices_8h.html" title="Configuration of devices connected to board. ">platform_devices.h</a>. <br /></td></tr>
<tr class="separator:gad9957354b1c342143b9b03457533fef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac855b4d7df3f7f93bb8010d85295879f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac855b4d7df3f7f93bb8010d85295879f"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gac855b4d7df3f7f93bb8010d85295879f">ad_uart_user_cb</a>) (void *user_data, uint16_t transferred)</td></tr>
<tr class="memdesc:gac855b4d7df3f7f93bb8010d85295879f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous callback function. <br /></td></tr>
<tr class="separator:gac855b4d7df3f7f93bb8010d85295879f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c5ede3587564c6c07b2726c3a03b738"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structuart__device__config.html">uart_device_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga4c5ede3587564c6c07b2726c3a03b738">uart_device_config</a></td></tr>
<tr class="memdesc:ga4c5ede3587564c6c07b2726c3a03b738"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART bus constant data.  <a href="#ga4c5ede3587564c6c07b2726c3a03b738">More...</a><br /></td></tr>
<tr class="separator:ga4c5ede3587564c6c07b2726c3a03b738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5d665822f955a640d0920f312b65a87d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga5d665822f955a640d0920f312b65a87d">AD_UART_DEVICE_FLAGS</a> { <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gga5d665822f955a640d0920f312b65a87da2c389faf8f7ab321078427228faf7df0">AD_UART_DEVICE_FLAGS_LOCKING_ASYNC</a> = 0x2
 }</td></tr>
<tr class="memdesc:ga5d665822f955a640d0920f312b65a87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART device flags.  <a href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga5d665822f955a640d0920f312b65a87d">More...</a><br /></td></tr>
<tr class="separator:ga5d665822f955a640d0920f312b65a87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866486e836d2039e6a272e1c7b8d5b49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga866486e836d2039e6a272e1c7b8d5b49">AD_UART_RES_TYPE</a> { <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gga866486e836d2039e6a272e1c7b8d5b49a04e61518eb75b78227fa31ff1127bcce">AD_UART_RES_TYPE_CONFIG</a>, 
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gga866486e836d2039e6a272e1c7b8d5b49aed83e45b81798d1dd3ed5f5f37989508">AD_UART_RES_TYPE_WRITE</a>, 
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gga866486e836d2039e6a272e1c7b8d5b49ac25932aa3532b3cbefb7e8f24297be68">AD_UART_RES_TYPE_READ</a>, 
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gga866486e836d2039e6a272e1c7b8d5b49a55372bdfc03b533ea9cdc68b01cb1a4f">AD_UART_RES_TYPES</a>
 }</td></tr>
<tr class="memdesc:ga866486e836d2039e6a272e1c7b8d5b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART resource types.  <a href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga866486e836d2039e6a272e1c7b8d5b49">More...</a><br /></td></tr>
<tr class="separator:ga866486e836d2039e6a272e1c7b8d5b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3d668bfee8a2e988061209ade5a3018c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3d668bfee8a2e988061209ade5a3018c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga3d668bfee8a2e988061209ade5a3018c">ad_uart_init</a> (void)</td></tr>
<tr class="memdesc:ga3d668bfee8a2e988061209ade5a3018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize adapter. <br /></td></tr>
<tr class="separator:ga3d668bfee8a2e988061209ade5a3018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07cb703a8b6387af205368cbd3de0fe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8">ad_uart_open</a> (const <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad9957354b1c342143b9b03457533fef3">uart_device_id</a> dev_id)</td></tr>
<tr class="memdesc:ga07cb703a8b6387af205368cbd3de0fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open UART device.  <a href="#ga07cb703a8b6387af205368cbd3de0fe8">More...</a><br /></td></tr>
<tr class="separator:ga07cb703a8b6387af205368cbd3de0fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga846fba0a733d6a6d5c4f06a8d1217ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga846fba0a733d6a6d5c4f06a8d1217ecb">ad_uart_close</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> device)</td></tr>
<tr class="memdesc:ga846fba0a733d6a6d5c4f06a8d1217ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close UART device.  <a href="#ga846fba0a733d6a6d5c4f06a8d1217ecb">More...</a><br /></td></tr>
<tr class="separator:ga846fba0a733d6a6d5c4f06a8d1217ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3161397e053e5230fca67febc9e2147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad3161397e053e5230fca67febc9e2147">ad_uart_write</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, const char *wbuf, size_t wlen)</td></tr>
<tr class="memdesc:gad3161397e053e5230fca67febc9e2147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to UART.  <a href="#gad3161397e053e5230fca67febc9e2147">More...</a><br /></td></tr>
<tr class="separator:gad3161397e053e5230fca67febc9e2147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae193afb0033c24fbcdd28fb75a2d6683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gae193afb0033c24fbcdd28fb75a2d6683">ad_uart_write_async</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, const char *wbuf, size_t wlen, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gac855b4d7df3f7f93bb8010d85295879f">ad_uart_user_cb</a> cb, void *user_data)</td></tr>
<tr class="memdesc:gae193afb0033c24fbcdd28fb75a2d6683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous write to UART.  <a href="#gae193afb0033c24fbcdd28fb75a2d6683">More...</a><br /></td></tr>
<tr class="separator:gae193afb0033c24fbcdd28fb75a2d6683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2035b1344458d57da35b1a459b83ff7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga2035b1344458d57da35b1a459b83ff7f">ad_uart_read</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, char *rbuf, size_t rlen, OS_TICK_TIME timeout)</td></tr>
<tr class="memdesc:ga2035b1344458d57da35b1a459b83ff7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from UART.  <a href="#ga2035b1344458d57da35b1a459b83ff7f">More...</a><br /></td></tr>
<tr class="separator:ga2035b1344458d57da35b1a459b83ff7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc22af2273d137b69f7afaf775fd3f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9">ad_uart_read_async</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, char *rbuf, size_t rlen, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gac855b4d7df3f7f93bb8010d85295879f">ad_uart_user_cb</a> cb, void *user_data)</td></tr>
<tr class="memdesc:gaacc22af2273d137b69f7afaf775fd3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous read from UART.  <a href="#gaacc22af2273d137b69f7afaf775fd3f9">More...</a><br /></td></tr>
<tr class="separator:gaacc22af2273d137b69f7afaf775fd3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0faa76f2466e015b640f47be37888179"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga0faa76f2466e015b640f47be37888179">ad_uart_complete_async_read</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev)</td></tr>
<tr class="memdesc:ga0faa76f2466e015b640f47be37888179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish asynchronous read.  <a href="#ga0faa76f2466e015b640f47be37888179">More...</a><br /></td></tr>
<tr class="separator:ga0faa76f2466e015b640f47be37888179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ea78f7363e4cc20f6694112a2d4c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga00ea78f7363e4cc20f6694112a2d4c76">ad_uart_abort_read_async</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev)</td></tr>
<tr class="memdesc:ga00ea78f7363e4cc20f6694112a2d4c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort previously started asynchronous read.  <a href="#ga00ea78f7363e4cc20f6694112a2d4c76">More...</a><br /></td></tr>
<tr class="separator:ga00ea78f7363e4cc20f6694112a2d4c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c84afdc598a9ea42cdc3452f30395a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a">ad_uart_bus_acquire</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev)</td></tr>
<tr class="memdesc:ga43c84afdc598a9ea42cdc3452f30395a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire access to UART bus.  <a href="#ga43c84afdc598a9ea42cdc3452f30395a">More...</a><br /></td></tr>
<tr class="separator:ga43c84afdc598a9ea42cdc3452f30395a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06924897ddd0c212a1eecdc37a7c1ff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4">ad_uart_bus_release</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev)</td></tr>
<tr class="memdesc:ga06924897ddd0c212a1eecdc37a7c1ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release access to UART bus.  <a href="#ga06924897ddd0c212a1eecdc37a7c1ff4">More...</a><br /></td></tr>
<tr class="separator:ga06924897ddd0c212a1eecdc37a7c1ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dd2fbc3a6a05dc00e62acff0554a84e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga0dd2fbc3a6a05dc00e62acff0554a84e">ad_uart_bus_acquire_ex</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga866486e836d2039e6a272e1c7b8d5b49">AD_UART_RES_TYPE</a> res_type)</td></tr>
<tr class="memdesc:ga0dd2fbc3a6a05dc00e62acff0554a84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire specific UART resource and its DMA counterpart.  <a href="#ga0dd2fbc3a6a05dc00e62acff0554a84e">More...</a><br /></td></tr>
<tr class="separator:ga0dd2fbc3a6a05dc00e62acff0554a84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ea2e8db4293a1f6ca336e178e0016a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga51ea2e8db4293a1f6ca336e178e0016a">ad_uart_bus_release_ex</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga866486e836d2039e6a272e1c7b8d5b49">AD_UART_RES_TYPE</a> res_type)</td></tr>
<tr class="memdesc:ga51ea2e8db4293a1f6ca336e178e0016a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release specific UART resource and its DMA counterpart.  <a href="#ga51ea2e8db4293a1f6ca336e178e0016a">More...</a><br /></td></tr>
<tr class="separator:ga51ea2e8db4293a1f6ca336e178e0016a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f8ee4d7d02f58dbdca2609808d264cd"><td class="memItemLeft" align="right" valign="top">HW_UART_ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga6f8ee4d7d02f58dbdca2609808d264cd">ad_uart_get_hw_uart_id</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev)</td></tr>
<tr class="memdesc:ga6f8ee4d7d02f58dbdca2609808d264cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART controller id.  <a href="#ga6f8ee4d7d02f58dbdca2609808d264cd">More...</a><br /></td></tr>
<tr class="separator:ga6f8ee4d7d02f58dbdca2609808d264cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UART adapter. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga161928ae516033cbe707cac5633861ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AD_UART_FLAGS_LOCKING_ASYNC&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls to <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9">ad_uart_read_async()</a>, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gae193afb0033c24fbcdd28fb75a2d6683">ad_uart_write_async()</a> acquire bus. </p>
<dl class="section note"><dt>Note</dt><dd>This macro is deprecated. Please use <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gga5d665822f955a640d0920f312b65a87da2c389faf8f7ab321078427228faf7df0">AD_UART_DEVICE_FLAGS_LOCKING_ASYNC</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5be01d68948b21d2210899e60784bb2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_UART_USE_DMA_RESMGMT&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether DMA resource acquisition will be used by the UART adapter. </p>
<p>UART adapter provides DMA resource access management in order to protect DMA resources from being used by multiple tasks simultaneously. Unsetting this macro will remove this feature, improving performance and potentially reducing code size (if the resource management API is not used by other modules). Unset this macro if, for example, you have exclusively assigned DMA channels to the UART interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga9a8228786b4220f081ce6176a93a2aab" title="Controls whether UART resource acquisition will be used. ">CONFIG_UART_USE_RESMGMT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a8228786b4220f081ce6176a93a2aab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_UART_USE_RESMGMT&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether UART resource acquisition will be used. </p>
<p>UART adapter provides resource access management in order to protect UART resources (devices and buses) from being used by multiple tasks simultaneously. Unsetting this macro will remove this feature, improving performance and potentially reducing code size (if the resource management API is not used by other modules). All acquisition and release UART adapter calls omit calls to the resource management API when this macro is unset.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga5be01d68948b21d2210899e60784bb2f" title="Controls whether DMA resource acquisition will be used by the UART adapter. ">CONFIG_UART_USE_DMA_RESMGMT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga60e617d96d1ccd9d442b62be87ca345c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_BUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_baud_rate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_parity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_stop, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_auto_flow_control, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_use_fifo, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel_tx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel_rx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_fifo_tr_lvl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rx_fifo_tr_lvl&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;extern const void *const name;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry for slave device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>valid values: UART1, UART2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>of uart may be COM1, or something like this </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_baud_rate</td><td>required uart baud rate from enum HW_UART_BAUDRATE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_bits</td><td>value from enum HW_UART_DATABITS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_parity</td><td>value from enum HW_UART_PARITY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_stop</td><td>value from enum HW_UART_STOPBITS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_auto_flow_control</td><td>if 1 auto flow control should be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_use_fifo</td><td>if 1 fifo should be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_tx</td><td>DMA number for tx channel, rx msut have the previous number, pass HW_DMA_CHANNEL_INVALID for no DMA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_rx</td><td>DMA number for rx channel, tx must have the next number, pass HW_DMA_CHANNEL_INVALID for no DMA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_fifo_tr_lvl</td><td>the tx fifo trigger level, valid numbers 0..3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rx_fifo_tr_lvl</td><td>the rx fifo trigger level, valid numbers 0..3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b122f24a1fedd200f145e3fabe53f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_DEV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_baud_rate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_parity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_stop, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_auto_flow_control, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_use_fifo, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel_tx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel_rx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_fifo_tr_lvl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rx_fifo_tr_lvl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_flags&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;extern const void *const name;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry for serial device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>valid values: UART1, UART2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>of uart may be COM1, or something like this </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_baud_rate</td><td>required uart baud rate from enum HW_UART_BAUDRATE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_bits</td><td>value from enum HW_UART_DATABITS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_parity</td><td>value from enum HW_UART_PARITY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_stop</td><td>value from enum HW_UART_STOPBITS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_auto_flow_control</td><td>if 1 auto flow control should be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_use_fifo</td><td>if 1 fifo should be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_tx</td><td>DMA number for tx channel, rx msut have the previous number, pass HW_DMA_CHANNEL_INVALID for no DMA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_rx</td><td>DMA number for rx channel, tx must have the next number, pass HW_DMA_CHANNEL_INVALID for no DMA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_fifo_tr_lvl</td><td>the tx fifo trigger level, valid numbers 0..3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rx_fifo_tr_lvl</td><td>the rx fifo trigger level, valid numbers 0..3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_flags</td><td>run time flags</td></tr>
  </table>
  </dd>
</dl>
<p>This macro creates similar device to UART_BUS, with added flags </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga4c5ede3587564c6c07b2726c3a03b738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structuart__device__config.html">uart_device_config</a>  <a class="el" href="structuart__device__config.html">uart_device_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART bus constant data. </p>
<p>Variable of this type keeps static configuration needed to configure UART bus. Those variables are generated by <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga60e617d96d1ccd9d442b62be87ca345c" title="Entry for slave device. ">UART_BUS()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga5d665822f955a640d0920f312b65a87d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga5d665822f955a640d0920f312b65a87d">AD_UART_DEVICE_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART device flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga5d665822f955a640d0920f312b65a87da2c389faf8f7ab321078427228faf7df0"></a>AD_UART_DEVICE_FLAGS_LOCKING_ASYNC&#160;</td><td class="fielddoc">
<p>If set, calls to <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9">ad_uart_read_async()</a>, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gae193afb0033c24fbcdd28fb75a2d6683">ad_uart_write_async()</a> perform bus acquisition. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga866486e836d2039e6a272e1c7b8d5b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga866486e836d2039e6a272e1c7b8d5b49">AD_UART_RES_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART resource types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga866486e836d2039e6a272e1c7b8d5b49a04e61518eb75b78227fa31ff1127bcce"></a>AD_UART_RES_TYPE_CONFIG&#160;</td><td class="fielddoc">
<p>Configuration resource. Acquiring this resource will block calls to <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> for the same UART bus. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga866486e836d2039e6a272e1c7b8d5b49aed83e45b81798d1dd3ed5f5f37989508"></a>AD_UART_RES_TYPE_WRITE&#160;</td><td class="fielddoc">
<p>Tx (write) resource. Acquiring this resource will block write operations on the same bus. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga866486e836d2039e6a272e1c7b8d5b49ac25932aa3532b3cbefb7e8f24297be68"></a>AD_UART_RES_TYPE_READ&#160;</td><td class="fielddoc">
<p>Rx (read) resource. Acquiring this resource will block read operations on the same bus. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga866486e836d2039e6a272e1c7b8d5b49a55372bdfc03b533ea9cdc68b01cb1a4f"></a>AD_UART_RES_TYPES&#160;</td><td class="fielddoc">
<p>Enumeration end. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga00ea78f7363e4cc20f6694112a2d4c76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_abort_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort previously started asynchronous read. </p>
<p>This function aborts asynchronous read started with </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9" title="Start asynchronous read from UART. ">ad_uart_read_async()</a>. To avoid unpredictable results <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire()</a> must be called before <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9" title="Start asynchronous read from UART. ">ad_uart_read_async()</a>, because <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> can be called from interrupt fired after user code decided to abort read operation. In that case <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> could already release uart for other tasks and calling abort would interfere with next read. If resource is blocked there is no risk of calling abort when read is finishing. User callback will be called only once.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9" title="Start asynchronous read from UART. ">ad_uart_read_async()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga43c84afdc598a9ea42cdc3452f30395a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_bus_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire access to UART bus. </p>
<p>This function waits for UART bus to be available, and locks it for current task's use only. This function can be called several times, but number of <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> calls must match number of calls to this function.</p>
<p>This function should be used if normal <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga2035b1344458d57da35b1a459b83ff7f" title="Read from UART. ">ad_uart_read()</a>, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad3161397e053e5230fca67febc9e2147" title="Write to UART. ">ad_uart_write()</a> are not enough and some other UART controller calls are required. In this case typical usage for this function would look like this:</p>
<p>ad_uart_bus_acquire(dev); id = ad_uart_get_hw_uart_id(dev); ... hw_uart_set...(id, ...); hw_uart_write_buffer(id, ...) ... ad_uart_bus_release(dev);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0dd2fbc3a6a05dc00e62acff0554a84e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_bus_acquire_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga866486e836d2039e6a272e1c7b8d5b49">AD_UART_RES_TYPE</a>&#160;</td>
          <td class="paramname"><em>res_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire specific UART resource and its DMA counterpart. </p>
<p>This is similar to <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire()</a>, but acquires only a specific UART resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">res_type</td><td>resource type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06924897ddd0c212a1eecdc37a7c1ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_bus_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release access to UART bus. </p>
<p>This function decrements acquire counter for this device and when it reaches 0 UART bus is released and can be used by other tasks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga51ea2e8db4293a1f6ca336e178e0016a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_bus_release_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga866486e836d2039e6a272e1c7b8d5b49">AD_UART_RES_TYPE</a>&#160;</td>
          <td class="paramname"><em>res_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release specific UART resource and its DMA counterpart. </p>
<p>This is similar to <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a>, but releases only a specific UART resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">res_type</td><td>resource type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga846fba0a733d6a6d5c4f06a8d1217ecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close UART device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>handle to device opened with <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0faa76f2466e015b640f47be37888179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_uart_complete_async_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish asynchronous read. </p>
<p>Asynchronous reads allow to create reads with timeouts, after requested number of characters arrive user callback is executed from ISR. At any moment after read is started application can decide that if less than requested characters were received, read request should end. In such case application code should call <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga0faa76f2466e015b640f47be37888179" title="Finish asynchronous read. ">ad_uart_complete_async_read()</a> to get number of characters read. This function must be called when task still owns bus, it means that application code calls </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire()</a> explicitly before calling </dd>
<dd>
ad_uart_async_read(). After calling this function application code can release bus with </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number for successfully read characters</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9" title="Start asynchronous read from UART. ">ad_uart_read_async()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f8ee4d7d02f58dbdca2609808d264cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HW_UART_ID ad_uart_get_hw_uart_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART controller id. </p>
<p>This function returns id that can be used to get UART controller id. This id is argument for lower level functions starting with hw_uart_ prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id that can be used with hw_uart_... functions </dd></dl>

</div>
</div>
<a class="anchor" id="ga07cb703a8b6387af205368cbd3de0fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> ad_uart_open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad9957354b1c342143b9b03457533fef3">uart_device_id</a>&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open UART device. </p>
<p>First call to this function will configure UART block. Later calls from other tasks will just return handle to already initialized UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>identifier as passed to to <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga60e617d96d1ccd9d442b62be87ca345c" title="Entry for slave device. ">UART_BUS()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>device handle that can be used with other functions </dd></dl>

</div>
</div>
<a class="anchor" id="ga2035b1344458d57da35b1a459b83ff7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_uart_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OS_TICK_TIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from UART. </p>
<p>This function reads rlen bytes from UART. This function is blocking. It can wait first for bus access, then it waits till transaction is completed. If timeout is OS_EVENT_FOREVER, exactly <code>rlen</code> bytes must be received. If timeout is specified, function can exit after timeout with less bytes than requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>pointer to data to be read from UART </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>time in ticks to wait for data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, 0 if no data arrived in specified time</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga846fba0a733d6a6d5c4f06a8d1217ecb" title="Close UART device. ">ad_uart_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaacc22af2273d137b69f7afaf775fd3f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gac855b4d7df3f7f93bb8010d85295879f">ad_uart_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous read from UART. </p>
<p>This function sets up read of <code>rlen</code> bytes from UART. The supplied callback is called when the operation finishes. If <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gga5d665822f955a640d0920f312b65a87da2c389faf8f7ab321078427228faf7df0">AD_UART_DEVICE_FLAGS_LOCKING_ASYNC</a> flag has been set for the associated device, this function will also perform bus acquisition. In that case and in order to avoid being blocked, the user should call <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire()</a> beforehand. The bus will be released just before user callback is executed.</p>
<p>When read operation is started, user must not release memory pointer <code>rbuf</code>.</p>
<p>To abort started read operation <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga00ea78f7363e4cc20f6694112a2d4c76" title="Abort previously started asynchronous read. ">ad_uart_abort_read_async()</a> should be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>pointer to data to be read from UART </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>function to call after write is finished or aborted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>pointer to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga846fba0a733d6a6d5c4f06a8d1217ecb" title="Close UART device. ">ad_uart_close()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga00ea78f7363e4cc20f6694112a2d4c76" title="Abort previously started asynchronous read. ">ad_uart_abort_read_async()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The callback is called from within UART ISR and at that time resources are released</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3161397e053e5230fca67febc9e2147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to UART. </p>
<p>This function performs write to UART. This function is blocking. It can wait first for bus access, then it waits till transaction is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>pointer to data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga846fba0a733d6a6d5c4f06a8d1217ecb" title="Close UART device. ">ad_uart_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae193afb0033c24fbcdd28fb75a2d6683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gac855b4d7df3f7f93bb8010d85295879f">ad_uart_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous write to UART. </p>
<p>This function sets up write of <code>wlen</code> bytes to UART. When write is done user callback <code>cb</code> will be called just after <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> is called. When write operation is started, user must not release memory pointer <code>wbuf</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>pointer to data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>function to call after write finishes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>pointer to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga846fba0a733d6a6d5c4f06a8d1217ecb" title="Close UART device. ">ad_uart_close()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The callback is called from within UART ISR and at that time resources are released</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 19 2018 07:50:05 for SmartSnippets DA1468x/DA15xxx SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
