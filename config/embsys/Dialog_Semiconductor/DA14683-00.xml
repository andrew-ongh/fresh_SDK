<?xml version="1.0" encoding="ascii"?>
<!-- File naming: Dialog_DA14680BB.svd -->
<!--
  Copyright (C) 2017 Dialog Semiconductor.
  This computer program includes Confidential, Proprietary Information  
  of Dialog Semiconductor. All Rights Reserved.

  Purpose: System Viewer Description (SVD) Example (Schema Version 1.2)
           This is a description of a none-existent and incomplete device
		   for demonstration purposes only.

  Generated by cmsis-svd (version 0.2), d.d. June 14, 2017 - 11:30:27
 -->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <vendor>Dialog</vendor>                   				    <!-- device vendor name -->
  <vendorID>ARM</vendorID>                                        <!-- device vendor short name -->
  <name>DA14680BB</name>                                          <!-- name of part-->
  <series>DA14680BB</series>                                         <!-- device series the device belongs to -->
  <version>1.2</version>                                          <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  <description>Applies for DA14682/3-00, DA15XXX-00</description>
  <licenseText><!-- this license text will appear in header file. \n forces line breaks -->
	Dialog GmbH (DLG) is supplying this software for use with Cortex-M\n
	processor based microcontroller, but can be equally used for other\n
	suitable  processor architectures. This file can be freely distributed.\n
	Modifications to this file shall be clearly marked.\n
	\n
	THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED\n
	OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF\n
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.\n
	ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR\n
	CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
</licenseText>
  <cpu><!-- details about the cpu embedded in the device (SVD version 1.2,  see https://www.keil.com/pack/doc/CMSIS/SVD/html/group__cpu_section__gr.html) -->
    <name>CM0</name>
    <revision>r1p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
		
  </cpu>
  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
  <width>32</width>                                               <!-- bus width is 32 bits -->
  <!-- default settings implicitly inherited by subsequent sections -->
  <size>32</size>                                                 <!-- this is the default size (number of bits) of all peripherals
																																									 and register that do not define "size" themselves -->
  <access>read-write</access>                                     <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>                             <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>                               <!-- by default all 32Bits of the registers are used -->
	
  <peripherals>
	<peripheral>  
  <name>NVIC</name>
  <version>1.0</version>
  <description>Cortex M0 NVIC registers</description>
  <groupName>NVIC</groupName>
  <baseAddress>0xE000E100</baseAddress>
  <size>0</size>
  <access>ACCESS</access>
  <addressBlock>
		<offset>0</offset>
		<size>0x321</size>
		<usage>registers</usage>
  </addressBlock>
  <registers>
	<register>
	  <name>ISER</name>
	  <description>Interrupt set-enable register</description>
	  <addressOffset>0x00000000</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[0:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[1:1]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn</name>
		  <description>FTDF_WAKEUP_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[2:2]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn</name>
		  <description>FTDF_GEN_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[3:3]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[4:4]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>COEX_IRQn</name>
		  <description>COEX_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[5:5]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>CRYPTO_IRQn</name>
		  <description>CRYPTO_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[6:6]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>MRM_IRQn</name>
		  <description>MRM_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[7:7]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[8:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[9:9]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[10:10]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C2_IRQn</name>
		  <description>I2C2_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[11:11]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[12:12]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SPI2_IRQn</name>
		  <description>SPI2_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[13:13]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[14:14]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[15:15]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>IRGEN_IRQn</name>
		  <description>IRGEN_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[16:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn</name>
		  <description>WKUP_GPIO_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[17:17]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM0_IRQn</name>
		  <description>SWTIM0_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[18:18]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM1_IRQn</name>
		  <description>SWTIM1_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[19:19]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>QUADEC_IRQn</name>
		  <description>QUADEC_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[20:20]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>USB_IRQn</name>
		  <description>USB_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[21:21]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[22:22]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>SRC_IN_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[23:23]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>SRC_OUT_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[24:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>VBUS_IRQn</name>
		  <description>VBUS_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[25:25]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[26:26]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RF_DIAG_IRQn</name>
		  <description>RF_DIAG_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[27:27]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>TRNG_IRQn</name>
		  <description>TRNG_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[28:28]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DCDC_IRQn</name>
		  <description>DCDC_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[29:29]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn</name>
		  <description>XTAL16RDY_IRQn (Interrupt set-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[30:30]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>Rsvd__irq__n</name>
		  <description>Rsvd__irq__n (Reserved)</description>
		  <access>read-write</access>
		  <bitRange>[31:31]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ICER</name>
	  <description>Interrupt clear-enable register</description>
	  <addressOffset>0x00000080</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[0:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[1:1]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn</name>
		  <description>FTDF_WAKEUP_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[2:2]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn</name>
		  <description>FTDF_GEN_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[3:3]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[4:4]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>COEX_IRQn</name>
		  <description>COEX_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[5:5]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>CRYPTO_IRQn</name>
		  <description>CRYPTO_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[6:6]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>MRM_IRQn</name>
		  <description>MRM_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[7:7]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[8:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[9:9]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[10:10]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C2_IRQn</name>
		  <description>I2C2_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[11:11]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[12:12]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SPI2_IRQn</name>
		  <description>SPI2_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[13:13]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[14:14]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[15:15]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>IRGEN_IRQn</name>
		  <description>IRGEN_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[16:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn</name>
		  <description>WKUP_GPIO_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[17:17]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM0_IRQn</name>
		  <description>SWTIM0_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[18:18]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM1_IRQn</name>
		  <description>SWTIM1_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[19:19]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>QUADEC_IRQn</name>
		  <description>QUADEC_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[20:20]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>USB_IRQn</name>
		  <description>USB_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[21:21]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[22:22]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>SRC_IN_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[23:23]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>SRC_OUT_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[24:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>VBUS_IRQn</name>
		  <description>VBUS_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[25:25]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[26:26]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RF_DIAG_IRQn</name>
		  <description>RF_DIAG_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[27:27]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>TRNG_IRQn</name>
		  <description>TRNG_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[28:28]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DCDC_IRQn</name>
		  <description>DCDC_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[29:29]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn</name>
		  <description>XTAL16RDY_IRQn (Interrupt clear-enable bit)</description>
		  <access>read-write</access>
		  <bitRange>[30:30]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>Rsvd__irq__n</name>
		  <description>Rsvd__irq__n (Reserved)</description>
		  <access>read-write</access>
		  <bitRange>[31:31]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ISPR</name>
	  <description>Interrupt set-pending register</description>
	  <addressOffset>0x00000100</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[0:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[1:1]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn</name>
		  <description>FTDF_WAKEUP_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[2:2]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn</name>
		  <description>FTDF_GEN_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[3:3]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[4:4]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>COEX_IRQn</name>
		  <description>COEX_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[5:5]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>CRYPTO_IRQn</name>
		  <description>CRYPTO_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[6:6]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>MRM_IRQn</name>
		  <description>MRM_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[7:7]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[8:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[9:9]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[10:10]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C2_IRQn</name>
		  <description>I2C2_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[11:11]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[12:12]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SPI2_IRQn</name>
		  <description>SPI2_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[13:13]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[14:14]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[15:15]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>IRGEN_IRQn</name>
		  <description>IRGEN_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[16:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn</name>
		  <description>WKUP_GPIO_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[17:17]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM0_IRQn</name>
		  <description>SWTIM0_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[18:18]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM1_IRQn</name>
		  <description>SWTIM1_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[19:19]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>QUADEC_IRQn</name>
		  <description>QUADEC_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[20:20]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>USB_IRQn</name>
		  <description>USB_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[21:21]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[22:22]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>SRC_IN_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[23:23]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>SRC_OUT_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[24:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>VBUS_IRQn</name>
		  <description>VBUS_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[25:25]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[26:26]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RF_DIAG_IRQn</name>
		  <description>RF_DIAG_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[27:27]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>TRNG_IRQn</name>
		  <description>TRNG_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[28:28]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DCDC_IRQn</name>
		  <description>DCDC_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[29:29]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn</name>
		  <description>XTAL16RDY_IRQn (Interrupt set-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[30:30]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>Rsvd__irq__n</name>
		  <description>Rsvd__irq__n (Reserved)</description>
		  <access>read-write</access>
		  <bitRange>[31:31]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ICPR</name>
	  <description>Interrupt clear-pending register</description>
	  <addressOffset>0x00000180</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn</name>
		  <description>BLE_WAKEUP_LP_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[0:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>BLE_GEN_IRQn</name>
		  <description>BLE_GEN_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[1:1]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn</name>
		  <description>FTDF_WAKEUP_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[2:2]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn</name>
		  <description>FTDF_GEN_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[3:3]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RFCAL_IRQn</name>
		  <description>RFCAL_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[4:4]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>COEX_IRQn</name>
		  <description>COEX_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[5:5]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>CRYPTO_IRQn</name>
		  <description>CRYPTO_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[6:6]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>MRM_IRQn</name>
		  <description>MRM_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[7:7]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>UART_IRQn</name>
		  <description>UART_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[8:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>UART2_IRQn</name>
		  <description>UART2_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[9:9]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C_IRQn</name>
		  <description>I2C_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[10:10]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C2_IRQn</name>
		  <description>I2C2_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[11:11]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SPI_IRQn</name>
		  <description>SPI_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[12:12]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SPI2_IRQn</name>
		  <description>SPI2_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[13:13]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>ADC_IRQn</name>
		  <description>ADC_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[14:14]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>KEYBRD_IRQn</name>
		  <description>KEYBRD_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[15:15]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>IRGEN_IRQn</name>
		  <description>IRGEN_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[16:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn</name>
		  <description>WKUP_GPIO_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[17:17]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM0_IRQn</name>
		  <description>SWTIM0_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[18:18]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM1_IRQn</name>
		  <description>SWTIM1_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[19:19]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>QUADEC_IRQn</name>
		  <description>QUADEC_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[20:20]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>USB_IRQn</name>
		  <description>USB_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[21:21]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PCM_IRQn</name>
		  <description>PCM_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[22:22]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SRC_IN_IRQn</name>
		  <description>SRC_IN_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[23:23]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SRC_OUT_IRQn</name>
		  <description>SRC_OUT_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[24:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>VBUS_IRQn</name>
		  <description>VBUS_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[25:25]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DMA_IRQn</name>
		  <description>DMA_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[26:26]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RF_DIAG_IRQn</name>
		  <description>RF_DIAG_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[27:27]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>TRNG_IRQn</name>
		  <description>TRNG_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[28:28]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DCDC_IRQn</name>
		  <description>DCDC_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[29:29]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn</name>
		  <description>XTAL16RDY_IRQn (Interrupt clear-pending bit)</description>
		  <access>read-write</access>
		  <bitRange>[30:30]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>Rsvd__irq__n</name>
		  <description>Rsvd__irq__n (Reserved)</description>
		  <access>read-write</access>
		  <bitRange>[31:31]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR0</name>
	  <description>Interrupt priority register 0</description>
	  <addressOffset>0x00000300</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>BLE_WAKEUP_LP_IRQn_prio</name>
		  <description>BLE_WAKEUP_LP_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[7:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>BLE_GEN_IRQn_prio</name>
		  <description>BLE_GEN_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[15:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_WAKEUP_IRQn_prio</name>
		  <description>FTDF_WAKEUP_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[23:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>FTDF_GEN_IRQn_prio</name>
		  <description>FTDF_GEN_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR1</name>
	  <description>Interrupt priority register 1</description>
	  <addressOffset>0x00000304</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>RFCAL_IRQn_prio</name>
		  <description>RFCAL_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[7:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>COEX_IRQn_prio</name>
		  <description>COEX_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[15:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>CRYPTO_IRQn_prio</name>
		  <description>CRYPTO_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[23:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>MRM_IRQn_prio</name>
		  <description>MRM_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR2</name>
	  <description>Interrupt priority register 2</description>
	  <addressOffset>0x00000308</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>UART_IRQn_prio</name>
		  <description>UART_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[7:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>UART2_IRQn_prio</name>
		  <description>UART2_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[15:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C_IRQn_prio</name>
		  <description>I2C_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[23:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>I2C2_IRQn_prio</name>
		  <description>I2C2_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR3</name>
	  <description>Interrupt priority register 3</description>
	  <addressOffset>0x0000030C</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>SPI_IRQn_prio</name>
		  <description>SPI_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[7:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SPI2_IRQn_prio</name>
		  <description>SPI2_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[15:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>ADC_IRQn_prio</name>
		  <description>ADC_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[23:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>KEYBRD_IRQn_prio</name>
		  <description>KEYBRD_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR4</name>
	  <description>Interrupt priority register 4</description>
	  <addressOffset>0x00000310</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>IRGEN_IRQn_prio</name>
		  <description>IRGEN_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[7:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>WKUP_GPIO_IRQn_prio</name>
		  <description>WKUP_GPIO_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[15:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM0_IRQn_prio</name>
		  <description>SWTIM0_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[23:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SWTIM1_IRQn_prio</name>
		  <description>SWTIM1_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR5</name>
	  <description>Interrupt priority register 5</description>
	  <addressOffset>0x00000314</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>QUADEC_IRQn_prio</name>
		  <description>QUADEC_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[7:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>USB_IRQn_prio</name>
		  <description>USB_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[15:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PCM_IRQn_prio</name>
		  <description>PCM_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[23:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SRC_IN_IRQn_prio</name>
		  <description>SRC_IN_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR6</name>
	  <description>Interrupt priority register 6</description>
	  <addressOffset>0x00000318</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>SRC_OUT_IRQn_prio</name>
		  <description>SRC_OUT_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[7:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>VBUS_IRQn_prio</name>
		  <description>VBUS_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[15:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DMA_IRQn_prio</name>
		  <description>DMA_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[23:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RF_DIAG_IRQn_prio</name>
		  <description>RF_DIAG_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>IPR7</name>
	  <description>Interrupt priority register 7</description>
	  <addressOffset>0x0000031C</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>TRNG_IRQn_prio</name>
		  <description>TRNG_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[7:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>DCDC_IRQn_prio</name>
		  <description>DCDC_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[15:8]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>XTAL16RDY_IRQn_prio</name>
		  <description>XTAL16RDY_IRQn[7:0] bits (Interrupt priority)</description>
		  <access>read-write</access>
		  <bitRange>[23:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>RESERVED31_IRQn_DONT_USE</name>
		  <description>RESERVED31_IRQn[7:0] bits (Reserved)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
  </registers>
</peripheral><peripheral>
  <name>SCB</name>
  <version>1.0</version>
  <description>Cortex M0 SCB registers</description>
  <groupName>SCB</groupName>
  <baseAddress>0xE000ED00</baseAddress>
  <size>0</size>
  <access>ACCESS</access>
  <addressBlock>
		<offset>0</offset>
		<size>0x29</size>
		<usage>registers</usage>
  </addressBlock>
  <registers>
	<register>
	  <name>CPUID</name>
	  <description>CPUID base register</description>
	  <addressOffset>0x00000000</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x410CC200</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>REVISION</name>
		  <description>REVISION[3:0] bits (Revision number)</description>
		  <access>read-only</access>
		  <bitRange>[3:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PARTNO</name>
		  <description>PARTNO[11:0] bits (Part number of the processor core)</description>
		  <access>read-only</access>
		  <bitRange>[15:4]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>CONSTANT</name>
		  <description>CONSTANT[3:0] bits (Reads as 0xF)</description>
		  <access>read-only</access>
		  <bitRange>[19:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>VARIANT</name>
		  <description>VARIANT[3:0] bits (Variant number)</description>
		  <access>read-only</access>
		  <bitRange>[23:20]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>IMPLEMENTER</name>
		  <description>IMPLEMENTER[7:0] bits (Implementer code)</description>
		  <access>read-only</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>ICSR</name>
	  <description>Interrupt control and state register</description>
	  <addressOffset>0x00000004</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>VECTACTIVE</name>
		  <description>VECTACTIVE[5:0] bits (Active vector)</description>
		  <access>read-write</access>
		  <bitRange>[5:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>VECTPENDING</name>
		  <description>VECTPENDING[5:0] bits (Pending vector)</description>
		  <access>read-write</access>
		  <bitRange>[17:12]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>ISRPENDING</name>
		  <description>Interrupt pending flag, excluding NMI and Faults</description>
		  <access>read-write</access>
		  <bitRange>[22:22]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PENDSTCLR</name>
		  <description>SysTick exception clear-pending bit</description>
		  <access>read-write</access>
		  <bitRange>[25:25]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PENDSTSET</name>
		  <description>SysTick exception set-pending bit</description>
		  <access>read-write</access>
		  <bitRange>[26:26]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PENDSVCLR</name>
		  <description>PendSV clear-pending bit</description>
		  <access>read-write</access>
		  <bitRange>[27:27]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PENDSVSET</name>
		  <description>PendSV set-pending bit</description>
		  <access>read-write</access>
		  <bitRange>[28:28]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>NMIPENDSET</name>
		  <description>NMI set-pending bit</description>
		  <access>read-write</access>
		  <bitRange>[31:31]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>AIRCR</name>
	  <description>Application interrupt and reset control register</description>
	  <addressOffset>0x0000000C</addressOffset>
	  <size>32</size>
	  <access>read-only</access>
	  <resetValue>0xFA050000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>VECTRESET</name>
		  <description>Reserved for Debug use</description>
		  <access>read-only</access>
		  <bitRange>[0:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>VECTCLRACTIVE</name>
		  <description>Reserved for Debug use</description>
		  <access>read-only</access>
		  <bitRange>[1:1]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SYSRESETREQ</name>
		  <description>System reset request</description>
		  <access>read-only</access>
		  <bitRange>[2:2]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>ENDIANESS</name>
		  <description>Data endianness bit</description>
		  <access>read-only</access>
		  <bitRange>[15:15]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>VECTKEY</name>
		  <description>VECTKEY[15:0] bits (Register key)</description>
		  <access>read-only</access>
		  <bitRange>[31:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>SCR</name>
	  <description>System control register</description>
	  <addressOffset>0x00000010</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>SLEEPONEXIT</name>
		  <description>Configures sleep-on-exit when returning from Handler mode to Thread mode</description>
		  <access>read-write</access>
		  <bitRange>[1:1]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SLEEPDEEP</name>
		  <description>Controls whether the processor uses sleep or deep sleep</description>
		  <access>read-write</access>
		  <bitRange>[2:2]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SEVEONPEND</name>
		  <description>Send event on pending bit</description>
		  <access>read-write</access>
		  <bitRange>[4:4]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>CCR</name>
	  <description>Configuration and control register</description>
	  <addressOffset>0x00000014</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000204</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>UNALIGN_TRP</name>
		  <description>Enables unaligned access traps</description>
		  <access>read-write</access>
		  <bitRange>[3:3]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>STKALIGN</name>
		  <description>Configures stack alignment on exception entry</description>
		  <access>read-write</access>
		  <bitRange>[9:9]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>SHPR2</name>
	  <description>System handler priority register 2</description>
	  <addressOffset>0x0000001C</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>PRI_11</name>
		  <description>PRI_11[7:0] bits (Priority of system handler 11, SVCall)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>SHPR3</name>
	  <description>System handler priority register 3</description>
	  <addressOffset>0x00000020</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>PRI_14</name>
		  <description>PRI_14[7:0] bits (Priority of system handler 14, PendSV)</description>
		  <access>read-write</access>
		  <bitRange>[23:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>PRI_15</name>
		  <description>PRI_15[7:0] bits (Priority of system handler 15, SysTick exception)</description>
		  <access>read-write</access>
		  <bitRange>[31:24]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
  </registers>
</peripheral><peripheral>
  <name>SysTick</name>
  <version>1.0</version>
  <description>Cortex M0 SysTick registers</description>
  <groupName>SYSTICK</groupName>
  <baseAddress>0xE000E010</baseAddress>
  <size>0</size>
  <access>ACCESS</access>
  <addressBlock>
		<offset>0</offset>
		<size>0x11</size>
		<usage>registers</usage>
  </addressBlock>
  <registers>
	<register>
	  <name>CTRL</name>
	  <description>SysTick Control and Status register</description>
	  <addressOffset>0x00000000</addressOffset>
	  <size>32</size>
	  <access>read-write</access>
	  <resetValue>0x00000004</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>ENABLE</name>
		  <description>SysTick Counter enable</description>
		  <access>read-write</access>
		  <bitRange>[0:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>TICKINT</name>
		  <description>SysTick exception request enable</description>
		  <access>read-write</access>
		  <bitRange>[1:1]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>CLKSOURCE</name>
		  <description>Clock source selection</description>
		  <access>read-write</access>
		  <bitRange>[2:2]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>COUNTFLAG</name>
		  <description>Timer counted to 0 since last time this was read</description>
		  <access>read-write</access>
		  <bitRange>[16:16]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>LOAD</name>
	  <description>SysTick Reload value register</description>
	  <addressOffset>0x00000004</addressOffset>
	  <size>32</size>
	  <access>read-write<!--==(HARDCODED)==--></access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>RELOAD</name>
		  <description>RELOAD[23:0] bits (Reload value)</description>
		  <access>read-write</access>
		  <bitRange>[23:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>VAL</name>
	  <description>SysTick Current value register</description>
	  <addressOffset>0x00000008</addressOffset>
	  <size>32</size>
	  <access>read-write<!--==(HARDCODED)==--></access>
	  <resetValue>0x00000000</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>CURRENT</name>
		  <description>CURRENT[23:0] bits (Current counter value)</description>
		  <access>read-write</access>
		  <bitRange>[23:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
	<register>
	  <name>CALIB</name>
	  <description>SysTick Calibration value register</description>
	  <addressOffset>0x0000000C</addressOffset>
	  <size>32</size>
	  <access>read-only<!--==(HARDCODED)==--></access>
	  <resetValue>0x00002328</resetValue>
	  <resetMask>0xffffffff</resetMask>
	  <fields>
		<field>
		  <name>TENMS</name>
		  <description>TENMS[23:0] bits (Calibration value)</description>
		  <access>read-only</access>
		  <bitRange>[23:0]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>SKEW</name>
		  <description>Indicates whether the TENMS value is exact</description>
		  <access>read-only</access>
		  <bitRange>[30:30]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
		<field>
		  <name>NOREF</name>
		  <description>Indicates that a separate reference clock is provided</description>
		  <access>read-only</access>
		  <bitRange>[31:31]</bitRange>
		  <enumeratedValues>
			<name>ENUM</name>
		  </enumeratedValues>
		</field>
	  </fields>
	</register>
  </registers>
</peripheral><peripheral>
	<name>AES_HASH</name>
	<version>1.0</version>
	<description>AES_HASH registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40020000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>260</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>CRYPTO_CLRIRQ_REG</name>
	<description>Crypto Clear interrupt request</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_CLRIRQ</name>
	<description>Write 1 to clear a pending interrupt request.</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_CTRL_REG</name>
	<description>Crypto Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_AES_KEXP</name>
	<description>It forces (active high) the execution of the key expansion process with the starting of the AES encryption/decryption process. The bit will be cleared automatically by the hardware, after the completion of the AES key expansion process.</description>
	<access>read-write</access>
	<bitRange>[17:17]</bitRange>
	
</field><field>
	<name>CRYPTO_MORE_IN</name>
	<description>0 - Define that this is the last input block. When the current input is consumed by the crypto engine and the output data is written to the memory, the calculation ends (CRYPTO_INACTIVE goes to one).
1 - The current input data block is not the last. More input data will follow. When the current input is consumed, the engine stops and waits for more data (CRYPTO_WAIT_FOR_IN goes to one).</description>
	<access>read-write</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>CRYPTO_HASH_OUT_LEN</name>
	<description>The number of bytes minus one of the hash result which will be saved at the memory by the DMA. In relation with the selected hash algorithm the accepted values are:
MD5: 0..15 -&gt; 1-16 bytes
SHA-1: 0..19 -&gt; 1-20 bytes
SHA-256: 0..31 -&gt; 1 - 32 bytes
SHA-256/224: 0..27 -&gt; 1- 28 bytes
SHA-384: 0..47 -&gt; 1 - 48 bytes
SHA-512: 0..63 -&gt; 1 - 64 bytes
SHA-512/224: 0..27 -&gt; 1- 28 bytes
SHA-512/256: 0..31 -&gt; 1 - 32 bytes</description>
	<access>read-write</access>
	<bitRange>[15:10]</bitRange>
	
</field><field>
	<name>CRYPTO_HASH_SEL</name>
	<description>Selects the type of the algorithm
0 - The encryption algorithm (AES)
1 - A hash algorithm.
The exact algorithm is defined by the fileds CRYPTO_ALG and CRYPTO_ALG_MD.</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>CRYPTO_IRQ_EN</name>
	<description>Interrupt Request Enable
0 - The interrupt generation ability is disabled.
1 - The interrupt generation ability is enabled. Generates an interrupt request at the end of operation.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>CRYPTO_ENCDEC</name>
	<description>Encryption/Decryption
0 - Decryption
1 - Encryption</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>CRYPTO_AES_KEY_SZ</name>
	<description>The size of AES Key
00 - 128 bits AES Key
01 - 192 bits AES Key
10 - 256 bits AES Key
11 - 256 bits AES Key</description>
	<access>read-write</access>
	<bitRange>[6:5]</bitRange>
	
</field><field>
	<name>CRYPTO_OUT_MD</name>
	<description>Output Mode. This field makes sense only when the AES algorithm is selected (CRYPTO_HASH_SEL =0)
0 - Write back to memory all the resulting data
1 - Write back to memory only the final block of the resulting data</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>CRYPTO_ALG_MD</name>
	<description>It defines the mode of operation of the AES algorithm when the controller is configured for an encryption/decryption processing (CRYPTO_HASH_SEL = 0).
00 - ECB
01 - ECB
10 - CTR
11 - CBC

When the controller is configured to applies a HASH function, this field selects the desired HASH algorithm with the help of the CRYPTO_ALG.

00 - HASH algorithms that are based on 32 bits operations
01 - HASH algorithms that are based on 64 bits operations
10 - Reserved
11 - Reserved

See also the CRYPTO_ALG field.</description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>CRYPTO_ALG</name>
	<description>Algorithm selection. When CRYPTO_HASH_SEL = 0 the only available choice is the AES algorithm.
00 - AES
01 - Reserved
10 - Reserved
11 - Reserved

When CRYPTO_HASH_SEL = 1, this field selects the desired hash algorithms, with the help of the CRYPTO_ALG_MD field.

If CRYPTO_ALG_MD = 00
00 - MD5
01 - SHA-1
10 - SHA-256/224
11 - SHA-256

If CRYPTO_ALG_MD = 01
00 - SHA-384
01 - SHA-512
10 - SHA-512/224
11 - SHA-512/256


</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_DEST_ADDR_REG</name>
	<description>Crypto DMA destination memory</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_DEST_ADDR</name>
	<description>Destination address at where the result of the processing is stored. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_FETCH_ADDR_REG</name>
	<description>Crypto DMA fetch register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_FETCH_ADDR</name>
	<description>The memory address from where will be retrieved the data that will be processed. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_KEYS_START</name>
	<description>Crypto First position of the AES keys storage memory</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_KEY_X</name>
	<description>CRYPTO_KEY_(0-63)
This is the AES keys storage memory. This memory is accessible via AHB slave interface, only when the CRYPTO is inactive (CRYPTO_INACTIVE = 1).</description>
	<access>write-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_LEN_REG</name>
	<description>Crypto Length of the input block in bytes</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_LEN</name>
	<description>It contains the number of bytes of input data. If this number is not a multiple of a block size, the data is automatically extended with zeros. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<access>read-write</access>
	<bitRange>[23:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_MREG0_REG</name>
	<description>Crypto Mode depended register 0</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_MREG0</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[31:0]
CTR - CTRBLK[31:0]. It is the initial value of the 32 bits counter.
At any other mode, the contents of this register has no meaning.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_MREG1_REG</name>
	<description>Crypto Mode depended register 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_MREG1</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[63:32]
CTR - CTRBLK[63:32]
At any other mode, the contents of this register has no meaning.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_MREG2_REG</name>
	<description>Crypto Mode depended register 2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_MREG2</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[95:64]
CTR - CTRBLK[95:64]
At any other mode, the contents of this register has no meaning.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_MREG3_REG</name>
	<description>Crypto Mode depended register 3</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_MREG3</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[127:96]
CTR - CTRBLK[127:96]
At any other mode, the contents of this register has no meaning.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_START_REG</name>
	<description>Crypto Start calculation</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_START</name>
	<description>Write 1 to initiate the processing of the input data. This register is auto-cleared.</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CRYPTO_STATUS_REG</name>
	<description>Crypto Status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CRYPTO_IRQ_ST</name>
	<description>The status of the interrupt request line of the CRYPTO block.
0 - There is no active interrupt request.
1 - An interrupt request is pending.</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CRYPTO_WAIT_FOR_IN</name>
	<description>Indicates the situation where the engine waits for more input data. This is applicable when the CRYPTO_MORE_IN= 1, so the input data are fragmented in the memory.
0 - The crypto is not waiting for more input data.
1 - The crypto waits for more input data.
The CRYPTO_INACTIVE flag remains to zero to indicate that the calculation is not finished. The supervisor of the CRYPTO must program to the CRYPTO_FETCH_ADDR and CRYPTO_LEN a new input data fragment. The calculation will be continued as soon as the CRYPTO_START register will be written with 1. This action will clear the CRYPTO_WAIT_FOR_IN flag.</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>CRYPTO_INACTIVE</name>
	<description>0 - The CRYPTO is active. The processing is in progress.
1 - The CRYPTO is inactive. The processing has finished.</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>ANAMISC</name>
	<version>1.0</version>
	<description>ANAMISC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001b00</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>104</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>ANA_TEST_REG</name>
	<description>Analog test registers</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ACORE_TESTBUS_EN</name>
	<description>TBD</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TEST_STRUCTURE</name>
	<description>4 bits to select which test-structure is mapped on P1[7]
0 : open
1 : VDD (1.2V)
2 : 10uA into 66k = 5/3 x 40k (W/L=0.45/22.33)
3 : 1uA into 700k = 18.5 x 40k (W/L=0.45/22.33)
4 : 1uA(same as going into 700k)
5 : AVS (0V)
6 : 5uA into nMOST (svt) 2x1u/110n
7 : 5uA into nMOST (hvt) 2x1u/110n
8 : 5uA into nMOST (UD18) 2x1u/260n
9 : 5uA into nMOST (OD33) 2x1u/500n
a : 7.5uA into nMOST (na25) 4x1u/1.2u
b : 5uA into nMOST (0vt) 4x1u/300n
c : VDD - 5uA from pMOST (svt) 2x1u/110n
d : VDD - 5uA from pMOST (hvt) 2x1u/110n
e : VDD - 5uA from pMOST (OD33) 2x1u/400n
f : VDD - 5uA from pMOST (UD18) 2x1u/260n </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHARGER_CTRL1_REG</name>
	<description>Charger control register 1</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00002000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DIE_TEMP_DISABLE</name>
	<description>0: Die temperature protection enabled: charger will be disabled when die temp exceeds value set in DIE_TEMP_SET
1: Die temperature protection disabled: testmode, use only in agreement with Dialog</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>DIE_TEMP_SET</name>
	<description>Die temperature protection level.
Charging will be automatically disabled if set level is exceeded and resumed when temperature has dropped few degrees below set level.
00: 0oC (do not use, for test only)
01: 50oC (do not use, for test only)
10: 80oC (default)
11: 100oC</description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>CHARGE_CUR</name>
	<description>Constant Current levels (typical values)
0000: 5 mA
0001: 10 mA
0010: 30 mA
0011: 45 mA
0100: 60 mA
0101: 90 mA
0110: 120 mA
0111: 150 mA
1000: 180 mA
1001: 210 mA
1010: 270 mA
1011: 300 mA
1100: 350 mA
1101: 400 mA </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>NTC_LOW_DISABLE</name>
	<description>0: Normal operation: voltage level higher than 7/8 VDD_USB will disable the charger
1: NTC low temp limit disabled: use if trickle charging below the minimum temperature is required </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>NTC_DISABLE</name>
	<description>0: Charger NTC protection enabled
1: Charger NTC protection disable</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>CHARGE_ON</name>
	<description>0: Charger in powerdown
1: Charger enabled </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>CHARGE_LEVEL</name>
	<description>Constant Voltage Levels
00000: 3.00V (reset)
00001: 3.40V (e.g. 2xNiMH)
00010: 3.50V
00011: 3.60V (e.g. Li-phosphate)
00100: 3.74V
00101: 3.86V
00110: 4.00V
00111: 4.05V
01000: 4.10V
01001: 4.15V
01010: 4.20V (e.g. Li-Co, Li-Mn, NMC)
01011: 4.25V
01100: 4.30V
01101: 4.35V
01110: 4.40V
01111: 4.50V
10000: 4.60V
10001: 4.90V e.g. 3xNiMH
10010: 5.00V</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHARGER_CTRL2_REG</name>
	<description>Charger control register 2</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000f07</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CHARGER_TEST</name>
	<description>Signals are mapped on SPDIF pin.
Also set ANA_TEST_REG[ANA_TESTBUS_TO_ADCPIN] = 1

000: normal mode (no test selected)
001: Vptat (temperature sensor) [1.4V max]
010: Vbat_sense after divider [1.2V]
011: Current loop output [0 to vsupply]
100: Voltage loop output [0 to vsupply]
101: Imeas or Iref/10
110: Icharge reduced by 26.6
111: reserved</description>
	<access>read-write</access>
	<bitRange>[15:13]</bitRange>
	
</field><field>
	<name>CURRENT_OFFSET_TRIM</name>
	<description>do not change, for test purpose only</description>
	<access>read-write</access>
	<bitRange>[12:8]</bitRange>
	
</field><field>
	<name>CHARGER_VFLOAT_ADJ</name>
	<description>Independent adjustment for the charge level. Adjust range is +/- 1.8%. The 4 bits adjustment is in two's complement.</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>CURRENT_GAIN_TRIM</name>
	<description>do not change, for test purpose only</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHARGER_STATUS_REG</name>
	<description>Charger status and trimming register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ff7f</resetMask>
	<fields>
	<field>
	<name>CHARGER_TMODE_PROT</name>
	<description>0: Dietemp below DIE_TEMP_SET level. Normal operation
1: Dietemp above DIE_TEMP_SET level. Charging is disabled</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>CHARGER_BATTEMP_HIGH</name>
	<description>0: Battery pack temperature 'ok' or 'too low' (voltage level on NTC pin above 1/2 VDD_USB)
1: Battery pack temperature 'too high' (voltage level on NTC pin below 1/2 VDD_USB)</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>CHARGER_BATTEMP_OK</name>
	<description>0: Battery pack temperature 'too low' or 'too high' (voltage level on NTC pin below 1/2 or above 7/8 VDD_USB)
1: Battery pack temperature 'ok' (voltage level on NTC pin between 1/2 and 7/8 VDD_USB)</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>CHARGER_BATTEMP_LOW</name>
	<description>0: Battery pack temperature 'ok' or 'too high' (voltage level on NTC pin below 7/8 VDD_USB)
1: Battery pack temperature 'too low' (voltage level on NTC pin above than 7/8 VDD_USB)</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>END_OF_CHARGE</name>
	<description>0: Actual charge current is between 10...100% of set CHARGE_CUR (or CHARGE_ON=0)
1: Actual charge current &lt;10% of set CHARGE_CUR</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CHARGER_CV_MODE</name>
	<description>0: voltage loop not in regulation (or charger is off)
1: constant voltage mode active, voltage loop in regulation. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>CHARGER_CC_MODE</name>
	<description>0: current loop not in regulation (or charger is off)
1: constant current mode active, current loop in regulation. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_REF_CNT_REG</name>
	<description>Count value for oscillator calibration</description>
	<addressOffset>0x00000062</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REF_CNT_VAL</name>
	<description>Indicates the calibration time, with a decrement counter to 1. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_REF_SEL_REG</name>
	<description>Select clock for oscillator calibration</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REF_CAL_START</name>
	<description>Writing a '1' starts a calibration. This bit is cleared when calibration is finished, and CLK_REF_VAL is ready. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>REF_CLK_SEL</name>
	<description>Select clock input for calibration:
0x0 : RC32K oscillator
0x1 : RC16M oscillator
0x2 : XTAL32K oscillator
0x3 : RCX oscillator</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_REF_VAL_H_REG</name>
	<description>DIVN reference cycles, upper 16 bits</description>
	<addressOffset>0x00000066</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the upper 16 bits of DIVN clock cycles counted during the calibration time, defined with REF_CNT_VAL </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_REF_VAL_L_REG</name>
	<description>DIVN reference cycles, lower 16 bits</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the lower 16 bits of DIVN clock cycles counted during the calibration time, defined with REF_CNT_VAL </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_ADD2CH_REG</name>
	<description>Fuel Gauge manually add extra charge to SOC_CHARGE_CNTRx_REG</description>
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SOC_ADD2CH</name>
	<description>Extra charge to be added to the SOC_CHARGE_CNTRx_REG per sample period (9-bit + sign + 6 fractional bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_CHARGE_AVG_REG</name>
	<description>Fuel Gauge Average charge counter</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CHARGE_AVG</name>
	<description>Average of 'charge' current (9-bit + sign and 6 fractional bits </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_CHARGE_CNTR1_REG</name>
	<description>Fuel Gauge Charge counter bits 15-0</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CHARGE_CNT1</name>
	<description>Sum of the charge-values per sampling period; (bits15:0)
The absolute full-scale charge value is 6-bits, At full scale charge current it takes 2^26 sampling periods until overflow of the charge_cnt register after a reset_charge event.
At fs=144kHz (=default) this will happen after 33 hours
At fs=1.152MHz After 10 hours </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_CHARGE_CNTR2_REG</name>
	<description>Fuel Gauge Charge counter bits 31-16</description>
	<addressOffset>0x0000004a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CHARGE_CNT2</name>
	<description>Sum of the charge-values per sampling period; (bits23:16) </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_CHARGE_CNTR3_REG</name>
	<description>Fuel Gauge Charge counter bits 39-32</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CHARGE_CNT3</name>
	<description>Sum of the charge-values per sampling period; (bits39:24) </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_CTRL1_REG</name>
	<description>Fuel Gauge Control register 1</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000d880</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SOC_CINT</name>
	<description>Integrator capacitor scaler
0: Cint = 1 pF
1: Cint = 2 pF
2: Cint = 4 pF
3: Cint = 8 pF (=default) </description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>SOC_BIAS</name>
	<description>Current DAC scaler
0: Ibias = 2 uA
1: Ibias = 1 uA (=default)
2: Ibias = 0.5 uA
3: Ibias = 0.25 uA </description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>SOC_CLK</name>
	<description>SOC Sample frequency
0: automatic mode (tbd)
1: fs = 18 kHz
2: fs = 36 kHz
3: fs = 72 kHz
4: fs = 144 kHz (=default)
5: fs = 288 kHz
6: fs = 576 kHz
7: fs = 1152 kHz </description>
	<access>read-write</access>
	<bitRange>[11:9]</bitRange>
	
</field><field>
	<name>SOC_LPF</name>
	<description>0: low-pass filter at integrator inputs disabled
1: Enables a low-pass filter at the integrator inputs </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>SOC_IDAC</name>
	<description>Scales the current DAC (Ibias: default=1uA)
0: Idac=0.25*Ibias
1: Idac=0.5*Ibias
2: Idac=Ibias (=default)
3: Idac=2*Ibias</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>SOC_SIGN</name>
	<description>Defines the sign of the charge converter input and output to perform a chopper function to eliminate offset voltage (see also SOC_CHOP and 'sign' on output pin)
0: non-inverted inputs and outputs
1: inverted inputs and outputs</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>SOC_GPIO</name>
	<description>Reserved (not yet implemented): switches the SOC-inputs to the GPIO pins</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>SOC_MUTE</name>
	<description>0: Normal operation
1: Connect the input voltage to 0V </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SOC_RESET_AVG</name>
	<description>1: Reset the SOC_CHARGE_AVG_REG to the last value of SOC_CHARGE_CNTRx_REG </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SOC_RESET_CHARGE</name>
	<description>1: Reset CHARGE_CNTR_REG </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SOC_ENABLE</name>
	<description>0: SOC analog circuits off. CHARGE_CNTRx_REG can still be written for a manual update.
See SOC_ADD2CH_REG
1: SOC analog circuits enabled </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_CTRL2_REG</name>
	<description>Fuel Gauge Control register 2</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000776a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SOC_DYNAVG</name>
	<description>if HIGH then 'weight' of Moving Average is forced to 1 if the converter detects significant input change
(if dcharge &gt; 4*delta_c, or high_limit, or low_limit) </description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>SOC_MAW</name>
	<description>Moving Average Weight factor
charge_avg(n) =
(weight*charge_avg(n-1) + charge(n) ) / (weight+1) where:weight = 2^(soc_maw) </description>
	<access>read-write</access>
	<bitRange>[14:12]</bitRange>
	
</field><field>
	<name>SOC_CMIREG_ENABLE</name>
	<description>SOC_CMIREG enable</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>SOC_CHOP</name>
	<description>Chopping control
0: 'external' chopping control with 'soc_sign'-input
1: chop each 2^1*scycle fs-periods
2: chop each 2^2*scycle fs-periods
..
7: chop each 2^7*scycle fs-periods. </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>SOC_ICM</name>
	<description>adds a common-mode current to Idac to increase the common-mode input-level of the integrator.
The common-mode input level is equal to (Idac+Icm)*Rvi;
0: Icm=0;
1: Icm=1*Ibias (=default);
2: Icm=2*Ibias;
3: Icm=4*Ibias</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>SOC_DCYCLE</name>
	<description>Cycle the current divider segments of Idac
0: no cycling
1: cycle each scycle fs-periods </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>SOC_SCYCLE</name>
	<description>Cycle current segments (8 segments) of Idac
0: no cycling
1: cycle each fs-period
2: cycle each 2 fs-periods
..
7: cycle each 7 fs-periods </description>
	<access>read-write</access>
	<bitRange>[4:2]</bitRange>
	
</field><field>
	<name>SOC_RVI</name>
	<description>Voltage-to-current resistor scaler
0: Rvi = 25 k
1: Rvi = 50 k
2: Rvi = 100 k (= default)
3: Rvi = 200 k </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_CTRL3_REG</name>
	<description>Fuel Gauge Control register 3</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000011</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SOC_VCMI</name>
	<description>Common Input Voltage target of regulator (see SOC_CMIREG_ENABLE)
0: 50 mV
1: 100 mV
2: 150 mV
3: 200 mV</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>SOC_DYNHYS</name>
	<description>Reserved. (To be implemented)
Hysteresis of the comparator which detects if the integrator voltage is rising or falling </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SOC_DYNTARG</name>
	<description>Reserved. (To be implemented)
0: Vint_target = 0V
1: Vint_target tracks the 2 MSB's of the charge register) </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SOC_VSAT</name>
	<description>Trigger level of the high-limit and low-limit comparators.
0: low_limit = -50mV; high_limit = +50mV
1: low_limit = -100mV; high_limit = +100mV (=default)
2: low_limit = -200mV; high_limit = +200mV
3: low_limit = -400mV; high_limit = +400mV</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_EXT_IN_REG</name>
	<description>Fuel Gauge input test register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SOC_EXT_IDAC_EN</name>
	<description>1: Enable 'external' control of Idac</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>SOC_EXT_SCYCLE_EN</name>
	<description>1: Enable 'external' control of scycle</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>SOC_NR_SCYCLE</name>
	<description>Number of the scycle </description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>SOC_RDAC_DIS</name>
	<description>0: Disables the resistor divider DAC. The Idac has 6-bits (plus sign)
1: Enables the resistor divider DAC. The Idac has 9-bits (plus sign)</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>SOC_IDAC_SIGN</name>
	<description>0: SOC_IDAC_VAL is positive
1: SOC_IDAC_VAL is negative</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>SOC_IDAC_VAL</name>
	<description>Controls the current for the DAC.
0: 0/512*SOC_IDAC
N: N/512*SOC_IDAC</description>
	<access>read-write</access>
	<bitRange>[8:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_EXT_OUT_REG</name>
	<description>Fuel Gauge output test register</description>
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SOC_CTRL_EVENT</name>
	<description>Controller event </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>SOC_STATE</name>
	<description>Controller state </description>
	<access>read-only</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>SOC_RISING_COMP</name>
	<description>Rising comparator output </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SOC_POS_COMP</name>
	<description>Positive comparator output </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SOC_LOWLIM_COMP</name>
	<description>Low_limit comparator output </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SOC_HIGH_LIM</name>
	<description>High_limit comparator output </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SOC_STATUS_REG</name>
	<description>Fuel Gauge Status register</description>
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SOC_INT_LOCKED</name>
	<description>0: Normal Operation
1: Integrator is pushed over high or low limit.
Returns to '0' if the converter runs for more than 2 sequential sampling periods in a 'safe' region (dcharge &lt; 2*delta_c) </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SOC_INT_OVERLOAD</name>
	<description>0: Normal Operation
1: Integrator exceeds high or low limit with full-scale IDAC (charge) for more than 3 sequential sampling periods </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>APU</name>
	<version>1.0</version>
	<description>APU registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50004000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>276</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>APU_MUX_REG</name>
	<description>APU mux register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>PDM1_MUX_IN</name>
	<description>PDM1 input mux
0 = SRC1_MUX_IN
1 = PDM input</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>PCM1_MUX_IN</name>
	<description>PCM1 input mux
0 = off
1 = SRC1 output
2 = PCM output registers</description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>SRC1_MUX_IN</name>
	<description>SRC1 input mux
0 = off
1 = PCM output
2 = SRC1 input registers</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEF0A_SET1_REG</name>
	<description>SRC coefficient 10 set 1</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000041f2</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRC_COEF10</name>
	<description>coefficient 10</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEF10_SET1_REG</name>
	<description>SRC coefficient 1,0 set 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x79a99278</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_COEF1</name>
	<description>coefficient 1</description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>SRC_COEF0</name>
	<description>coefficient 0</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEF32_SET1_REG</name>
	<description>SRC coefficient 3,2 set 1</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x6d568b41</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_COEF3</name>
	<description>coefficient 3</description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>SRC_COEF2</name>
	<description>coefficient 2</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEF54_SET1_REG</name>
	<description>SRC coefficient 5,4 set 1</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_COEF5</name>
	<description>coefficient 5</description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>SRC_COEF4</name>
	<description>coefficient 4 </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEF76_SET1_REG</name>
	<description>SRC coefficient 7,6 set 1</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_COEF7</name>
	<description>coefficient 7
</description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>SRC_COEF6</name>
	<description>coefficient 6</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEF98_SET1_REG</name>
	<description>SRC coefficient 9,8 set 1</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_COEF9</name>
	<description>coefficient 9</description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>SRC_COEF8</name>
	<description>coefficient 8</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PCM1_CTRL_REG</name>
	<description>PCM1 Control register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PCM_FSC_DIV</name>
	<description>PCM Framesync divider, Values 7-0xFFF. To divide by N, write N-1. (Minimum value N-1=7 for 8 bits PCM_FSC)
Note if PCM_CLK_BIT=1, N must always be even</description>
	<access>read-write</access>
	<bitRange>[31:20]</bitRange>
	
</field><field>
	<name>PCM_FSC_EDGE</name>
	<description>0: shift channels 1, 2, 3, 4, 5, 6, 7, 8 after PCM_FSC edge
1: shift channels 1, 2, 3, 4 after PCM_FSC edge shift channels 5, 6, 7, 8 after opposite PCM_FSC edge </description>
	<access>read-write</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>PCM_CH_DEL</name>
	<description>Channel delay in multiples of 8 bits </description>
	<access>read-write</access>
	<bitRange>[15:11]</bitRange>
	
</field><field>
	<name>PCM_CLK_BIT</name>
	<description>0:One clock cycle per data bit
1:Two cloc cycles per data bit</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PCM_FSCINV</name>
	<description>0: PCM FSC
1: PCM FSC inverted</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>PCM_CLKINV</name>
	<description>0:PCM CLK
1:PCM CLK inverted</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>PCM_PPOD</name>
	<description>0:PCM DO push pull
1:PCM DO open drain</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>PCM_FSCDEL</name>
	<description>0:PCM FSC starts one cycle before MSB bit
1:PCM FSC starts at the same time as MSB bit</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>PCM_FSCLEN</name>
	<description>0:PCM FSC length equal to 1 data bit
N:PCM FSC length equal to N*8 </description>
	<access>read-write</access>
	<bitRange>[5:2]</bitRange>
	
</field><field>
	<name>PCM_MASTER</name>
	<description>0:PCM interface in slave mode
1:PCM interface in master mode</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>PCM_EN</name>
	<description>0:PCM interface disabled
1:PCM interface enabled</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PCM1_IN1_REG</name>
	<description>PCM1 data in 1</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PCM_IN</name>
	<description>PCM1_IN1 bits 31-0 </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PCM1_IN2_REG</name>
	<description>PCM1 data in 2</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PCM_IN</name>
	<description>PCM1_IN2 bits 31-0 </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PCM1_OUT1_REG</name>
	<description>PCM1 data out 1</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PCM_OUT</name>
	<description>PCM1_OUT1 bits 31-0 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PCM1_OUT2_REG</name>
	<description>PCM1 data out 2</description>
	<addressOffset>0x00000110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PCM_OUT</name>
	<description>PCM1_OUT2 bits 31-0 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SRC1_CTRL_REG</name>
	<description>SRC1 control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_PDM_DO_DEL</name>
	<description>PDM_DO output delay line
0: no delay
1: 14 ns
2: 20 ns
3: 26 ns</description>
	<access>read-write</access>
	<bitRange>[31:30]</bitRange>
	
</field><field>
	<name>SRC_PDM_MODE</name>
	<description>PDM Output mode selection on PDM_DO1
00: No output
01: Right channel (falling edge of PDM_CLK)
10: Left channel (rising edge of PDM_CLK)
11: Left and Right channel</description>
	<access>read-write</access>
	<bitRange>[29:28]</bitRange>
	
</field><field>
	<name>SRC_PDM_DI_DEL</name>
	<description>PDM_DI input delay line
0: no delay
1: 6 ns
2: 12 ns
3: 18 ns</description>
	<access>read-write</access>
	<bitRange>[27:26]</bitRange>
	
</field><field>
	<name>SRC_OUT_FLOWCLR</name>
	<description>Writing a 1 clears the SRC1_OUT Overflow/underflow bits 23-22. No more over/underflow indications while bit is 1. Keep 1 until the over/under flow bit is cleared </description>
	<access>write-only</access>
	<bitRange>[25:25]</bitRange>
	
</field><field>
	<name>SRC_IN_FLOWCLR</name>
	<description>Writing a 1 clears the SRC1_IN Overflow/underflow bits 21-20. No more over/underflow indications while bit is 1. Keep 1 until the over/under flow bit is cleared </description>
	<access>write-only</access>
	<bitRange>[24:24]</bitRange>
	
</field><field>
	<name>SRC_OUT_UNFLOW</name>
	<description>1 = SRC1_OUT Underflow occurred </description>
	<access>read-only</access>
	<bitRange>[23:23]</bitRange>
	
</field><field>
	<name>SRC_OUT_OVFLOW</name>
	<description>1 = SRC1_OUT Overflow occurred </description>
	<access>read-only</access>
	<bitRange>[22:22]</bitRange>
	
</field><field>
	<name>SRC_IN_UNFLOW</name>
	<description>1 = SRC1_IN Underflow occurred </description>
	<access>read-only</access>
	<bitRange>[21:21]</bitRange>
	
</field><field>
	<name>SRC_IN_OVFLOW</name>
	<description>1 = SRC1_IN Overflow occurred </description>
	<access>read-only</access>
	<bitRange>[20:20]</bitRange>
	
</field><field>
	<name>SRC_RESYNC</name>
	<description>1 = SRC will restart synchronisation</description>
	<access>write-only</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>SRC_OUT_OK</name>
	<description>SRC1_OUT Status
0: acquisition in progress
1: acquisition ready (In manual mode this bit is always 1)</description>
	<access>read-only</access>
	<bitRange>[18:18]</bitRange>
	
</field><field>
	<name>SRC_OUT_US</name>
	<description>SRC1_OUT UpSampling IIR filters setting
00: for sample rates up-to 48kHz
01: for sample rates of 96kHz
10: reserved
11: for sample rates of 192kHz</description>
	<access>read-write</access>
	<bitRange>[17:16]</bitRange>
	
</field><field>
	<name>SRC_OUT_CAL_BYPASS</name>
	<description>SRC1_OUT1 upsampiling filter bypass
0:Do not bypass
1:Bypass filter</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>SRC_OUT_AMODE</name>
	<description>SRC1_OUT1 Automatic Conversion mode
0:Manual mode
1:Automatic mode</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>SRC_DITHER_DISABLE</name>
	<description>Dithering feature
0: Enable
1: Disable</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SRC_IN_OK</name>
	<description>SRC1_IN status
0: Acquisition in progress
1: Acquisition ready</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>SRC_IN_DS</name>
	<description>SRC1_IN UpSampling IIR filters setting
00: for sample rates up-to 48kHz
01: for sample rates of 96kHz
10: reserved
11: for sample rates of 192kHz</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>SRC_IN_CAL_BYPASS</name>
	<description>SRC1_IN upsampeling filter bypass
0: Do not bypass
1: Bypass filter</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SRC_IN_AMODE</name>
	<description>SRC1_IN Automatic conversion mode
0: Manual mode
1: Automatic mode</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SRC_EN</name>
	<description>SRC1_IN and SRC1_OUT enable
0: disabled
1: enabled</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SRC1_IN1_REG</name>
	<description>SRC1 data in 1</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_IN</name>
	<description>SRC1_IN1 </description>
	<access>read-write</access>
	<bitRange>[31:8]</bitRange>
	
</field></fields>
</register><register>
	<name>SRC1_IN2_REG</name>
	<description>SRC1 data in 2</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_IN</name>
	<description>SRC1_IN2 </description>
	<access>read-write</access>
	<bitRange>[31:8]</bitRange>
	
</field></fields>
</register><register>
	<name>SRC1_IN_FS_REG</name>
	<description>SRC1 Sample input rate</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_IN_FS</name>
	<description>SRC_IN Sample rate
SRC_IN_FS = 8192*Sample_rate/100
Sample_rate upper limit is 192kHz. For 96kHz and 192kHz SRC_CTRLx_REG[SRC_IN_DS] must be set as shown below:

Sample_rate SRC_IN_FS SRC_IN_DS Audio bandwidth
8000 Hz 0xA0000 0 4000 Hz
11025 Hz 0x0DC800 0 5512 Hz
16000 Hz 0x140000 0 8000 Hz
22050 Hz 0x1B9000 0 11025 Hz
32000 Hz 0x280000 0 16000 Hz
44100 Hz 0x372000 0 22050 Hz
48000 Hz 0x3C0000 0 24000 Hz
96000 Hz 0x3C0000 1 24000 Hz
192000 Hz 0x3C0000 3 24000 Hz

In manual SRC mode, SRC_IN_FS can be set and adjusted to the desired sample rate at any time.
In automatic mode the SRC returns the final sample rate as soon as SRC_IN_OK. Note that SRC_DS is not calculated in automatic mode and must be set manually automatic mode with Sample_rate of 96 and 192kHz.</description>
	<access>read-write</access>
	<bitRange>[23:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SRC1_OUT1_REG</name>
	<description>SRC1 data out 1</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_OUT</name>
	<description>SRC1_OUT1 </description>
	<access>read-only</access>
	<bitRange>[31:8]</bitRange>
	
</field></fields>
</register><register>
	<name>SRC1_OUT2_REG</name>
	<description>SRC1 data out 2</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_OUT</name>
	<description>SRC1_OUT2 </description>
	<access>read-only</access>
	<bitRange>[31:8]</bitRange>
	
</field></fields>
</register><register>
	<name>SRC1_OUT_FS_REG</name>
	<description>SRC1 Sample output rate</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SRC_OUT_FS</name>
	<description>SRC_OUT Sample rate
SRC_OUT_FS = 8192*Sample_rate/100
Sample_rate upper limit is 192kHz. For 96kHz and 192kHz SRC_CTRLx_REG[SRC_DS] must be set as shown below:

Sample_rate SRC_OUT_FS  SRC_OUT_DS Audio bandwidth
8000 Hz     0xA0000     0          4000 Hz
11025 Hz    0x0DC800    0          5512 Hz
16000 Hz    0x140000    0          8000 Hz
22050 Hz    0x1B9000    0          11025 Hz
32000 Hz    0x280000    0          16000 Hz
44100 Hz    0x372000    0          22050 Hz
48000 Hz    0x3C0000    0          24000 Hz
96000 Hz    0x3C0000    1          24000 Hz
192000 Hz   0x3C0000    3          24000 Hz

In manual SRC mode, SRC_OUT_FS can be set and adjusted to the desired sample rate at any time.
In automatic mode the SRC returns the final sample rate as soon as SRC_OUT_OK. Note that SRC_DS is not calculated in automatic mode and must be set manually automatic mode with Sample_rate of 96 and 192kHz.</description>
	<access>read-write</access>
	<bitRange>[23:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>BLE</name>
	<version>1.0</version>
	<description>BLE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40000000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>532</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>BLE_ACTSCANSTAT_REG</name>
	<description>Active scan register</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00010001</resetValue>
	<resetMask>0x01ff01ff</resetMask>
	<fields>
	<field>
	<name>BACKOFF</name>
	<description>Active scan mode back-off counter initialization value. </description>
	<access>read-only</access>
	<bitRange>[24:16]</bitRange>
	
</field><field>
	<name>UPPERLIMIT</name>
	<description>Active scan mode upper limit counter value. </description>
	<access>read-only</access>
	<bitRange>[8:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_ADVCHMAP_REG</name>
	<description>Advertising Channel Map</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields>
	<field>
	<name>ADVCHMAP</name>
	<description>Advertising Channel Map, defined as per the advertising connection settings. Contains advertising channels index 37 to 39. If ADVCHMAP[i] equals:
0: Do not use data channel i+37.
1: Use data channel i+37. </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_ADVTIM_REG</name>
	<description>Advertising Packet Interval</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>ADVINT</name>
	<description>Advertising Packet Interval defines the time interval in between two ADV_xxx packet sent. Value is in us.
Value to program depends on the used Advertising Packet type and the device filtering policy. </description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_AESCNTL_REG</name>
	<description>Start AES register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>AES_MODE</name>
	<description>0: Cipher mode
1: Decipher mode</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>AES_START</name>
	<description>Writing a 1 starts AES-128 ciphering/deciphering process.
This bit is reset once the process is finished (i.e. ble_crypt_irq interrupt occurs, even masked) </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_AESKEY127_96_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>AESKEY127_96</name>
	<description>AES encryption 128-bit key. Bit 127 down to 96 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_AESKEY31_0_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>AESKEY31_0</name>
	<description>AES encryption 128-bit key. Bit 31 down to 0 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_AESKEY63_32_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>AESKEY63_32</name>
	<description>AES encryption 128-bit key. Bit 63 down to 32 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_AESKEY95_64_REG</name>
	<description>AES encryption key</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>AESKEY95_64</name>
	<description>AES encryption 128-bit key. Bit 95 down to 64 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_AESPTR_REG</name>
	<description>Pointer to the block to encrypt/decrypt</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>AESPTR</name>
	<description>Pointer to the memory zone where the block to cipher/decipher using AES-128 is stored. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_BASETIMECNTCORR_REG</name>
	<description>Base Time Counter</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields>
	<field>
	<name>BASETIMECNTCORR</name>
	<description>Base Time Counter correction value. </description>
	<access>read-write</access>
	<bitRange>[26:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_BASETIMECNT_REG</name>
	<description>Base time reference counter</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields>
	<field>
	<name>BASETIMECNT</name>
	<description>Value of the 625us base time reference counter. Updated each time SAMPCLK is written. Used by the SW in order to synchronize with the HW </description>
	<access>read-only</access>
	<bitRange>[26:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_BDADDRL_REG</name>
	<description>BLE device address LSB register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>BDADDRL</name>
	<description>Bluetooth Low Energy Device Address. LSB part.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_BDADDRU_REG</name>
	<description>BLE device address MSB register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields>
	<field>
	<name>PRIV_NPUB</name>
	<description>Bluetooth Low Energy Device Address privacy indicator
0: Public Bluetooth Device Address
1: Private Bluetooth Device Address </description>
	<access>read-write</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>BDADDRU</name>
	<description>Bluetooth Low Energy Device Address. MSB part. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_BLEMPRIO0_REG</name>
	<description>Coexistence interface Priority 0 Register</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3489adef</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>BLEM7</name>
	<description>Set Priority value for Passive Scanning </description>
	<access>read-write</access>
	<bitRange>[31:28]</bitRange>
	
</field><field>
	<name>BLEM6</name>
	<description>Set Priority value for Non-Connectable Advertising </description>
	<access>read-write</access>
	<bitRange>[27:24]</bitRange>
	
</field><field>
	<name>BLEM5</name>
	<description>Set Priority value for Connectable Advertising BLE message </description>
	<access>read-write</access>
	<bitRange>[23:20]</bitRange>
	
</field><field>
	<name>BLEM4</name>
	<description>Set Priority value for Active Scanning BLE message </description>
	<access>read-write</access>
	<bitRange>[19:16]</bitRange>
	
</field><field>
	<name>BLEM3</name>
	<description>Set Priority value for Initiating (Scanning) BLE message </description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>BLEM2</name>
	<description>Set Priority value for Data Channel transmission BLE message </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>BLEM1</name>
	<description>Set Priority value for LLCP BLE message </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>BLEM0</name>
	<description>Set Priority value for Initiating (Connection Request Response) BLE message </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_BLEMPRIO1_REG</name>
	<description>Coexistence interface Priority 1 Register</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x30000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>BLEMDEFAULT</name>
	<description>Set default priority value for other BLE message than those defined above </description>
	<access>read-write</access>
	<bitRange>[31:28]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_CNTL2_REG</name>
	<description>BLE Control Register 2</description>
	<addressOffset>0x00000200</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>BLE_TRANSACTION_START</name>
	<description>The value will be compared with the FINECNT in order to assert the BLE_TRANSACTION signal towards the COEX block. The deassertion of BLE_TRANSACTION is triggered by the deassertion of BLE_EVENT_IN_PROCESS. Refer also to BLE_TRANSACTION_MODE, BLE_TRANSACTION_SRC and BLE_PTI_SOURCE_SEL bitfields.
If the desired distance from TX_EN/RX_EN is RADIO_PWRDN and TXRXPWRUP=max(TXPWRUP, RXPWRUP), then this bitfield must be set to (RADIO_PWRDN + TXRXPWRUP-1) if CS.FCNTOFFSET is "0", otherwise it must be set to (RADIO_PWRDN + TXRXPWRUP-1 - CS.FCNTOFFSET-1). 
Remark: BLE_EVENT_IN_PROCESS is controlled by the BLE_TIMGENCNTL_REG.PREFETCH_TIME, so the BLE_TRANSACTION_START should be less than the PREFETCH_TIME.</description>
	<access>read-write</access>
	<bitRange>[31:22]</bitRange>
	
</field><field>
	<name>BLE_RSSI_SEL</name>
	<description>0: Select Peak-hold RSSI value (default).
1: Select current Average RSSI value. </description>
	<access>read-write</access>
	<bitRange>[21:21]</bitRange>
	
</field><field>
	<name>WAKEUPLPSTAT</name>
	<description>The status of the BLE_WAKEUP_LP_IRQ. The Interrupt Service Routine of BLE_WAKEUP_LP_IRQ should return only when the WAKEUPLPSTAT is cleared.
Note that BLE_WAKEUP_LP_IRQ is automatically acknowledged after the power up of the Radio Subsystem, plus one Low Power Clock period. </description>
	<access>read-only</access>
	<bitRange>[20:20]</bitRange>
	
</field><field>
	<name>SW_RPL_SPI</name>
	<description>Keep to 0. </description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>BB_ONLY</name>
	<description>Keep to 0.</description>
	<access>read-write</access>
	<bitRange>[18:18]</bitRange>
	
</field><field>
	<name>BLE_PTI_SOURCE_SEL</name>
	<description>0: Provide to COEX block the PTI value indicated by the Control Structure. Recommended value is "0".
1: Provide to COEX block the PTI value generated dynamically by the BLE core, which is based on the PTI of the Control Structure.</description>
	<access>read-write</access>
	<bitRange>[17:17]</bitRange>
	
</field><field>
	<name>BLE_TRANSACTION_MODE</name>
	<description>0: Keep the BLE_TRANSACTION constant during the process of the current event, regadless of the state of PTI value. Recommended value is "0".
1: Create a one clock cycle of low period at the BLE_TRANSACTION whenever a change in the PTI value is detected.
(refer also to BLE_PTI_SOURCE_SEL)</description>
	<access>read-write</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>BLE_TRANSACTION_SRC</name>
	<description>0: Assert the BLE_TRANSACTION at the moment indicated by the BLE_TRANSACTION_START only if the PTI value is available at that moment, otherwise assert BLE_TRANSACTION at the next positive edge of TX_EN ot RX_EN. Recommended value is "0".
1: Assert the BLE_TRANSACTION at the moment indicated by the BLE_TRANSACTION_START, if during this moment the BLE_EVENT_IN_PROCESS is asserted, otherwise assert BLE_TRANSACTION at the next positive edge of TX_EN ot RX_EN. Useful when COEX_CTRL_REG[SEL_BLE_PTI]=0.</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>BLE_CLK_SEL</name>
	<description>BLE Clock Select.
Specifies the BLE master clock absolute frequency in MHz.
Typical values are 16 and 8.
Value depends on the selected XTAL frequency and the value of CLK_RADIO_REG[BLE_DIV] bitfield. For example, if XTAL oscillates at 16MHz and CLK_RADIO_REG[BLE_DIV] = 1 (divide by 2), then BLE master clock frequency is 8MHz and BLE_CLK_SEL should be set to value 8.
The selected BLE master clock frequency (affected by BLE_DIV and BLE_CLK_SEL) must be modified and set only during the initialization time, i.e. before setting BLE_RWBTLECNTL_REG[RWBLE_EN] to 1.
Refer also to BLE_RWBTLECONF_REG[CLK_SEL].</description>
	<access>read-write</access>
	<bitRange>[14:9]</bitRange>
	
</field><field>
	<name>RADIO_PWRDN_ALLOW</name>
	<description>This active high signal indicates when it is allowed for the BLE core (embedded in the Radio sub-System power domain) to be powered down.
After the assertion of the BLE_DEEPSLCNTL_REG[DEEP_SLEEP_ON] a hardware sequence based on the Low Power clock will cause the assertion of RADIO_PWRDN_ALLOW. The RADIO_PWRDN_ALLOW will be cleared to "0" when the BLE core exits from the sleep state, i.e. when the BLE_SLP_IRQ will be asserted.</description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>MON_LP_CLK</name>
	<description>The SW can only write a "0" to this bit.
Whenever a positive edge of the low power clock used by the BLE Timers is detected, then the HW will automatically set this bit to "1". This functionality will not work if BLE Timer is in reset state (refer to CLK_RADIO_REG[BLE_LP_RESET]).
This bit can be used for SW synchronization, to debug the low power clock, etc.</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>BLE_CLK_STAT</name>
	<description>0: BLE uses low power clock
1: BLE uses master clock </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BLE_DIAG_OVR_SEL</name>
	<description>Effective only when BLE_CNTL2_REG[ BLE_DIAG_OVR ] is set to '1', providing the values of P1[0] and P1[2] diagnostic signals:
P1[0] will provide the logical OR of all Cortex M0 IRQ lines, regadless of the BLE_DIAG_OVR_SEL value.
P1[2] will provide the value according to the BLE_DIAG_OVR_SEL value:
00: "low_power_clk" free running clock.
01: "running_at_32k" status.
10: "cortex_deepsleep" status.
11: "deep_sleep_stat_32k" BLE core in sleep mode.</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>BLE_DIAG_OVR</name>
	<description>1: Overrule the P1[0] and P1[2] control signals PAD_LATCH_EN to always "1" and the direction to always "output". It can be used in combination with the BLE_CNTL2_REG[ BLE_DIAG_OVR_SEL ] to provide diagnostic signals on P1[0] and P1[2] even while the system is in power down state.
0: The PAD_LATCH_EN and direction of P1[0] and P1[2] pins are not overruled.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>EMACCERRMSK</name>
	<description>Exchange Memory Access Error Mask:
When cleared to "0" the EM_ACC_ERR will not cause an BLE_ERROR_IRQ interrupt.
When set to "1" an BLE_ERROR_IRQ will be generated as long as EM_ACC_ERR is "1". </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>EMACCERRACK</name>
	<description>Exchange Memory Access Error Acknowledge.
When the SW writes a "1" to this bit then the EMACCERRSTAT bit will be cleared.
When the SW writes "0" it will have no affect.
The read value is always "0". </description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>EMACCERRSTAT</name>
	<description>Exchange Memory Access Error Status:
The bit is read-only and can be cleared only by writing a "1" at EMACCERRACK bitfield.
This bit will be set to "1" by the hardware when the controller will access an EM page that is not mapped according to the EM_MAPPING value.
When this bit is "1" then the BLE_ERROR_IRQ will be asserted as long as EMACCERRMSK is "1". </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_COEXIFCNTL0_REG</name>
	<description>Coexistence interface Control 0 Register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x003300f3</resetMask>
	<fields>
	<field>
	<name>WLCRXPRIOMODE</name>
	<description>Defines Bluetooth Low Energy packet ble_rx mode behavior.
00: Rx indication excluding Rx Power up delay (starts when correlator is enabled)
01: Rx indication including Rx Power up delay
10: Rx High priority indicator
11: n/a</description>
	<access>read-write</access>
	<bitRange>[21:20]</bitRange>
	
</field><field>
	<name>WLCTXPRIOMODE</name>
	<description>Defines Bluetooth Low Energy packet ble_tx mode behavior
00: Tx indication excluding Tx Power up delay
01: Tx indication including Tx Power up delay
10: Tx High priority indicator
11: n/a</description>
	<access>read-write</access>
	<bitRange>[17:16]</bitRange>
	
</field><field>
	<name>WLANTXMSK</name>
	<description>Determines how wlan_tx impact BLE Tx and Rx
00: wlan_tx has no impact (default mode)
01: wlan_tx can stop BLE Tx, no impact on BLE Rx
10: wlan_tx can stop BLE Rx, no impact on BLE Tx
11: wlan_tx can stop both BLE Tx and BLE Rx</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>WLANRXMSK</name>
	<description>Determines how wlan_rx impact BLE Tx and Rx
00: wlan_rx has no impact
01: wlan_rx can stop BLE Tx, no impact on BLE Rx (default mode)
10: wlan_rx can stop BLE Rx, no impact on BLE Tx
11: wlan_rx can stop both BLE Tx and BLE Rx</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>SYNCGEN_EN</name>
	<description>Determines whether ble_sync is generated or not.
0: ble_sync pulse not generated
1: ble_sync pulse generated</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>COEX_EN</name>
	<description>Enable / Disable control of the MWS/WLAN Coexistence control
0: Coexistence interface disabled
1: Coexistence interface enabled</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_COEXIFCNTL1_REG</name>
	<description>Coexistence interface Control 1 Register</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x1f1f7f7f</resetMask>
	<fields>
	<field>
	<name>WLCPRXTHR</name>
	<description>Applies on ble_rx if WLCRXPRIOMODE equals 10
Determines the threshold for Rx priority setting.
If ble_pti[3:0] output value is greater than WLCPRXTHR, then Rx Bluetooth Low Energy priority is considered as high, and must be provided to the WLAN coexistence interface </description>
	<access>read-write</access>
	<bitRange>[28:24]</bitRange>
	
</field><field>
	<name>WLCPTXTHR</name>
	<description>Applies on ble_tx if WLCTXPRIOMODE equals 10
Determines the threshold for priority setting.
If ble_pti[3:0] output value is greater than WLCPTXTHR, then Tx Bluetooth Low Energy priority is considered as high, and must be provided to the WLAN coexistence interface </description>
	<access>read-write</access>
	<bitRange>[20:16]</bitRange>
	
</field><field>
	<name>WLCPDURATION</name>
	<description>Applies on ble_tx if WLCTXPRIOMODE equals 10
Applies on ble_rx if WLCRXPRIOMODE equals 10
Determines how many s the priority information must be maintained
Note that if WLCPDURATION = 0x00, then Tx/Rx priority levels are maintained till Tx/Rx EN are de-asserted. </description>
	<access>read-write</access>
	<bitRange>[14:8]</bitRange>
	
</field><field>
	<name>WLCPDELAY</name>
	<description>Applies on ble_tx if WLCTXPRIOMODE equals 10.
Applies on ble_rx if WLCRXPRIOMODE equals 10.
Determines the delay (in us) in Tx/Rx enables rises the time Bluetooth Low energy Tx/Rx priority has to be provided . </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_CURRENTRXDESCPTR_REG</name>
	<description>Rx Descriptor Pointer for the Receive Buffer Chained List</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>ETPTR</name>
	<description>Exchange Table Pointer that determines the starting point of the Exchange Table</description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>CURRENTRXDESCPTR</name>
	<description>Rx Descriptor Pointer that determines the starting point of the Receive Buffer Chained List </description>
	<access>read-write</access>
	<bitRange>[14:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_DEBUGADDMAX_REG</name>
	<description>Upper limit for the memory zone</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>REG_ADDMAX</name>
	<description>Upper limit for the Register zone indicated by the reg_inzone flag </description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>EM_ADDMAX</name>
	<description>Upper limit for the Exchange Memory zone indicated by the em_inzone flag </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_DEBUGADDMIN_REG</name>
	<description>Lower limit for the memory zone</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>REG_ADDMIN</name>
	<description>Lower limit for the Register zone indicated by the reg_inzone flag </description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>EM_ADDMIN</name>
	<description>Lower limit for the Exchange Memory zone indicated by the em_inzone flag </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_DEEPSLCNTL_REG</name>
	<description>Deep-Sleep control register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>EXTWKUPDSB</name>
	<description>External Wake-Up disable
0: RW-BLE Core can be woken by external wake-up
1: RW-BLE Core cannot be woken up by external wake-up </description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>DEEP_SLEEP_STAT</name>
	<description>Indicator of current Deep Sleep clock mux status:
0: RW-BLE Core is not yet in Deep Sleep Mode
1: RW-BLE Core is in Deep Sleep Mode (only low_power_clk is running) </description>
	<access>read-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>SOFT_WAKEUP_REQ</name>
	<description>Wake Up Request from RW-BLE Software. Applies when system is in Deep Sleep Mode. It wakes up the RW-BLE Core when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>DEEP_SLEEP_CORR_EN</name>
	<description>625us base time reference integer and fractional part correction. Applies when system has been woken-up from Deep Sleep Mode. It enables Fine Counter and Base Time counter when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DEEP_SLEEP_ON</name>
	<description>0: RW-BLE Core in normal active mode
1: Request RW-BLE Core to switch in deep sleep mode.
This bit is reset on DEEP_SLEEP_STAT falling edge. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DEEP_SLEEP_IRQ_EN</name>
	<description>Always set to "3" when DEEP_SLEEP_ON is set to "1".
It controls the generation of BLE_WAKEUP_LP_IRQ. </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_DEEPSLSTAT_REG</name>
	<description>Duration of the last deep sleep phase register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>DEEPSLDUR</name>
	<description>Actual duration of the last deep sleep phase measured in low_power_clk clock cycle. DEEPSLDUR is set to zero at the beginning of the deep sleep phase, and is incremented at each low_power_clk clock cycle until the end of the deep sleep phase. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_DEEPSLWKUP_REG</name>
	<description>Time (measured in Low Power clock cycles) in Deep Sleep Mode before waking-up the device</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>DEEPSLTIME</name>
	<description>Determines the time in low_power_clk clock cycles to spend in Deep Sleep Mode before waking-up the device. This ensures a maximum of 37 hours and 16mn sleep mode capabilities at 32kHz. This ensures a maximum of 36 hours and 16mn sleep mode capabilities at 32.768kHz </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_DIAGCNTL2_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x0000020c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>DIAG7_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>DIAG7</name>
	<description>Only relevant when DIAG7_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG7. </description>
	<access>read-write</access>
	<bitRange>[29:24]</bitRange>
	
</field><field>
	<name>DIAG6_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<access>read-write</access>
	<bitRange>[23:23]</bitRange>
	
</field><field>
	<name>DIAG6</name>
	<description>Only relevant when DIAG6_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG6. </description>
	<access>read-write</access>
	<bitRange>[21:16]</bitRange>
	
</field><field>
	<name>DIAG5_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DIAG5</name>
	<description>Only relevant when DIAG5_EN= 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG5.</description>
	<access>read-write</access>
	<bitRange>[13:8]</bitRange>
	
</field><field>
	<name>DIAG4_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>DIAG4</name>
	<description>Only relevant when DIAG4_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG4.</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_DIAGCNTL3_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x00000210</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>DIAG7_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>DIAG7_BIT</name>
	<description>Selects which bit from the DIAG7 word will be forwarded to bit 7 of the BLE DIagnostic Port.</description>
	<access>read-write</access>
	<bitRange>[30:28]</bitRange>
	
</field><field>
	<name>DIAG6_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<access>read-write</access>
	<bitRange>[27:27]</bitRange>
	
</field><field>
	<name>DIAG6_BIT</name>
	<description>Selects which bit from the DIAG6 word will be forwarded to bit 6 of the BLE DIagnostic Port.</description>
	<access>read-write</access>
	<bitRange>[26:24]</bitRange>
	
</field><field>
	<name>DIAG5_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<access>read-write</access>
	<bitRange>[23:23]</bitRange>
	
</field><field>
	<name>DIAG5_BIT</name>
	<description>Selects which bit from the DIAG5 word will be forwarded to bit 5 of the BLE DIagnostic Port.</description>
	<access>read-write</access>
	<bitRange>[22:20]</bitRange>
	
</field><field>
	<name>DIAG4_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>DIAG4_BIT</name>
	<description>Selects which bit from the DIAG4 word will be forwarded to bit 4 of the BLE DIagnostic Port.</description>
	<access>read-write</access>
	<bitRange>[18:16]</bitRange>
	
</field><field>
	<name>DIAG3_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DIAG3_BIT</name>
	<description>Selects which bit from the DIAG3 word will be forwarded to bit 3 of the BLE DIagnostic Port.</description>
	<access>read-write</access>
	<bitRange>[14:12]</bitRange>
	
</field><field>
	<name>DIAG2_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DIAG2_BIT</name>
	<description>Selects which bit from the DIAG2 word will be forwarded to bit 2 of the BLE DIagnostic Port.</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>DIAG1_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>DIAG1_BIT</name>
	<description>Selects which bit from the DIAG1 word will be forwarded to bit 1 of the BLE DIagnostic Port.</description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>DIAG0_INV</name>
	<description>If set, then the specific diagnostic bit will be inverted.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DIAG0_BIT</name>
	<description>Selects which bit from the DIAG0 word will be forwarded to bit 0 of the BLE DIagnostic Port.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_DIAGCNTL_REG</name>
	<description>Diagnostics Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>DIAG3_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>DIAG3</name>
	<description>Only relevant when DIAG3_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG3. </description>
	<access>read-write</access>
	<bitRange>[29:24]</bitRange>
	
</field><field>
	<name>DIAG2_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<access>read-write</access>
	<bitRange>[23:23]</bitRange>
	
</field><field>
	<name>DIAG2</name>
	<description>Only relevant when DIAG2_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG2. </description>
	<access>read-write</access>
	<bitRange>[21:16]</bitRange>
	
</field><field>
	<name>DIAG1_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DIAG1</name>
	<description>Only relevant when DIAG1_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG1. </description>
	<access>read-write</access>
	<bitRange>[13:8]</bitRange>
	
</field><field>
	<name>DIAG0_EN</name>
	<description>0: Disable diagnostic port 0 output. All outputs are set to 0x0.
1: Enable diagnostic port 0 output. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>DIAG0</name>
	<description>Only relevant when DIAG0_EN = 1.
Selection of the outputs that must be driven to the diagnostic port BLE_DIAG0. </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_DIAGSTAT_REG</name>
	<description>Debug use only</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>DIAG3STAT</name>
	<description>Directly connected to ble_dbg3[7:0] output. Debug use only. </description>
	<access>read-only</access>
	<bitRange>[31:24]</bitRange>
	
</field><field>
	<name>DIAG2STAT</name>
	<description>Directly connected to ble_dbg2[7:0] output. Debug use only. </description>
	<access>read-only</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>DIAG1STAT</name>
	<description>Directly connected to ble_dbg1[7:0] output. Debug use only. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>DIAG0STAT</name>
	<description>Directly connected to ble_dbg0[7:0] output. Debug use only. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_EM_BASE_REG</name>
	<description>Exchange Memory Base Register</description>
	<addressOffset>0x00000208</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>BLE_EM_BASE_16_10</name>
	<description>The physical address on the system memory map of the base of the Exchange Memory.</description>
	<access>read-write</access>
	<bitRange>[16:10]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_ENBPRESET_REG</name>
	<description>Time in low power oscillator cycles register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TWEXT</name>
	<description>Minimum and recommended value is "TWIRQ_RESET + 1".
In the case of wake-up due to an external wake-up request, TWEXT specifies the time delay in low power oscillator cycles to deassert BLE_WAKEUP_LP_IRQ.
Refer also to GP_CONTROL_REG[BLE_WAKEUP_REQ].
Range is [0...64 ms] for 32kHz; [0...62.5 ms] for 32.768kHz </description>
	<access>read-write</access>
	<bitRange>[31:21]</bitRange>
	
</field><field>
	<name>TWIRQ_SET</name>
	<description>Minimum value is "TWIRQ_RESET + 1".
Time in low power oscillator cycles to set BLE_WAKEUP_LP_IRQ before the BLE sleep timer expiration.
Refer also to BLE_DEEPSLWKUP_REG[DEEPSLTIME].
Range is [0...64 ms] for 32kHz; [0...62.5 ms] for 32.768kHz </description>
	<access>read-write</access>
	<bitRange>[20:10]</bitRange>
	
</field><field>
	<name>TWIRQ_RESET</name>
	<description>Recommended value is 1.
Time in low power oscillator cycles to reset BLE_WAKEUP_LP_IRQ before the BLE sleep timer expiration.
Refer also to BLE_DEEPSLWKUP_REG[DEEPSLTIME].
Range is [0...32 ms] for 32kHz; [0...31.25 ms] for 32.768kHz. </description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_ERRORTYPESTAT_REG</name>
	<description>Error Type Status registers</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields>
	<field>
	<name>CONCEVTIRQ_ERROR</name>
	<description>Indicates whether two consecutive and concurrent ble_event_irq have been generated, and not acknowledged in time by the RW-BLE Software.
0: No error
1: Error occurred</description>
	<access>read-only</access>
	<bitRange>[17:17]</bitRange>
	
</field><field>
	<name>RXDATA_PTR_ERROR</name>
	<description>Indicates whether Rx data buffer pointer value programmed is null: this is a major programming failure.
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>TXDATA_PTR_ERROR</name>
	<description>Indicates whether Tx data buffer pointer value programmed is null during Advertising / Scanning / Initiating events, or during Master / Slave connections with non-null packet length: this is a major programming failure.
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>RXDESC_EMPTY_ERROR</name>
	<description>Indicates whether Rx Descriptor pointer value programmed in register is null: this is a major programming failure.
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>TXDESC_EMPTY_ERROR</name>
	<description>Indicates whether Tx Descriptor pointer value programmed in Control Structure is null during Advertising / Scanning / Initiating events: this is a major programming failure.
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>CSFORMAT_ERROR</name>
	<description>Indicates whether CS-FORMAT has been programmed with an invalid value: this is a major software programming failure.
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>LLCHMAP_ERROR</name>
	<description>Indicates Link Layer Channel Map error, happens when actual number of CS-LLCHMAP bit set to one is different from CS-NBCHGOOD at the beginning of Frequency Hopping process
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>ADV_UNDERRUN</name>
	<description>Indicates Advertising Interval Under run, occurs if time between two consecutive Advertising packet (in Advertising mode) is lower than the expected value.
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>IFS_UNDERRUN</name>
	<description>Indicates Inter Frame Space Under run, occurs if IFS time is not enough to update and read Control Structure/Descriptors, and/or White List parsing is not finished and/or Decryption time is too long to be finished on time
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>WHITELIST_ERROR</name>
	<description>Indicates White List Timeout error, occurs if White List parsing is not finished on time
0: No error
1: Error occurred</description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>EVT_CNTL_APFM_ERROR</name>
	<description>Indicates Anticipated Pre-Fetch Mechanism error: happens when 2 consecutive events are programmed, and when the first event is not completely finished while second pre-fetch instant is reached.
0: No error
1: Error occured </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>EVT_SCHDL_APFM_ERROR</name>
	<description>Indicates Anticipated Pre-Fetch Mechanism error: happens when 2 consecutive events are programmed, and when the first event is not completely finished while second pre-fetch instant is reached.
0: No error
1: Error occured </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>EVT_SCHDL_ENTRY_ERROR</name>
	<description>Indicates Event Scheduler faced Invalid timing programing on two consecutive ET entries (e.g first one with 624s offset and second one with no offset)
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>EVT_SCHDL_EMACC_ERROR</name>
	<description>Indicates Event Scheduler Exchange Memory access error, happens when Exchange Memory accesses are not served in time, and blocks the Exchange Table entry read
0: No error
1: Error occurred</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RADIO_EMACC_ERROR</name>
	<description>Indicates Radio Controller Exchange Memory access error, happens when Exchange Memory accesses are not served in time and data are corrupted.
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>PKTCNTL_EMACC_ERROR</name>
	<description>Indicates Packet Controller Exchange Memory access error, happens when Exchange Memory accesses are not served in time and Tx/Rx data are corrupted
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RXCRYPT_ERROR</name>
	<description>Indicates real time decryption error, happens when AES-CCM decryption is too slow compared to Packet Controller requests. A 16-bytes block has to be decrypted prior the next block is received by the Packet Controller
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>TXCRYPT_ERROR</name>
	<description>Indicates Real Time encryption error, happens when AES-CCM encryption is too slow compared to Packet Controller requests. A 16-bytes block has to be encrypted and prepared on Packet Controller request, and needs to be ready before the Packet Controller has to send ti
0: No error
1: Error occurred </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_FINECNTCORR_REG</name>
	<description>Phase correction value register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>FINECNTCORR</name>
	<description>Phase correction value for the 625us reference counter (i.e. Fine Counter) in us. </description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_FINETIMECNT_REG</name>
	<description>Fine time reference counter</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>FINECNT</name>
	<description>Value of the current s fine time reference counter. Updated each time SAMPCLK is written. Used by the SW in order to synchronize with the HW, and obtain a more precise sleep duration </description>
	<access>read-only</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_FINETIMTGT_REG</name>
	<description>Fine Timer Target value</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields>
	<field>
	<name>FINETARGET</name>
	<description>Fine Timer Target value on which a ble_finetgtim_irq must be generated. This timer has a precision of 625us: interrupt is generated only when FINETARGET = BASETIMECNT </description>
	<access>read-write</access>
	<bitRange>[26:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_GROSSTIMTGT_REG</name>
	<description>Gross Timer Target value</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields>
	<field>
	<name>GROSSTARGET</name>
	<description>Gross Timer Target value on which a ble_grosstgtim_irq must be generated. This timer has a precision of 10ms: interrupt is generated only when GROSSTARGET[22:0] = BASETIMECNT[26:4] and BASETIMECNT[3:0] = 0. </description>
	<access>read-write</access>
	<bitRange>[22:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_INTACK_REG</name>
	<description>Interrupt acknowledge register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>SWINTACK</name>
	<description>SW triggered interrupt acknowledgement bit
Software writing 1 acknowledges the SW triggered interrupt. This bit resets SWINTSTAT and SWINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>EVENTAPFAINTACK</name>
	<description>End of event / Anticipated Pre-Fetch Abort interrupt acknowledgement bit
Software writing 1 acknowledges the End of event / Anticipated Pre-Fetch Abort interrupt. This bit resets EVENTAPFAINTSTAT and EVENTAPFAINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>FINETGTIMINTACK</name>
	<description>Fine Target Timer interrupt acknowledgement bit
Software writing 1 acknowledges the Fine Timer interrupt. This bit resets FINETGTIMINTSTAT and FINETGTIMINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>GROSSTGTIMINTACK</name>
	<description>Gross Target Timer interrupt acknowledgement bit
Software writing 1 acknowledges the Gross Timer interrupt. This bit resets GROSSTGTIMINTSTAT and GROSSTGTIMINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ERRORINTACK</name>
	<description>Error interrupt acknowledgement bit
Software writing 1 acknowledges the Error interrupt. This bit resets ERRORINTSTAT and ERRORINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>CRYPTINTACK</name>
	<description>Encryption engine interrupt acknowledgement bit Software writing 1 acknowledges the Encryption engine interrupt. This bit resets CRYPTINTSTAT and CRYPTINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>EVENTINTACK</name>
	<description>End of Event interrupt acknowledgment bit
Software writing 1 acknowledges the End of Advertising / Scanning / Connection interrupt. This bit resets SLPINTSTAT and SLPINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SLPINTACK</name>
	<description>End of Deep Sleep interrupt acknowledgment bit
Software writing 1 acknowledges the End of Sleep Mode interrupt. This bit resets SLPINTSTAT and SLPINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RXINTACK</name>
	<description>Packet Reception interrupt acknowledgment bit
Software writing 1 acknowledges the Rx interrupt. This bit resets RXINTSTAT and RXINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>CSCNTINTACK</name>
	<description>625us base time reference interrupt acknowledgment bit
Software writing 1 acknowledges the CLKN interrupt. This bit resets CLKINTSTAT and CLKINTRAWSTAT flags.
Resets at 0 when action is performed </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_INTCNTL_REG</name>
	<description>Interrupt controller register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000811f</resetValue>
	<resetMask>0x000083ff</resetMask>
	<fields>
	<field>
	<name>CSCNTDEVMSK</name>
	<description>CSCNT interrupt mask during event. This bit allows to enable CSCNT interrupt generation during events (i.e. advertising, scanning, initiating, and connection)
0: CSCNT Interrupt not generated during events.
1: CSCNT Interrupt generated during events. </description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>SWINTMSK</name>
	<description>SW triggered interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>EVENTAPFAINTMSK</name>
	<description>End of event / anticipated pre-fetch abort interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>FINETGTIMINTMSK</name>
	<description>Fine Target Timer Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>GROSSTGTIMINTMSK</name>
	<description>Gross Target Timer Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ERRORINTMSK</name>
	<description>Error Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>CRYPTINTMSK</name>
	<description>Encryption engine Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>EVENTINTMSK</name>
	<description>End of event Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SLPINTMSK</name>
	<description>Sleep Mode Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RXINTMSK</name>
	<description>Rx Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>CSCNTINTMSK</name>
	<description>625us Base Time Interrupt Mask
0: Interrupt not generated
1: Interrupt generated </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_INTRAWSTAT_REG</name>
	<description>Interrupt raw status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>SWINTRAWSTAT</name>
	<description>SW triggered interrupt raw status
0: No SW triggered interrupt.
1: A SW triggered interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>EVENTAPFAINTRAWSTAT</name>
	<description>End of event / Anticipated Pre-Fetch Abort interrupt raw status
0: No End of Event interrupt.
1: An End of Event interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>FINETGTIMINTRAWSTAT</name>
	<description>Fine Target Timer Error interrupt raw status
0: No Fine Target Timer interrupt.
1: A Fine Target Timer interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>GROSSTGTIMINTRAWSTAT</name>
	<description>Gross Target Timer interrupt raw status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ERRORINTRAWSTAT</name>
	<description>Error interrupt raw status
0: No Error interrupt.
1: An Error interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>CRYPTINTRAWSTAT</name>
	<description>Encryption engine interrupt raw status
0: No Encryption / Decryption interrupt.
1: An Encryption / Decryption interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>EVENTINTRAWSTAT</name>
	<description>End of Event interrupt raw status
0: No End of Advertising / Scanning / Connection interrupt.
1: An End of Advertising / Scanning / Connection interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SLPINTRAWSTAT</name>
	<description>Sleep interrupt raw status
0: No End of Sleep Mode interrupt.
1: An End of Sleep Mode interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RXINTRAWSTAT</name>
	<description>Packet Reception interrupt raw status
0: No Rx interrupt.
1: An Rx interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>CSCNTINTRAWSTAT</name>
	<description>625us base time reference interrupt raw status
0: No 625us Base Time interrupt.
1: A 625us Base Time interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_INTSTAT_REG</name>
	<description>Interrupt status register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>SWINTSTAT</name>
	<description>SW triggered interrupt status
0: No SW triggered interrupt.
1: A SW triggered interrupt is pending </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>EVENTAPFAINTSTAT</name>
	<description>End of event / Anticipated Pre-Fetch Abort interrupt status
0: No End of Event interrupt.
1: An End of Event interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>FINETGTIMINTSTAT</name>
	<description>Masked Fine Target Timer Error interrupt status
0: No Fine Target Timer interrupt.
1: A Fine Target Timer interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>GROSSTGTIMINTSTAT</name>
	<description>Masked Gross Target Timer interrupt status
0: No Gross Target Timer interrupt.
1: A Gross Target Timer interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ERRORINTSTAT</name>
	<description>Masked Error interrupt status
0: No Error interrupt.
1: An Error interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>CRYPTINTSTAT</name>
	<description>Masked Encryption engine interrupt status
0: No Encryption / Decryption interrupt.
1: An Encryption / Decryption interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>EVENTINTSTAT</name>
	<description>Masked End of Event interrupt status
0: No End of Advertising / Scanning / Connection interrupt.
1: An End of Advertising / Scanning / Connection interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SLPINTSTAT</name>
	<description>Masked Sleep interrupt status
0: No End of Sleep Mode interrupt.
1: An End of Sleep Mode interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RXINTSTAT</name>
	<description>Masked Packet Reception interrupt status
0: No Rx interrupt.
1: An Rx interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>CSCNTINTSTAT</name>
	<description>Masked 625us base time reference interrupt status
0: No 625us Base Time interrupt.
1: A 625us Base Time interrupt is pending. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_RADIOCNTL0_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>field246rsv</name>
	
	
	<bitRange>[4:2]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_RADIOCNTL1_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>XRFSEL</name>
	<description>Extended radio selection field, Must be set to "2".</description>
	<access>read-write</access>
	<bitRange>[20:16]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_RADIOCNTL2_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	</fields>
</register><register>
	<name>BLE_RADIOCNTL3_REG</name>
	<description>Radio interface control register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	</fields>
</register><register>
	<name>BLE_RADIOPWRUPDN_REG</name>
	<description>RX/TX power up/down phase register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00d203d2</resetValue>
	<resetMask>0x7fff0fff</resetMask>
	<fields>
	<field>
	<name>RTRIP_DELAY</name>
	<description>Defines round trip delay value. This value correspond to the addition of data latency in Tx and data latency in Rx. Value is in us </description>
	<access>read-write</access>
	<bitRange>[30:24]</bitRange>
	
</field><field>
	<name>RXPWRUP</name>
	<description>This register holds the length in s of the RX power up phase for the current radio device. Default value is 210us (reset value). Operating range depends on the selected radio. </description>
	<access>read-write</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>TXPWRDN</name>
	<description>This register extends the length in s of the TX power down phase for the current radio device. Default value is 3us (reset value). Operating range depends on the selected radio. </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>TXPWRUP</name>
	<description>This register holds the length in s of the TX power up phase for the current radio device. Default value is 210us (reset value). Operating range depends on the selected radio. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_RFTESTCNTL_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>INFINITERX</name>
	<description>Applicable in RF Test Mode only
0: Normal mode of operation
1: Infinite Rx window </description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>RXPKTCNTEN</name>
	<description>Applicable in RF Test Mode only
0: Rx packet count disabled
1: Rx packet count enabled, and reported in CS-RXCCMPKTCNT and RFTESTRXSTAT-RXPKTCNT on RF abort command </description>
	<access>read-write</access>
	<bitRange>[27:27]</bitRange>
	
</field><field>
	<name>INFINITETX</name>
	<description>Applicable in RF Test Mode only
0: Normal mode of operation.
1: Infinite Tx packet / Normal start of a packet but endless payload </description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>TXLENGTHSRC</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Normal mode of operation: TxDESC-TXADVLEN controls the Tx packet payload size
1: Uses RFTESTCNTL-TXLENGTH packet length (can support up to 512 bytes transmit) </description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>PRBSTYPE</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Tx Packet Payload are PRBS9 type
1: Tx Packet Payload are PRBS15 type </description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>TXPLDSRC</name>
	<description>Applicable only in Tx/Rx RF Test mode
0: Tx Packet Payload source is the Control Structure
1: Tx Packet Payload are PRBS generator </description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>TXPKTCNTEN</name>
	<description>Applicable in RF Test Mode only
0: Tx packet count disabled
1: Tx packet count enabled, and reported in CS-TXCCMPKTCNT and RFTESTTXSTAT-TXPKTCNT on RF abort command </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TXLENGTH</name>
	<description>Applicable only for Tx/Rx RF Test mode, and valid when RFTESTCNTL-TXLENGTHSRC = 1
Tx packet length in number of byte </description>
	<access>read-write</access>
	<bitRange>[8:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_RFTESTRXSTAT_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RXPKTCNT</name>
	<description>Reports number of correctly received packet during Test Modes (no sync error, no CRC error).
Value is valid if RFTESTCNTL-RXPKTCNTEN is set</description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_RFTESTTXSTAT_REG</name>
	<description>RF Testing Register</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TXPKTCNT</name>
	<description>Reports number of transmitted packet during Test Modes.
Value is valid if RFTESTCNTL-TXPKTCNTEN is set</description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_RWBLECNTL_REG</name>
	<description>BLE Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MASTER_SOFT_RST</name>
	<description>Reset the complete BLE Core except registers and timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<access>write-only</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>MASTER_TGSOFT_RST</name>
	<description>Reset the timing generator, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<access>write-only</access>
	<bitRange>[30:30]</bitRange>
	
</field><field>
	<name>REG_SOFT_RST</name>
	<description>Reset the complete register block, when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.
Note that INT STAT will not be cleared, so the user should also write to BLE_INTACK_REG after the SW Reset</description>
	<access>read-write</access>
	<bitRange>[29:29]</bitRange>
	
</field><field>
	<name>SWINT_REQ</name>
	<description>Forces the generation of ble_sw_irq when written with a 1, and proper masking is set. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<access>write-only</access>
	<bitRange>[28:28]</bitRange>
	
</field><field>
	<name>RFTEST_ABORT</name>
	<description>Abort the current RF Testing defined as per CS-FORMAT when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.
Note that when RFTEST_ABORT is requested:
1) In case of infinite Tx, the Packet Controller FSM stops at the end of the current byte in process, and processes accordingly the packet CRC.
2) In case of Infinite Rx, the Packet Controller FSM either stops as the end of the current Packet reception (if Access address has been detected), or simply stop the processing switching off the RF.</description>
	<access>write-only</access>
	<bitRange>[26:26]</bitRange>
	
</field><field>
	<name>ADVERT_ABORT</name>
	<description>Abort the current Advertising event when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<access>write-only</access>
	<bitRange>[25:25]</bitRange>
	
</field><field>
	<name>SCAN_ABORT</name>
	<description>Abort the current scan window when written with a 1. Resets at 0 when action is performed. No action happens if it is written with 0.</description>
	<access>write-only</access>
	<bitRange>[24:24]</bitRange>
	
</field><field>
	<name>MD_DSB</name>
	<description>0: Normal operation of MD bits management
1: Allow a single Tx/Rx exchange whatever the MD bits are.
value forced by SW from Tx Descriptorvalue just saved in Rx Descriptor during reception</description>
	<access>read-write</access>
	<bitRange>[22:22]</bitRange>
	
</field><field>
	<name>SN_DSB</name>
	<description>0: Normal operation of Sequence number
1: Sequence Number Management disabled:
value forced by SW from Tx Descriptorvalue ignored in Rx, where no SN error reported.</description>
	<access>read-write</access>
	<bitRange>[21:21]</bitRange>
	
</field><field>
	<name>NESN_DSB</name>
	<description>0: Normal operation of Acknowledge
1: Acknowledge scheme disabled:
value forced by SW from Tx Descriptorvalue ignored in Rx, where no NESN error reported.</description>
	<access>read-write</access>
	<bitRange>[20:20]</bitRange>
	
</field><field>
	<name>CRYPT_DSB</name>
	<description>0: Normal operation. Encryption / Decryption enabled.
1: Encryption / Decryption disabled.
Note that if CS-CRYPT_EN is set, then MIC is generated, and only data encryption is disabled, meaning data sent are plain data.</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>WHIT_DSB</name>
	<description>0: Normal operation. Whitening enabled.
1: Whitening disabled.</description>
	<access>read-write</access>
	<bitRange>[18:18]</bitRange>
	
</field><field>
	<name>CRC_DSB</name>
	<description>0: Normal operation. CRC removed from data stream.
1: CRC stripping disabled on Rx packets, CRC replaced by 0x000 in Tx.</description>
	<access>read-write</access>
	<bitRange>[17:17]</bitRange>
	
</field><field>
	<name>HOP_REMAP_DSB</name>
	<description>0: Normal operation. Frequency Hopping Remapping algorithm enabled.
1: Frequency Hopping Remapping algorithm disabled</description>
	<access>read-write</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>CORR_MODE</name>
	<description>Defines correlation mode
00: Correlates onto Access Address
01: Correlates onto half preamble and Access Address
10: Correlates onto full preamble and Access Address
11: n/a</description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>ADVERTFILT_EN</name>
	<description>Advertising Channels Error Filtering Enable control
0: RW-BLE Core reports all errors to RW-BLE Software
1: RW-BLE Core reports only correctly received packet, without error to RW-BLE Software</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>RWBLE_EN</name>
	<description>0: Disable RW-BLE Core Exchange Table pre-fetch mechanism.
1: Enable RW-BLE Core Exchange table pre-fetch mechanism.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>RXWINSZDEF</name>
	<description>Default Rx Window size in us. Used when device:

is master connectedperforms its second receipt.0 is not a valid value. Recommended value is 10 (in decimal).</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>SYNCERR</name>
	<description>Indicates the maximum number of errors allowed to recognize the synchronization word.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_RWBLECONF_REG</name>
	<description>Configuration register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x1002001f</resetValue>
	<resetMask>0x3f7f3f7f</resetMask>
	<fields>
	<field>
	<name>ADD_WIDTH</name>
	<description>Value of the RW_BLE_ADDRESS_WIDTH parameter concerted into binary.</description>
	<access>read-only</access>
	<bitRange>[29:24]</bitRange>
	
</field><field>
	<name>RFIF</name>
	<description>Radio Interface ID </description>
	<access>read-only</access>
	<bitRange>[22:16]</bitRange>
	
</field><field>
	<name>CLK_SEL</name>
	<description>Operating Frequency (in MHz) </description>
	<access>read-only</access>
	<bitRange>[13:8]</bitRange>
	
</field><field>
	<name>DECIPHER</name>
	<description>0: AES deciphering not present</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DMMODE</name>
	<description>0: RW-BLE Core is used as a standalone BLE device </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>INTMODE</name>
	<description>1: Interrupts are trigger level generated, i.e. stays active at 1 till acknowledgement </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>COEX</name>
	<description>1: WLAN Coexistence mechanism present </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USEDBG</name>
	<description>1: Diagnostic port instantiated </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USECRYPT</name>
	<description>1: AES-CCM Encryption block present </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>BUSWIDTH</name>
	<description>Processor bus width:
1: 32 bits </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_RXMICVAL_REG</name>
	<description>AES / CCM plain MIC value</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RXMICVAL</name>
	<description>AES-CCM plain MIC value. Valid on once MIC has been extracted from Rx packet. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_SAMPLECLK_REG</name>
	<description>Samples the Base Time Counter</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SAMP</name>
	<description>Writing a 1 samples the Base Time Counter value in BASETIMECNT register. Resets at 0 when action is performed. </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_SWPROFILING_REG</name>
	<description>Software Profiling register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SWPROFVAL</name>
	<description>Software Profiling register: used by RW-BLE Software for profiling purpose: this value is copied on Diagnostic port </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_TIMGENCNTL_REG</name>
	<description>Timing Generator Register</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>APFM_EN</name>
	<description>Controls the Anticipated pre-Fetch Abort mechanism
0: Disabled
1: Enabled </description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>PREFETCHABORT_TIME</name>
	<description>Defines the instant in s at which immediate abort is required after anticipated pre-fetch abort </description>
	<access>read-write</access>
	<bitRange>[25:16]</bitRange>
	
</field><field>
	<name>PREFETCH_TIME</name>
	<description>Defines Exchange Table pre-fetch instant in us </description>
	<access>read-write</access>
	<bitRange>[8:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_TXMICVAL_REG</name>
	<description>AES / CCM plain MIC value</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TXMICVAL</name>
	<description>AES-CCM plain MIC value. Valid on when MIC has been calculated (in Tx) </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_VERSION_REG</name>
	<description>Version register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07010000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TYP</name>
	<description>BLE Core Type</description>
	<access>read-only</access>
	<bitRange>[31:24]</bitRange>
	
</field><field>
	<name>REL</name>
	<description>BLE Core version Major release number.</description>
	<access>read-only</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>UPG</name>
	<description>BLE Core upgrade Upgrade number.</description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>BUILD</name>
	<description>BLE Core Build Build number.</description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_WLNBDEV_REG</name>
	<description>Devices in white list</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>NBPRIVDEV</name>
	<description>Number of private devices in the white list.</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>NBPUBDEV</name>
	<description>Number of public devices in the white list. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_WLPRIVADDPTR_REG</name>
	<description>Start address of private devices list</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>WLPRIVADDPTR</name>
	<description>Start address pointer of the private devices white list. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BLE_WLPUBADDPTR_REG</name>
	<description>Start address of public devices list</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>WLPUBADDPTR</name>
	<description>Start address pointer of the public devices white list. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CACHE</name>
	<version>1.0</version>
	<description>CACHE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x400c3000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>84</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>CACHE_ASSOCCFG_REG</name>
	<description>Cache associativity configuration register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CACHE_ASSOC</name>
	<description>Cache associativity:
0: 1-way (direct mapped)
1: 2-way
2: 4-way
3: reserved.
Note: Flush the cache controller before dynamically decreasing the associativity.</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CACHE_CTRL1_REG</name>
	<description>Cache control register 1</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CACHE_RES1</name>
	<description>Reserved. Always keep 0.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>CACHE_FLUSH</name>
	<description>Writing a '1' into this bit, flushes the contents of the tag memories which invalidates the content of the cache memory.
The read of this bit is always '0'.
Note: The flushing of the cache TAG memory takes 0x100 or 0x200 HCLK cycles for a Cache Data RAM size of 8 KB resp. 16 KB.</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CACHE_CTRL2_REG</name>
	<description>Cache control register 2</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>ENABLE_ALSO_QSPIFLASH_CACHED</name>
	<description>Enable also the QSPI FLASH cacheability when remapped to OTP (cached).
See also the notes at "CACHE_LEN".</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>ENABLE_ALSO_OTP_CACHED</name>
	<description>Enable also the OTP cacheability when remapped to QSPI FLASH (cached).
See also the notes at "CACHE_LEN".</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>CACHE_CGEN</name>
	<description>0: Cache controller clock gating is not enabled.
1: Cache controller clock gating is enabled (enabling power saving).
Note: This bit must be set to '0' (default) when setting the CACHE_FLUSH bit while executing from other than QSPI FLASH cached or OTP cached, e.g. from Booter or SYSRAM.</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>CACHE_WEN</name>
	<description>0: Cache Data and TAG memory read only.
1: Cache Data and TAG memory read/write.
The TAG and Data memory are only updated by the cache controller.
There is no HW protection to prevent unauthorized access by the ARM.
Note: When accessing the memory mapped Cache Data and TAG memory (for debugging purposes) only 32 bits access is allowed to the Cache Data memory and only 16 bits access is allowed to the Cache TAG memory.</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>CACHE_LEN</name>
	<description>Length of QSPI FLASH cacheable memory.
(N+1)*64kbyte. N=1 to 512 (Max of 32 Mbyte).
Setting CACHE_LEN=0 disables the cache.
Note 1: The OTP memory is completely cacheable (when enabled).
Note 2: The max. size/length of QSPI FLASH cacheable memory is 16 Mbyte when also OTP is cached.</description>
	<access>read-write</access>
	<bitRange>[8:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CACHE_CTRL3_REG</name>
	<description>Cache control register 3 (for the Cache Controller configuration reset values)</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000022</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CACHE_CONTROLLER_RESET</name>
	<description>0: De-activate the Reset of the Cache Controller.
1: Reset the Cache Controller and take the new configuration reset values (when the reset is released again by changing this bit from '1' to '0').
Note: All CACHE_MRM_* registers are also reset.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>CACHE_RAM_SIZE_RESET_VALUE</name>
	<description>Cache DATA RAM size reset value:
0: reserved,
1: 8 KB,
2: 16 KB,
3-7: reserved.</description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>CACHE_LINE_SIZE_RESET_VALUE</name>
	<description>Cache line size reset value:
0: 8 bytes,
1: 16 bytes,
2: 32 bytes,
3: reserved.</description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>CACHE_ASSOCIATIVITY_RESET_VALUE</name>
	<description>Cache associativity reset value:
0: 1-way (direct mapped)
1: 2-way
2: 4-way
3: reserved.</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CACHE_LNSIZECFG_REG</name>
	<description>Cache line size configuration register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CACHE_LINE</name>
	<description>Cache line size:
0: 8 bytes,
1: 16 bytes,
2: 32 bytes,
3: reserved.
Note: Flush the cache just after the dynamic (run-time) reconfiguration of the cache with an 8 bytes cache line size: write the value "01" into the cache control register CACHE_CTRL1_REG just after the write of the value "00" into the cache line size configuration register CACHE_LNSIZECFG_REG.</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CACHE_MRM_CTRL_REG</name>
	<description>Cache MRM (Miss Rate Monitor) CONTROL register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MRM_IRQ_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache misses reached the programmed threshold (threshold != 0).</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>MRM_IRQ_TINT_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the time interval counter reached the end (time interval != 0).</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>MRM_IRQ_MASK</name>
	<description>0: Disables interrupt generation.
1: Enables interrupt generation.
Note: The Cache MRM generates a pulse-sensitive interrupt towards the ARM processor,</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>MRM_START</name>
	<description>0: Freeze the "misses/hits" counters and reset the time interval counter to the programmed value in CACHE_MRM_TINT_REG.
1: Enables the counters.
Note: In case CACHE_MRM_CTRL_REG[MRM_START] is set to '1' and CACHE_MRM_TINT_REG (!=0) is used for the MRM interrupt generation, the time interval counter counts down (on a fixed reference clock of 16 MHz) until it's '0'. At that time CACHE_MRM_CTRL_REG[MRM_START] will be reset automatically to '0' by the MRM hardware and the MRM interrupt will be generated.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CACHE_MRM_HITS_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MRM_HITS</name>
	<description>Contains the amount of cache hits.</description>
	<access>read-write</access>
	<bitRange>[18:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CACHE_MRM_MISSES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) MISSES register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MRM_MISSES</name>
	<description>Contains the amount of cache misses.</description>
	<access>read-write</access>
	<bitRange>[17:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CACHE_MRM_THRES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) THRESHOLD register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MRM_THRES</name>
	<description>Defines the threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_THRES_STATUS].
Note: When MRM_THRES=0 (unrealistic value), no interrupt will be generated.</description>
	<access>read-write</access>
	<bitRange>[17:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CACHE_MRM_TINT_REG</name>
	<description>Cache MRM (Miss Rate Monitor) TIME INTERVAL register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MRM_TINT</name>
	<description>Defines the time interval for the monitoring in 16 MHz clock cycles. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_TINT_STATUS].
Note: When MRM_TINT=0 (unrealistic value), no interrupt will be generated.</description>
	<access>read-write</access>
	<bitRange>[17:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SWD_RESET_REG</name>
	<description>SWD HW reset control register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SWD_HW_RESET_REQ</name>
	<description>0: default.
1: HW reset request without resetting the SWD and DAP controller. The register is automatically reset with a HW_RESET.
This bit can only be accessed by the debugger software and not by the application.</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CHIP_VERSION</name>
	<version>1.0</version>
	<description>CHIP_VERSION registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003200</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>13</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>CHIP_CONFIG1_REG</name>
	<description>Chip configuration register 1.</description>
	<addressOffset>0x00000005</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000030</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>CHIP_CONFIG1</name>
	<description>First character of Chip Configuration "0M2" in ASCII. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHIP_CONFIG2_REG</name>
	<description>Chip configuration register 2.</description>
	<addressOffset>0x00000006</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x0000004d</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>CHIP_CONFIG2</name>
	<description>Second character of Chip Configuration "0M2" in ASCII. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHIP_CONFIG3_REG</name>
	<description>Chip configuration register 3.</description>
	<addressOffset>0x00000007</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>CHIP_CONFIG3</name>
	<description>Third character of Chip Configuration "0M2" in ASCII. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHIP_ID1_REG</name>
	<description>Chip identification register 1.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000036</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>CHIP_ID1</name>
	<description>First character of device type "680" in ASCII. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHIP_ID2_REG</name>
	<description>Chip identification register 2.</description>
	<addressOffset>0x00000001</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000038</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>CHIP_ID2</name>
	<description>Second character of device type "680" in ASCII. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHIP_ID3_REG</name>
	<description>Chip identification register 3.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000030</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>CHIP_ID3</name>
	<description>Third character of device type "680" in ASCII. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHIP_REVISION_REG</name>
	<description>Chip revision register.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>REVISION_ID</name>
	<description>Chip version, corresponds with type number in ASCII.
0x41 = 'A', 0x42 = 'B' </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHIP_SWC_REG</name>
	<description>Software compatibility register.</description>
	<addressOffset>0x00000003</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>CHIP_SWC</name>
	<description>SoftWare Compatibility code.
Integer (default = 0) which is incremented if a silicon change has impact on the CPU Firmware.
Can be used by software developers to write silicon revision dependent code. </description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CHIP_TEST1_REG</name>
	<description>Chip test register 1.</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	</fields>
</register><register>
	<name>CHIP_TEST2_REG</name>
	<description>Chip test register 2.</description>
	<addressOffset>0x0000000b</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000021</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	</fields>
</register><register>
	<name>CHIP_TEST3_REG</name>
	<description>Chip test register 3.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>8</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	</fields>
</register></registers>
</peripheral><peripheral>
	<name>COEX</name>
	<version>1.0</version>
	<description>COEX registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50002f00</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>48</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>COEX_BLE_PTI_REG</name>
	<description>COEX BLE PTI Control Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_BLE_PTI</name>
	<description>This value specifies the PTI value that characterizes the next BLE transaction that will be initiated on the following "ble_active" positive edge. The value should remain constant during the high period of the "ble_active" signal.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_CTRL_REG</name>
	<description>COEX Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IGNORE_BLE</name>
	<description>If set to "1" then all BLE requests are ignored by masking the internal "ble_active" signal. Refer also to IGNORE_BLE_STAT.</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>IGNORE_FTDF</name>
	<description>If set to "1" then all FTDF requests are ignored by masking the internal "ftdf_active" signal. Refer also to IGNORE_FTDF_STAT.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>IGNORE_EXT</name>
	<description>If set to "1" then all EXT requests are ignored by masking the internal "ext_act" signal ("ext_act" is the logical OR of "ext_act0" and "ext_act1"). Refer also to IGNORE_EXT_STAT.</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>SEL_BLE_RADIO_BUSY</name>
	<description>Select the logic driving the BLE core input "ble.radio_busy":
0: (decision==BLE) AND rfcu.radio_busy.
1: Hold to "0".
2: (decision==FTDF) OR (decision==EXT) OR rfcu.radio_busy.
3: (decision==FTDF) OR (decision==EXT).
Selection "0" is the default, while selection "2" is the recommended value if the BLE SW supports it.</description>
	<access>read-write</access>
	<bitRange>[12:11]</bitRange>
	
</field><field>
	<name>SEL_BLE_WLAN_TX_RX</name>
	<description>If set to "1" then the COEX block will drive the WLAN_TX and WLAN_RX inputs of the BLE core. Otherwise both BLE inputs will be forced to "0".</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>SEL_BLE_PTI</name>
	<description>It controls the source of the BLE PTI value that the COEX Arbiter will use.
If "0" then use the COEX_BLE_PTI_REG.
If "1" then use the PTI value provided by the BLE core.</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>SEL_FTDF_PTI</name>
	<description>It controls the source of the FTDF PTI value that the COEX Arbiter will use.
If "0" then use the COEX_FTDF_PTI_REG.
If "1" then use the PTI value provided by the FTDF core.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>SEL_FTDF_CCA</name>
	<description>If set to "1" and the COEX decision is different than "FTDF", then the CCA_STAT signal going to FTDF (generated from the radio) will be forced to "1"; otherwise the FTDF.CCA_STAT will be driven with the signal generated from the radio.
Recommended value for SEL_FTDF_CCA is "1".</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SEL_COEX_DIAG</name>
	<description>The COEX block can provide internal diagnostic signals by overwriting the BLE diagnostic bus, which is forwarded to GPIO multiplexing. There is no need to program the BLE registers, but only this field and the GPIO PID fields.
0: No COEX diagnostics, only BLE.
1: BLE_DIAG[4:3]=decision[1:0]; BLE_DIAG[5]=closing.
2: BLE_DIAG[4:3]=decision[1:0]; BLE_DIAG[5]=closing; BLE_DIAG[6]=OR( ftdf/ble2coex_tx/rx_en )
3: BLE_DIAG[2]=closing OR radio_busy; BLE_DIAG[6:3]=decision_ptr[3:0]; BLE_DIAG[7]=0.</description>
	<access>read-write</access>
	<bitRange>[6:5]</bitRange>
	
</field><field>
	<name>SMART_ACT_IMPL</name>
	<description>Controls the behavior of the SMART_ACT (and SMART_PRI as a consequence).
If SMART_ACT_IMPL="0" then if any BLE or FTDF MAC request is active then SMART_ACT will be asserted. SMART_ACT will actually be the logical OR of "ble_active" and "ftdf_active" internal signals. SMART_ACT will be asserted regardless the decision of the Arbiter to allow or disallow the access to the on-chip radio from the active MAC(s).
if SMART_ACT_IMPL="1" then if the Arbiter's decision is to allow EXTernal MAC, then keep SMART_ACT to "0", otherwise follow the implementation of SMART_ACT_IMPL="0".</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TXRX_MON_BLE_ALL</name>
	<description>It controls the behavior of the Monitoring bitfields COEX_INT_STAT_REG[ *TXRX_MON* ]
If "0" then update the Monitoring bitfields with BLE Rx/Tx that has been masked.
If "1" then update for every BLE Rx/Tx, either masked or not.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>TXRX_MON_FTDF_ALL</name>
	<description>It controls the behavior of the Monitoring bitfields COEX_INT_STAT_REG[ *TXRX_MON* ]
If "0" then update the Monitoring bitfields with FTDF Rx/Tx that has been masked.
If "1" then update for every FTDF Rx/Tx, either masked or not.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DECISION_SW_ALL</name>
	<description>Refer to COEX_INT_STAT_REG[ IRQ_DECISION_SW ] bitfield description.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>PRGING_ARBITER</name>
	<description>If set to "1" then the current transaction (Tx or Rx) will complete normally and after that no further decision will be taken by the arbiter. Will be set to "1" automatically by the HW as soon as a write operation will be detected to the COEX_PRIx_REG registers. As soon as the update on the priorities will be completed, the SW should clear this bit. The SW can set or clear this bit.
Note: Depending on the relationship between the PCLK and COEX_CLK periods a write operation to this bitfield may be effective in more than one PCLK clock cycles.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_FTDF_PTI_REG</name>
	<description>COEX FTDF PTI Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_FTDF_PTI</name>
	<description>This value specifies the PTI value that characterizes the next FTDF transaction that will be initiated on the following "ftdf_active" positive edge. The value should remain constant during the high period of the "ftdf_active" signal. Refer also to bitfield COEX_CTRL_REG.SEL_FTDF_PTI.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_INT_MASK_REG</name>
	<description>COEX Interrupt Mask Register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IRQ_DECISION_SW</name>
	<description>If "1" then a "1" on COEX_INT_STAT_REG[IRQ_DECISION_SW] will generate an IRQ to CPU.</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>IRQ_TXRX_MON</name>
	<description>If "1" then a "1" on COEX_INT_STAT_REG[IRQ_TXRX_MON] will generate an IRQ to CPU.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_INT_STAT_REG</name>
	<description>COEX Interrupt Status Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IRQ_DECISION_SW</name>
	<description>IRQ event when the DECISION switches to another value.
If DECISION_SW_ALL=1, then it reports any change of DECISION value.
If DECISION_SW_ALL=0, then it reports only the switches to another MAC, ignoring also the intermediate transitions to DECISION==NONE.
For example the sequence FTDF-NONE-FTDF-NONE-BLE-NONE-BLE will report only the first switch from NONE to BLE.
Note that after a Radio Power domain reset, the first transition of the DECISION to any non-NONE value will also trigger this event.</description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>IRQ_TXRX_MON</name>
	<description>Tx/Rx Monitor event pending. When this bitfield is set, then there is a valid entry at the bitfields TXRX_MON_PTR, TXRX_MON_TX, TXRX_MON_PASSED and TXRX_MON_OVWR. </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>TXRX_MON_OVWR</name>
	<description>Tx/Rx Monitor entry Overwritten.
if "1" then TXRX_MON_PTR loaded a new value without being cleared first by the software. Provides an indication that the software does not fetch the TXRX_MON_PTR fast enough.</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>TXRX_MON_PASSED</name>
	<description>This bit indicates if the corresponding TXRX_MON_PTR pointer indicates a Tx/Rx that has been masked or not by the COEX block.
If "0" then the Tx/Rx has been masked.
If "1" then the Tx/Rx has not been masked.
The bitfield is valid only when TXRX_MON_PTR is not zero.</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>TXRX_MON_TX</name>
	<description>If "0" then the corresponding TXRX_MON_PTR corresponds to an Rx.
If "1" then the corresponding TXRX_MON_PTR corresponds to an Tx.
The bitfield is valid only when TXRX_MON_PTR is not zero.</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>TXRX_MON_PTR</name>
	<description>Tx/Rx Monitor Pointer.
If not zero then it provides a pointer to the Priority registers indicating the completion of an Tx or Rx (deassertion of TX_EN or RX_EN) that corresponds to this Priority register. Refer also to the COEX_CTRL_REG[ TXRX_MON_ALL ] control bit.
If the PTI that corresponds to the deasserted TX_EN/RX_EN is not in the Priority Register list, then this event will be ignored and will not be reported by the TXRX Monitoring bitfields.
Reading the register will clear the bitfield.</description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI10_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI11_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI12_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI13_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI14_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI15_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x0000002e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI1_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000018</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Specifies the MAC that has been assigned with the specific priority level. The MAC encoding follows the COEX_DECISION bitfield encoding.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>The priority level specified by the name of this register will be applied to the packets coming from the MAC specified by the COEX_PRI_MAC bitfield and characterized with the PTI value specified by the COEX_PRI_PTI bitfield.
The effective PTI value of the packets coming from BLE and FTDF is controlled by the register bitfields SEL_BLE_PTI and SEL_FTDF_PTI, while for the External MAC (EXT) the PTI is considered always as "0".</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI2_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI3_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI4_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI5_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI6_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI7_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI8_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_PRI9_REG</name>
	<description>COEX Priority Register</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_PRI_MAC</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>COEX_PRI_PTI</name>
	<description>Refer to COEX_PRI1_REG.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_STAT2_REG</name>
	<description>COEX Status 2 Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COEX_EXT_ACT</name>
	<description>The internal EXT_ACT used for the decision taking. </description>
	<access>read-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>COEX_BLE_PTI_INT</name>
	<description>The BLE PTI value that is used for decision taking.</description>
	<access>read-only</access>
	<bitRange>[14:12]</bitRange>
	
</field><field>
	<name>COEX_BLE_TX_EN</name>
	<description>The current value of BLE TX_EN.</description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>COEX_BLE_RX_EN</name>
	<description>The current value of BLE RX_EN.</description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>COEX_BLE_ACTIVE</name>
	<description>The internal BLE_ACTIVE signal used for decision taking.</description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>COEX_FTDF_PTI_INT</name>
	<description>The FTDF PTI value that is used for decision taking.
Value depends on COEX_CTRL_REG.SEL_FTDF_PTI.</description>
	<access>read-only</access>
	<bitRange>[8:6]</bitRange>
	
</field><field>
	<name>COEX_FTDF_TX_EN</name>
	<description>The current value of FTDF TX_EN.</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>COEX_FTDF_RX_EN</name>
	<description>The current value of FTDF RX_EN.</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>COEX_FTDF_ACTIVE</name>
	<description>The internal FTDF_ACTIVE signal used for the decision taking.</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>COEX_DECISION_WITH_CLOSING</name>
	<description>DECISION (bits [1:0]) appended the CLOSING (bit [2]) state.</description>
	<access>read-only</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>COEX_STAT_REG</name>
	<description>COEX Status Register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IGNORE_BLE_STAT</name>
	<description>This signal is constantly "1" on FTDF-only chips.
If set to "1" then all BLE requests are ignored by masking immediately the request signal from the BLE.
In more detail, the internal signal "ble_active" is the logical AND of this bitfield and the "ble.event_in_process".</description>
	<access>read-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>IGNORE_FTDF_STAT</name>
	<description>This signal is constantly "1" on BLE-only chips.
If set to "1" then all FTDF requests are ignored by masking immediately the request signal from the FTDF.
In more detail, the internal signal "ftdf_active" is the logical AND of this bitfield and the "ftdf.phy_en".</description>
	<access>read-only</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>IGNORE_EXT_STAT</name>
	<description>If set to "1" then all EXT requests are ignored by masking immediately the request signal from the external MAC.
In more detail, the internal signal "ext_active" is the logical AND of this bitfield and the "ext_act".</description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>COEX_RADIO_BUSY</name>
	<description>Current state of RADIO_BUSY signal generated from RFCU, which is the logical OR among all Radio DCFs.
Note that the arbiter will process this value with one COEX clock cycle delay.</description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>EXT_ACT1</name>
	<description>Current state of the pin.</description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>EXT_ACT0</name>
	<description>Current state of the pin.</description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>SMART_PRI</name>
	<description>Current state of the pin.</description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>SMART_ACT</name>
	<description>Current state of the pin.</description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>COEX_CLOSING</name>
	<description>Provides the value of the "CLOSING" substate.</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>COEX_DECISION</name>
	<description>Decision values:
0: Decision is NONE.
1: Decision is BLE.
2: Decision is FTDF.
3: Decision is EXT.
Note: If "0" (i.e. decision is NONE) then no MAC will have access to the on-chip radio. As a consequence, the SMART_PRI signal will stay low, since no on-chip (SMART) MAC will have priority.
Note: While in programming mode, the COEX_PRIx_REGs are considered as invalid, which means that no new decision can be taken.
Note: The decision NONE will be held as long as there is no "*_active" internal signal from BLE, FTDF or EXT. Also, if in programming state and the last transaction has been finished, then the decision will be held also to NONE.</description>
	<access>read-only</access>
	<bitRange>[6:5]</bitRange>
	
</field><field>
	<name>COEX_DECISION_PTR</name>
	<description>Provides the number "x" of the COEX_PRIx_REG that win the last arbitration cycle. If "0" then it is a null pointer, pointing to no COEX_PRIx_REG.</description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_PER</name>
	<version>1.0</version>
	<description>CRG_PER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001c00</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>76</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>CLK_PER_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>ADC_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>KBSCAN_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>KBSCAN_ENABLE</name>
	<description>Enables the clock</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>IR_CLK_ENABLE</name>
	<description>Enables the clock</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>QUAD_ENABLE</name>
	<description>Enables the clock</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>I2C_ENABLE</name>
	<description>Enables the clock</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SPI_ENABLE</name>
	<description>Enables the clock</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>UART_ENABLE</name>
	<description>Enables the clock</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>EH_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>EH_EN</name>
	<description>Must be zero for normal operation</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PCM_DIV_REG</name>
	<description>PCM divider and enables</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>PCM_SRC_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>CLK_PCM_EN</name>
	<description>Enable for the internally generated PCM clock
The PCM_DIV must be set before or together with CLK_PCM_EN.</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>PCM_DIV</name>
	<description>PCM clock divider</description>
	<access>read-write</access>
	<bitRange>[11:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PCM_FDIV_REG</name>
	<description>PCM fractional division register</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PCM_FDIV</name>
	<description>These bits define the fractional division part of the PCM clock. The left most '1' defines the denominator, the number of '1' bits define the numerator. E.g.
0x0110 means 2/9, with a distribution of 1.0001.0000
0xfeee means 13/16, with a distribution of 1111.1110.1110.1110
</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PDM_DIV_REG</name>
	<description>PDM divider and enables</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>PDM_MASTER_MODE</name>
	<description>Master mode selection
0: slave mode
1: master mode</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>CLK_PDM_EN</name>
	<description>Enable for the internally generated PDM clock
The PDM_DIV must be set before or together with CLK_PDM_EN.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>PDM_DIV</name>
	<description>PDM clock divider</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SRC_DIV_REG</name>
	<description>SRC divider and enables</description>
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>CLK_SRC_EN</name>
	<description>Enable for the internally generated SRC clock
The SRC_DIV must be set before or together with CLK_SRC_EN.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>SRC_DIV</name>
	<description>SRC clock divider</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USBPAD_REG</name>
	<description>USB pads control register</description>
	<addressOffset>0x0000004a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields>
	<field>
	<name>USBPHY_FORCE_SW2_ON</name>
	<description>0: Pull up resistor SW2 is controlled by the USB controller. It is off when the USB is not enabled.
1: Force the pull up resistor on USBP to be 2.3Kohm</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USBPHY_FORCE_SW1_OFF</name>
	<description>0: Pull up resistor SW1 is controlled by the USB controller. It is off when the USB is not enabled.
1: Force the pull up resistor on USBP to be switched off.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USBPAD_EN</name>
	<description>0: The power for the USB PHY and USB pads is switched on when the USB is enabled.
1: The power for the USB PHY and USB pads is forced on.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_TOP</name>
	<version>1.0</version>
	<description>CRG_TOP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>108</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>ANA_STATUS_REG</name>
	<description>status bit of analog (power management) circuits</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000090</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COMP_1V8_PA_HIGH</name>
	<description>VDD1V8P &gt; 1.7V </description>
	<access>read-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>COMP_1V8_FLASH_HIGH</name>
	<description>VDD1V8 &gt; 1.7V</description>
	<access>read-only</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>COMP_V33_HIGH</name>
	<description>V33 &gt; 1.7V</description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>COMP_VBUS_LOW</name>
	<description>VBUS &gt; 3.4V</description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>COMP_VBUS_HIGH</name>
	<description>VBUS &gt; 4V</description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>LDO_1V8_FLASH_OK</name>
	<description>ldo_vdd1v8 = ok</description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>LDO_1V8_PA_OK</name>
	<description>ldo_vdd1v8P = ok</description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>LDO_CORE_OK</name>
	<description>ldo_core = ok</description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>COMP_VDD_HIGH</name>
	<description>VDD &gt; 1.13V</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>BANDGAP_OK</name>
	<description>bandgap = ok
</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>LDO_SUPPLY_USB_OK</name>
	<description>ldo_supply_usb = ok</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>LDO_SUPPLY_VBAT_OK</name>
	<description>ldo_supply_vbat =ok</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>NEWBAT</name>
	<description>new battery has been detected</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>VBUS_AVAILABLE</name>
	<description>vbus is available (vbus &gt; vbat)</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>COMP_VBAT_OK</name>
	<description>vbat &gt; 1.7V</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>LDO_RADIO_OK</name>
	<description>ldo_radio = ok</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>AON_SPARE_REG</name>
	<description>Spare register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>EN_BUSSYS_RET</name>
	
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>EN_BATSYS_RET</name>
	
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>OSC16_SH_DISABLE</name>
	<description>bias in tracking mode</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>OSC16_HOLD_AMP_REG</name>
	<description>freezes amplitude regulation</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BANDGAP_REG</name>
	<description>bandgap trimming</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LDO_SUPPLY_USE_BGREF</name>
	<description>0x0 -&gt; LDO_SUPPLY_(VBAT/USB) uses V12 voltage/(V12/2Mohm) current as reference
0x1 -&gt; LDO_SUPPLY_(VBAT/USB) uses bandgap voltage/bandgap current (1uA) as reference -&gt; set 0x1 in (booter-)software
Switch to 0x1 at start of user application when maximum BOD functionality is switched on.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>LDO_SLEEP_TRIM</name>
	<description>0x4 --&gt; 1120 mV
0x5 --&gt; 1089 mV
0x6 --&gt; 1058 mV
0x7 --&gt; 1030 mV
0x0 --&gt; 1037 mV
0x1 --&gt; 1005 mV
0x2 --&gt; 978 mV
0x3 --&gt; 946 mV
0x8 --&gt; 952 mV
0x9 --&gt; 918 mV
0xA --&gt; 889 mV
0xB --&gt; 861 mV
0xC --&gt; 862 mV
0xD --&gt; 828 mV
0xE --&gt; 798 mV
0xF --&gt; 770 mV
These values are from simulation and vary over corners</description>
	<access>read-write</access>
	<bitRange>[13:10]</bitRange>
	
</field><field>
	<name>BGR_ITRIM</name>
	<description>Current trimming for bias </description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>BGR_TRIM</name>
	<description>Trim register for bandgap </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BOD_CTRL2_REG</name>
	<description>Brown Out Detection control register</description>
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>BOD_V14_EN</name>
	<description>V14 BOD Enable</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BOD_VBAT_EN</name>
	<description>VBAT BOD Enable</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>BOD_1V8_FLASH_EN</name>
	<description>1V8 Flash BOD Enable</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>BOD_1V8_PA_EN</name>
	<description>1V8 PA BOD Enable</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BOD_V33_EN</name>
	<description>V33 BOD Enable</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>BOD_VDD_EN</name>
	<description>VDD BOD Enable</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>BOD_RESET_EN</name>
	<description>Generate a chip reset on BOD event</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BOD_CTRL_REG</name>
	<description>Brown Out Detection control register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000007aa</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>BOD_VDD_LVL</name>
	<description>VDD BOD Level; 0=700mV; 1=700mV; 3=800mV; 7=1.05V</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>BOD_V33_TRIM</name>
	<description>V33 BOD Trimming bits</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>BOD_1V4_TRIM</name>
	<description>1V4 BOD Trimming bits</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>BOD_1V8_TRIM</name>
	<description>1V8 PA &amp; Flash BOD Trimming bits</description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>BOD_VDD_TRIM</name>
	<description>VDD BOD Trimming bits</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BOD_STATUS_REG</name>
	<description>Brown Out Detection status register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>BOD_V14_LOW</name>
	<description>Indicates V14 &gt; V14_Trigger</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>BOD_VBAT_LOW</name>
	<description>Indicates VBAT &gt; VBAT_Trigger</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>BOD_V33_LOW</name>
	<description>Indicates V33 &gt; V33_Trigger</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BOD_1V8_FLASH_LOW</name>
	<description>Indicates V18_Flash &gt; V18_Flash_Trigger</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>BOD_1V8_PA_LOW</name>
	<description>Indicates V18_PA &gt; V18_PA_Trigger</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>BOD_VDD_LOW</name>
	<description>Indicates VDD &gt; VDD_Trigger</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_16M_REG</name>
	<description>16 MHz RC and xtal oscillator register</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000054a0</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RC16M_STARTUP_DISABLE</name>
	<description>Gates the RC16M enable from the startup block.
The enable from the clksel and CLK_16M_REG[0] are not gated by this bit.</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>XTAL16_HPASS_FLT_EN</name>
	<description>enables high pass filter
</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>XTAL16_SPIKE_FLT_BYPASS</name>
	<description>bypasses spikefilter</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>XTAL16_AMP_TRIM</name>
	<description>sets xtal amplitude, 0 is minimum, 101 is maximum</description>
	<access>read-write</access>
	<bitRange>[12:10]</bitRange>
	
</field><field>
	<name>XTAL16_EXT_CLK_ENABLE</name>
	<description>Uses the signal on the xtal-p pin as the clock, the xtal-n pin can float. </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>XTAL16_MAX_CURRENT</name>
	<description>Uses the maximum current, for testing purpose only.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>XTAL16_CUR_SET</name>
	<description>start-up current for the 16MHz XTAL oscillator. 000 is minimum, 110 is maximum. </description>
	<access>read-write</access>
	<bitRange>[7:5]</bitRange>
	
</field><field>
	<name>RC16M_TRIM</name>
	<description>0000 = lowest frequency
1111 = highest frequency </description>
	<access>read-write</access>
	<bitRange>[4:1]</bitRange>
	
</field><field>
	<name>RC16M_ENABLE</name>
	<description>Enables the 16MHz RC oscillator </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_32K_REG</name>
	<description>32 kHz oscillator register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000007ae</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>XTAL32K_XTAL1_BIAS_DISABLE</name>
	<description>Disables the 1nA bias current through the pull down diode</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>XTAL32K_DISABLE_AMPREG</name>
	<description>Setting this bit disables the amplitude regulation of the XTAL32kHz oscillator.
Set this bit to '1' for an external clock to XTAL32Kp
Keep this bit '0' with a crystal between XTAL32Kp and XTAL32Km</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>RC32K_TRIM</name>
	<description>0000 = lowest frequency
0111 = default
1111 = highest frequency </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>RC32K_ENABLE</name>
	<description>Enables the 32kHz RC oscillator </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>XTAL32K_CUR</name>
	<description>Bias current for the 32kHz XTAL oscillator. 0000 is minimum, 1111 is maximum, 0011 is default. For each application there is an optimal setting for which the start-up behavior is optimal </description>
	<access>read-write</access>
	<bitRange>[6:3]</bitRange>
	
</field><field>
	<name>XTAL32K_RBIAS</name>
	<description>Setting for the bias resistor. 00 is maximum, 11 is minimum. Prefered setting will be provided by Dialog </description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>XTAL32K_ENABLE</name>
	<description>Enables the 32kHz XTAL oscillator </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_AMBA_REG</name>
	<description>HCLK, PCLK, divider and clock gates</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000022</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields>
	<field>
	<name>QSPI_ENABLE</name>
	<description>Clock enable for QSPI controller </description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>QSPI_DIV</name>
	<description>QSPI divider
00 = divide by 1
01 = divide by 2
10 = divide by 4
11 = divide by 8</description>
	<access>read-write</access>
	<bitRange>[11:10]</bitRange>
	
</field><field>
	<name>OTP_ENABLE</name>
	<description>Clock enable for OTP controller </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>TRNG_CLK_ENABLE</name>
	<description>Clock enable for TRNG block </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>ECC_CLK_ENABLE</name>
	<description>Clock enable for ECC block </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>AES_CLK_ENABLE</name>
	<description>Clock enable for AES crypto block </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>PCLK_DIV</name>
	<description>APB interface clock, Cascaded with HCLK:
00 = divide hclk by 1
01 = divide hclk by 2
10 = divide hclk by 4
11 = divide hclk by 8 </description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>HCLK_DIV</name>
	<description>AHB interface and microprocessor clock. Source clock divided by:
000 = divide hclk by 1
001 = divide hclk by 2
010 = divide hclk by 4
011 = divide hclk by 8
1xx = divide hclk by 16</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_CTRL_REG</name>
	<description>Clock control register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00002001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RUNNING_AT_PLL96M</name>
	<description>Indicates that the PLL96MHz clock is used as clock, and may not be switched off </description>
	<access>read-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>RUNNING_AT_XTAL16M</name>
	<description>Indicates that the XTAL16M clock is used as clock, and may not be switched off </description>
	<access>read-only</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>RUNNING_AT_RC16M</name>
	<description>Indicates that the RC16M clock is used as clock </description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>RUNNING_AT_32K</name>
	<description>Indicates that either the RC32k or XTAL32k is being used as clock </description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DIVN_SHIFT_SEL</name>
	<description>In 32MHz mode, select the clock to be in or out of phase w.r.t. RF clock.
0 : 180 degrees shifted
1 : 0 degrees shifted</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>CLK32K_SOURCE</name>
	<description>Sets the clock source of the LowerPower clock
'00': 32 Khz RC Oscillator
'01': RCX Oscillator
'10': XTAL32kHz, when using an external crystal i.c.w. the internal oscillator (set P20 and P21 to FUNC_XTAL32)
'11': XTAL32kHz, when an external generator or MCU applies a square wave on P20 (set P20 to FUNC_GPIO)</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>DIVN_SYNC_LEVEL</name>
	<description>Level of the RF divider to sync with in case XTAL32_MODE is set.
This is used to align the internal DIVN clock XTAL@32MHz divided by 2 with the radio clock</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>DIVN_XTAL32M_MODE</name>
	<description>Enables the DIVN divide-by-2, in case of a 32 MHz crystal (See also XTAL32M_MODE), to keep the DIVN clock at 16 MHz.</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>PLL_DIV2</name>
	<description>Divides the PLL clock by 2 before being used</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_CLK_SRC</name>
	<description>Selects the USB source clock
0 : PLL clock, divided by 2
1 : HCLK</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>XTAL32M_MODE</name>
	<description>Enables dividers in the XTAL for both the RF and the BB PLL.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>XTAL16M_DISABLE</name>
	<description>Setting this bit instantaneously disables the 16 MHz crystal oscillator. This bit may not be set to '1' when "RUNNING_AT_XTAL16M is '1' to prevent deadlock. After resetting this bit, wait for XTAL16_TRIM_READY to become '1' before switching to XTAL16 clock source. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SYS_CLK_SEL</name>
	<description>Selects the clock source.
0x0 : XTAL16M (check the XTAL16_TRIM_READY bit!!)
0x1 : RC16M
0x2 : The Low Power clock is used
0x3 : The PLL96Mhz is used</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_FREQ_TRIM_REG</name>
	<description>Xtal frequency trimming register.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>COARSE_ADJ</name>
	<description>Xtal frequency course trimming register.
0x0 = lowest frequency
0x7 = highest frequencyIncrement or decrement the binary value with 1. Wait approximately 200usec to allow the adjustment to settle. </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>FINE_ADJ</name>
	<description>Xtal frequency fine trimming register.0x00 = lowest frequency
0xFF = highest frequency </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_RADIO_REG</name>
	<description>Radio PLL control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>FTDF_MAC_ENABLE</name>
	<description>Enable the FTDF MAC core clocks </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>FTDF_MAC_DIV</name>
	<description>Division factor for FTCF MAC clock, relative to the DIVN clock
00 = Divide by 1
01 = Divide by 2
10 = Divide by 4
11 = Divide by 8
It should always be set to 00.</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>BLE_ENABLE</name>
	<description>Enable the BLE core clocks.
When the BLE system clock is disabled, either due to the CLK_RADIO_REG[BLE_ENABLE] or due to the PMU_CTRL_REG[BLE_SLEEP], then any access to the BLE Register file will issue a hard fault to the CPU.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>BLE_LP_RESET</name>
	<description>Reset for the BLE LP timer </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BLE_DIV</name>
	<description>Division factor for BLE core blocks, having as reference the DIVN clock:
00 = Divide by 1
01 = Divide by 2
10 = Divide by 4
11 = Divide by 8
The programmed frequency should not be lower than 8MHz, not faster than 16MHz and not faster than the programmed CPU clock frequency. Refer also to BLE_CNTL2_REG[BLE_CLK_SEL].</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>RFCU_ENABLE</name>
	<description>Enable the RF control Unit clock </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RFCU_DIV</name>
	<description>Division factor for RF Control Unit
0x0 = divide by 1
0x1 = divide by 2
0x2 = divide by 4
0x3 = divide by 8
The programmed frequency must be exactly 8MHz. </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_RCX20K_REG</name>
	<description>RCX-oscillator control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000004c2</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>RCX20K_ENABLE</name>
	<description>Enable the RCX oscillator</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>RCX20K_LOWF</name>
	<description>Extra low frequency</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>RCX20K_BIAS</name>
	<description>Bias control</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>RCX20K_NTC</name>
	<description>Temperature control</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>RCX20K_TRIM</name>
	<description>0000 = lowest frequency
0111 = default
1111 = highest frequency </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CLK_TMR_REG</name>
	<description>Clock control for the timers</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>P06_TMR1_PWM_MODE</name>
	<description>Maps Timer1_pwm onto P06, when DEBUGGER_EN = '0'.
This state is preserved during deep sleep, to allow PWM output on the pad during deep sleep.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>WAKEUPCT_ENABLE</name>
	<description>Enables the clock</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>BREATH_ENABLE</name>
	<description>Enables the clock</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>TMR2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TMR2_ENABLE</name>
	<description>Enable timer clock</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>TMR2_DIV</name>
	<description>Division factor for Timer
0x0 = divide by 1
0x1 = divide by 2
0x2 = divide by 4
0x3 = divide by 8 </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>TMR1_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>TMR1_ENABLE</name>
	<description>Enable timer clock</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>TMR1_DIV</name>
	<description>Division factor for Timer
0x0 = divide by 1
0x1 = divide by 2
0x2 = divide by 4
0x3 = divide by 8 </description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>TMR0_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>TMR0_ENABLE</name>
	<description>Enable timer clock</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>TMR0_DIV</name>
	<description>Division factor for Timer
0x0 = divide by 1
0x1 = divide by 2
0x2 = divide by 4
0x3 = divide by 8 </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DISCHARGE_RAIL_REG</name>
	<description>Immediate rail resetting. There is no LDO/DCDC gating</description>
	<addressOffset>0x0000006a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields>
	<field>
	<name>RESET_V18P</name>
	<description>1: Enables immediate discharging of the V18P rail. Note that the source is not disabled.
0: disable immediate discharging of the V18P rail.
This bit is ORed with the automatic function controlled by PMU_RESET_RAIL_REG.RESET_V18P</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RESET_V18</name>
	<description>1: Enables immediate discharging of the V18 rail. Note that the source is not disabled.
0: disable immediate discharging of the V18 rail.
This bit is ORed with the automatic function controlled by PMU_RESET_RAIL_REG.RESET_V18</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RESET_V14</name>
	<description>1: Enables immediate discharging of the V14 rail. Note that the source is not disabled.
0: disable immediate discharging of the V14 rail.
This bit is ORed with the automatic function controlled by PMU_RESET_RAIL_REG.RESET_V14</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FORCE_SLEEP_REG</name>
	<description>Force FTDF/BLE to sleep</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>FORCE_BLE_SLEEP</name>
	<description>Once set, the BLE can't be woken up
This bit is set only, and reset with HW reset</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>FORCE_FTDF_SLEEP</name>
	<description>Once set, the FTDF can't be woken up
This bit is set only, and reset with HW reset</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>LDOS_DISABLE_REG</name>
	<description>Force off all LDOs</description>
	<addressOffset>0x00000062</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>LDOS_DISABLE</name>
	<description>If set to '1', the following LDOS are disabled:
LDO_SUPPLY_VBAT (V33)
LDO_SUPPLY_VBUS (V33)
LDO_VBAT_RET (V33)
LDO_1V8_PA
LDO_1V8_PA_RET
LDO_1V8_FLASH
LDO_1V8_FLASH_RET
LDO_CORE (VDD1V2)
</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>LDO_CTRL1_REG</name>
	<description>LDO control register</description>
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000057</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>LDO_RADIO_ENABLE</name>
	<description>Enables (1) or disables (0) LDO_RADIO
For fast XTAL startup, this bit may be kept to '1' during deep sleep. The LDO is switched off automatically when in deep sleep, and enabled when waking up.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>LDO_RADIO_SETVDD</name>
	<description>Sets the output voltage of LDO_RADIO
000 = 1.30 V
001 = 1.35 V
010 = 1.40 V
011 = 1.45 V
1XX = 1.50 V</description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>LDO_CORE_SETVDD</name>
	<description>Sets the output voltage of LDO_CORE
000 = 1.20 V
001 = 1.15 V
010 = 1.10 V
011 = 1.05 V
1XX = 1.32 V</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>LDO_SUPPLY_USB_LEVEL</name>
	<description>Sets the output voltage of LDO_SUPPLY_USB
00 = 2.40 V
01 = 3.30 V
10 = 3.45 V
11 = 3.60 V</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>LDO_SUPPLY_VBAT_LEVEL</name>
	<description>Sets the output voltage of LDO_SUPPLY_VBAT
00 = 2.40 V
01 = 3.30 V
10 = 3.45 V
11 = 3.60 V</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>LDO_VBAT_RET_LEVEL</name>
	<description>Sets the output voltage of LDO_VBAT_RET
00 = 2.40 V
01 = 3.30 V
10 = 3.45 V
11 = 3.60 V</description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>LDO_CORE_CURLIM</name>
	<description>Sets the current limit of LDO_CORE
00 = Current limiter disabled
01 = 8 mA
10 = 60 mA
11 = 80 mA</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>LDO_CTRL2_REG</name>
	<description>LDO control register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>LDO_1V8_PA_RET_DISABLE</name>
	<description>Disables (1) or enables (0) LDO_1V8_PA_RET</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>LDO_1V8_FLASH_RET_DISABLE</name>
	<description>Disables (1) or enables (0) LDO_1V8_FLASH_RET</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>LDO_VBAT_RET_DISABLE</name>
	<description>Disables (1) or enables (0) LDO_VBAT_RET</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>LDO_1V8_PA_ON</name>
	<description>Enables (1) or disables (0) LDO_1V8_PA</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>LDO_1V8_FLASH_ON</name>
	<description>Enables (1) or disables (0) LDO_1V8_FLASH</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>LDO_3V3_ON</name>
	<description>Enables (1) or disables (0) LDO_SUPPLY_VBAT and LDO_SUPPLY_USB</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>LDO_1V2_ON</name>
	<description>Enables (1) or disables (0) LDO_CORE</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>LDO_CTRL3_REG</name>
	<description>Retention LDO control register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>LDO_1V8_PA_RET_VREF_HOLD</name>
	<description>Setting of this register is "ORed" with the vref_hold
control from the CRG StateMachine.
"0" = CRG controls the T&amp;H of Vref.
"1" = T&amp;H is always in "Hold"</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>LDO_1V8_PA_RET_ENABLE</name>
	<description>Setting of this register is "ORed" with the ldo_enable
control from the CRG StateMachine.
"0" = CRG controls the enable of the LDO.
"1" = LDO is always enabled
To activate a retention LDO in "active-mode", this bit
must be "1" and the VREF_HOLD bit must be "0".</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>LDO_1V8_FLASH_RET_VREF_HOLD</name>
	<description>Setting of this register is "ORed" with the vref_hold
control from the CRG StateMachine.
"0" = CRG controls the T&amp;H of Vref.
"1" = T&amp;H is always in "Hold"</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>LDO_1V8_FLASH_RET_ENABLE</name>
	<description>Setting of this register is "ORed" with the ldo_enable
control from the CRG StateMachine.
"0" = CRG controls the enable of the LDO.
"1" = LDO is always enabled
To activate a retention LDO in "active-mode", this bit
must be "1" and the VREF_HOLD bit must be "0".</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>LDO_VBAT_RET_VREF_HOLD</name>
	<description>Setting of this register is "ORed" with the vref_hold
control from the CRG StateMachine.
"0" = CRG controls the T&amp;H of Vref.
"1" = T&amp;H is always in "Hold"</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>LDO_VBAT_RET_ENABLE</name>
	<description>Setting of this register is "ORed" with the ldo_enable
control from the CRG StateMachine.
"0" = CRG controls the enable of the LDO.
"1" = LDO is always enabled
To activate a retention LDO in "active-mode", this bit
must be "1" and the VREF_HOLD bit must be "0".</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PMU_CTRL_REG</name>
	<description>Power Management Unit control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RETAIN_ECCRAM</name>
	<description>Selects the retainability of the ECC u-Code RAM during deep sleep.
'1' is retainable, '0' is power gated</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>RETAIN_CACHE</name>
	<description>Selects the retainability of the cache block during deep sleep.
'1' is retainable, '0' is power gated</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>ENABLE_CLKLESS</name>
	<description>Selects the clockless sleep mode. Wakeup is done asynchronously.
When set to '1', the lp_clk is stopped during deep sleep, until a wakeup event (not debounced) is detected by the WAKUPCT block.
When set to '0', the lp_clk continues running, so the MAC counters keep on running.
This mode cannot be combined with regulated sleep, so keep SLEEP_TIMER=0 when using ENABLE_CLKLESS.</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>RETAIN_RAM</name>
	<description>Select the retainability of the 5 system memory RAM macros during deep sleep.
'1' is retainable, '0' is power gated
(4) is SYSRAM5
(3) is SYSRAM4
(2) is SYSRAM3
(1) is SYSRAM2
(0) is SYSRAM1</description>
	<access>read-write</access>
	<bitRange>[12:8]</bitRange>
	
</field><field>
	<name>OTP_COPY_DIV</name>
	<description>Sets the HCLK division during OTP mirroring </description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>RESET_ON_WAKEUP</name>
	<description>Perform a Hardware Reset after waking up. Booter will be started. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>MAP_BANDGAP_EN</name>
	<description>Maps the bandgap_enable to P06 </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>FTDF_SLEEP</name>
	<description>Put the FTDF in powerdown </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BLE_SLEEP</name>
	<description>Put the BLE in powerdown.
When the BLE system clock is disabled, either due to the CLK_RADIO_REG[BLE_ENABLE] or due to the PMU_CTRL_REG[BLE_SLEEP], then any access to the BLE Register file will issue a hard fault to the CPU.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RADIO_SLEEP</name>
	<description>Put the digital part of the radio in powerdown </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>PERIPH_SLEEP</name>
	<description>Put all peripherals (I2C, UART, SPI, ADC) in powerdown </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PMU_RESET_RAIL_REG</name>
	<description>Controls rail resetting when RST is pulsed</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields>
	<field>
	<name>RESET_V18P</name>
	<description>1: Enables discharging of the V18P rail when HW reset is pressed
0: this rail will not be discharged when HW reset is pressed
</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RESET_V18</name>
	<description>1: Enables discharging of the V18 rail when HW reset is pressed
0: this rail will not be discharged when HW reset is pressed
</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RESET_V14</name>
	<description>1: Enables discharging of the V14 rail when HW reset is pressed
0: this rail will not be discharged when HW reset is pressed</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>POR_VBAT_CTRL_REG</name>
	<description>Controls the POR on VBAT</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000326f</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>POR_VBAT_MASK_N</name>
	<description>Enables propagation of the generated POR</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>POR_VBAT_ENABLE</name>
	<description>Enables generation of the POR</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>POR_VBAT_HYST_LOW</name>
	<description>Controls hysteresis of POR. 20mV per step. Must be set to 0x2 when thres_ctrl_low is set to 0xf.</description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>POR_VBAT_THRES_HIGH</name>
	<description>High-side (PTAT) threshold contribution:
Level --&gt; Threshold
0x0 --&gt; 1.25V
0x1 --&gt; 1.27V
0x2 --&gt; 1.29V
0x3 --&gt; 1.31V
0x4 --&gt; 1.44V
0x5 --&gt; 1.49V
0x6 --&gt; 1.53V
0x7 --&gt; 1.58V
0x8 --&gt; 1.63V
0x9 --&gt; 1.68V
0xA --&gt; 1.73V
0xB --&gt; 1.78V0xC --&gt; 1.83V0xD --&gt; 1.87V0xE --&gt; 1.92V
0xF --&gt; 1.97V
</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>POR_VBAT_THRES_LOW</name>
	<description>Low-side (CTAT) threshold contribution
Level --&gt; Threshold
0xC --&gt; 1.25V
0xC --&gt; 1.27V
0xC --&gt; 1.29V
0xC --&gt; 1.31V
0x0 --&gt; 1.44V
0x1 --&gt; 1.49V
0x2 --&gt; 1.53V
0x3 --&gt; 1.58V
0x4 --&gt; 1.63V
0x5 --&gt; 1.68V
0x6 --&gt; 1.73V
0x7 --&gt; 1.78V
0x8 --&gt; 1.83V
0x9 --&gt; 1.87V
0xA --&gt; 1.92V
0xB --&gt; 1.97V
0xF --&gt; 1.63V; use only with POR_VBAT_THRES_LOW=0x6 and POR_VBAT_THRES_HYST=0x2</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>POWER_CTRL_REG</name>
	<description>Power control register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields>
	<field>
	<name>TRIM_NEWBAT</name>
	
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RESET_STAT_REG</name>
	<description>Reset status register</description>
	<addressOffset>0x0000005e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000001f</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>SWD_HWRESET_STAT</name>
	<description>Indicates that a write to SWD_RESET_REG has happened. Note thatit is also set when a POReset has happened.</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>WDOGRESET_STAT</name>
	<description>Indicates that a Watchdog has happened. Note that it is also set when a POReset has happened.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SWRESET_STAT</name>
	<description>Indicates that a SW Reset has happened</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>HWRESET_STAT</name>
	<description>Indicates that a HW Reset has happened</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>PORESET_STAT</name>
	<description>Indicates that a PowerOn Reset has happened</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SECURE_BOOT_REG</name>
	<description>Controls secure booting</description>
	<addressOffset>0x00000066</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>FORCE_DEBUGGER_OFF</name>
	<description>Follows the respective OTP flag value. Is write-one-only and will be reset by POR only! Its value is updated by the BootROM code.
1: The system debugger SWD is totally disabled.
0: The system debugger is enabled with DEBUGGER_ENABLE</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SECURE_BOOT</name>
	<description>Follows the respective OTP flag value. Is write-one-only and will be reset by POR only! Its value is updated by the BootROM code.
1: system is a secure system supporting secure boot
0: system is not supporting secure boot
</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SLEEP_TIMER_REG</name>
	<description>Timer for regulated sleep</description>
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SLEEP_TIMER</name>
	<description>Defines the amount of ticks of the sleep clock between enabling the bandgap for re-charging the retention LDOs. This value depends on the load and should be calibrated on a per application basis.If set to 0, no recharging cycle will happen at all.
Keep this value to 0 (no recharging) when using the clockless sleep.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>STARTUP_STATUS_REG</name>
	<description>Startup timeout bits</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SU_BOD_STATUS</name>
	<description>0b011 brownout on V14
0b100 brownout on vdd
0b101 brownout on v18_flash
0b110 brownout on v18_pa
0b111 brownout on v33</description>
	<access>read-only</access>
	<bitRange>[15:13]</bitRange>
	
</field><field>
	<name>SU_LDO_1V8_FLASH_OK</name>
	
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>SU_COMP_1V8_FLASH_HIGH</name>
	
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>SU_COMP_1V8_PA_HIGH</name>
	
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>SU_COMP_VBUS_LOW</name>
	
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>SU_COMP_VBUS_HIGH</name>
	
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>SU_COMP_V33_HIGH</name>
	
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SU_COMP_VDD_HIGH</name>
	
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>SU_LDO_1V8_PA_OK</name>
	
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>SU_LDO_CORE_OK</name>
	
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>SU_LOD_SUPPLY_USB_OK</name>
	
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SU_LDO_SUPPLY_VBAT_OK</name>
	
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SU_NEWBAT</name>
	
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SU_BANDGAP_OK</name>
	
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SYS_CTRL_REG</name>
	<description>System Control register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SW_RESET</name>
	<description>Writing a '1' to this bit will generate a SW_RESET.</description>
	<access>write-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>REMAP_INTVECT</name>
	<description>0: normal operation
1: If ARM is in address range 0 to 0x1FF then the address is remapped to SYS-RAM 0x07FC.0000 to 0x07FC.01FF. This allows to put the interrupt vector table to be placed in RAM while executing from QSPI</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>OTP_COPY</name>
	<description>Enables OTP to SysRAM copy action after waking up PD_SYS </description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>QSPI_INIT</name>
	<description>Enables QSPI initialization after wakeup</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DEV_PHASE</name>
	<description>Sets the development phase mode, used in combination with OTP_COPY
No copy action to SysRAM is done when the system wakes up.
For emulating startup time, the OTP_COPY bit still needs to be set. </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>CACHERAM_MUX</name>
	<description>Controls accessiblity of Cache RAM:
0: the cache controller is bypassed, the cacheRAM is visible in the memory space next to the DataRAMs
1: the cache controller is enabled, the cacheRAM is not visible anymore in the memory space</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>TIMEOUT_DISABLE</name>
	<description>Disables timeout in Power statemachine. By default, the statemachine continues if after 2 ms the blocks are not started up. This can be read back from
ANA_STATUS_REG</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>DRA_OFF</name>
	<description>Disables the DRA mode, and released the ARM reset</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DEBUGGER_ENABLE</name>
	<description>Enable the debugger. This bit is set by the booter according to the OTP header. If not set, the SWDIO and SW_CLK can be used as gpio ports. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>OTPC_RESET_REQ</name>
	<description>Reset request for the OTP controller. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>PAD_LATCH_EN</name>
	<description>Latches the control signals of the pads for state retention in powerdown mode.
0 = Control signals are retained
1 = Latch is transparant, pad can be recontrolled </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>REMAP_RAMS</name>
	<description>Defines the sequence of the 3 first DataRAMs in the memory space. DataRAM4, DataRAM5 and potentially CacheRAM, cannot not be reshuffled.
0x0: DataRAM1, DataRAM2, DataRAM3
0x1: DataRAM2, DataRAM1, DataRAM3
0x2: DataRAM3, DataRAM1, DataRAM2
0x3: DataRAM3, DataRAM2, DataRAM1</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>REMAP_ADR0</name>
	<description>Controls which memory is located at address 0x0000 for execution.
0x0: ROM
0x1: OTP
0x2: FLASH
0x3: RAMS (for the exact configuration see REMAP_RAMS)
0x4: FLASH un-cached (for verification only)
0x5: OTP un-cached (for verification only)
0x6: Cache Data RAM (CACHERAM_MUX=0, for testing purposes only)
Note 1: DWord (64 bits) access is not supported by the Cache Data RAM interface in mirrored mode (only 32, 16 and 8 bits).
Note 2: DMA access is not supported by the Cache Data RAM interface when REMAP_ADR0=0x6.</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SYS_STAT_REG</name>
	<description>System status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000005d5</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>FTDF_IS_UP</name>
	<description>Indicates that PD_DBG is functional </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>FTDF_IS_DOWN</name>
	<description>Indicates that PD_DBG is in power down </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>BLE_IS_UP</name>
	<description>Indicates that PD_DBG is functional </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>BLE_IS_DOWN</name>
	<description>Indicates that PD_DBG is in power down </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>XTAL16_SETTLE_READY</name>
	<description>Indicates that the XTAL16_CLK_CNT has reached the XTAL_SETTLE_N threshold.</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>XTAL16_TRIM_READY</name>
	<description>Indicates that XTAL trimming mechanism is ready, i.e. the trimming equals CLK_FREQ_TRIM_REG. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DBG_IS_ACTIVE</name>
	<description>Indicates that a debugger is attached.</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>XTAL16_SW2</name>
	<description>Indicates the switching moment SW2 has happened.</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>PER_IS_UP</name>
	<description>Indicates that PD_PER is functional </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>PER_IS_DOWN</name>
	<description>Indicates that PD_PER is in power down </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RAD_IS_UP</name>
	<description>Indicates that PD_RAD is functional </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RAD_IS_DOWN</name>
	<description>Indicates that PD_RAD is in power down </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TRIM_CTRL_REG</name>
	<description>Control trimming of the XTAL16M</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003f22</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>XTAL_SETTLE_N</name>
	<description>Designates that the XTAL16 can be safely used as the CPU clock. When XTAL16_CLK_CNT reases this value, the signal XTAL_SETTLE_READY will be set</description>
	<access>read-write</access>
	<bitRange>[13:8]</bitRange>
	
</field><field>
	<name>XTAL_TRIM_SELECT</name>
	<description>Select which source controls the XTAL trimming
0b00: xtal counter. Starts XTAL16M_START_REG, after COUNT_N * 32 xtal pulses trim is changed to CLK_FREQ_TRIM_REG.
0b01: xtal OK filter. Starts with XTAL16M_START_REG, when xtal is ramping is changed to CLK_FREQ_TRIM_REG
0b10: statically forced off. Only uses CLK_FREQ_TRIM_REG.
0b11: xtal OK filter, 2 stage. Starts with XTAL16M_START_REG switches to XTAL16M_RAMP_REG when sw1='1', and switches to CLK_FREQ_TRIM_REG when sw2='1'.</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>XTAL_COUNT_N</name>
	<description>Defines the number of XTAL cycles to be counted, before the xtal trimming is applied, in steps of 32.
0x01: 32
0x02: 64
0x3f:2016 </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>VBUS_IRQ_CLEAR_REG</name>
	<description>Clear pending IRQ register</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>VBUS_IRQ_CLEAR</name>
	<description>Writing any value to this register will reset the VBUS_IRQ line</description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>VBUS_IRQ_MASK_REG</name>
	<description>IRQ masking</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>VBUS_IRQ_EN_RISE</name>
	<description>Setting this bit to '1' enables VBUS_IRQ generation when the VBUS starts to ramp above threshold</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>VBUS_IRQ_EN_FALL</name>
	<description>Setting this bit to '1' enables VBUS_IRQ generation when the VBUS starts to fall below threshold</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>XTAL16M_CTRL_REG</name>
	<description>Control register for XTAL16M</description>
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>XTAL16M_ENABLE_ZERO</name>
	
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>XTAL16M_SH_OVERRULE</name>
	<description>Overrule of the XTAL bias sampling:
0b01 = Continues tracking.
0b1x = Sampled and hold.
0b00 = normal function (following closed loop enable)</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>XTAL16M_TST_AON</name>
	
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>XTAL16M_AMP_REG_SIG_SEL</name>
	
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>XTAL16M_FREQ_TRIM_SW2_AMP</name>
	
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>XTAL16M_RAMP_REG</name>
	<description>Xtal frequency trimming register during ramping</description>
	<addressOffset>0x0000005a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000300</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>COARSE_ADJ</name>
	<description>Xtal frequency course trimming register.
0x0 = lowest frequency
0x7 = highest frequencyIncrement or decrement the binary value with 1. Wait approximately 200usec to allow the adjustment to settle. </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>FINE_ADJ</name>
	<description>Xtal frequency fine trimming register.0x00 = lowest frequency
0xFF = highest frequency </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>XTAL16M_START_REG</name>
	<description>Xtal frequency trimming register during startup</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>COARSE_ADJ</name>
	<description>Xtal frequency course trimming register.
0x0 = lowest frequency
0x7 = highest frequencyIncrement or decrement the binary value with 1. Wait approximately 200usec to allow the adjustment to settle. </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>FINE_ADJ</name>
	<description>Xtal frequency fine trimming register.0x00 = lowest frequency
0xFF = highest frequency </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>XTAL16M_TRSTAT_REG</name>
	<description>Read back value of current XTAL trimming</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>XTAL16M_TRSTAT</name>
	<description>Read value of the current XTAL trimming</description>
	<access>read-only</access>
	<bitRange>[14:0]</bitRange>
	
</field></fields>
</register><register>
	<name>XTALRDY_CTRL_REG</name>
	<description>Control register for XTALRDY IRQ</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>XTALRDY_CNT</name>
	<description>Number of LP cycles between the crystal is enabled, and the XTALRDY_IRQ is fired.
0x00: no interrupt
</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>XTALRDY_STAT_REG</name>
	<description>Difference between XTAL_OK and XTALRDY_IRQ in LP clock cycles</description>
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>XTALRDY_STAT</name>
	
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DCDC</name>
	<version>1.0</version>
	<description>DCDC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000080</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>58</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>DCDC_CTRL_0_REG</name>
	<description>DCDC First Control Register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00002f24</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>DCDC_FAST_STARTUP</name>
	<description>Set current limit to maximum during initial startup</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>DCDC_BROWNOUT_LV_MODE</name>
	<description>Switches to low voltage settings when battery voltage drops below 2.5 V</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DCDC_IDLE_CLK_DIV</name>
	<description>Idle Clock Divider
00 = 2
01 = 4
10 = 8
11 = 16</description>
	<access>read-write</access>
	<bitRange>[12:11]</bitRange>
	
</field><field>
	<name>DCDC_PRIORITY</name>
	<description>Charge priority register (4x 2 bit ID)
Charge sequence is [1:0] &gt; [3:2] &gt; [5:4] &gt; [7:6]
ID[V14] = 00
ID[V18] = 01
ID[VDD] = 10
ID[V18P] = 11</description>
	<access>read-write</access>
	<bitRange>[10:3]</bitRange>
	
</field><field>
	<name>DCDC_FW_ENABLE</name>
	<description>Freewheel switch enable</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DCDC_MODE</name>
	<description>DCDC converter mode
00 = Disabled
01 = Active
10 = Sleep mode
11 = Disabled</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_CTRL_1_REG</name>
	<description>DCDC Second Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00005410</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_STARTUP_DELAY</name>
	<description>Delay between turning bias on and converter becoming active
0 - 31 us, 1 us step size</description>
	<access>read-write</access>
	<bitRange>[15:11]</bitRange>
	
</field><field>
	<name>DCDC_GLOBAL_MAX_IDLE_TIME</name>
	<description>Global maximum idle time
The current limit of any output that is idle for this long will be downramped faster than normal
0 - 7875 ns, 125 ns step size</description>
	<access>read-write</access>
	<bitRange>[10:5]</bitRange>
	
</field><field>
	<name>DCDC_TIMEOUT</name>
	<description>P and N switch timeout, if switch is closed longer than this a timeout is generated and the FSM is forced to the next state
Writing 0 disables timeout functionality
62.5 - 1937.5 ns, 62.5 ns step size</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_CTRL_2_REG</name>
	<description>DCDC Third Control Register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000882d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_TIMEOUT_IRQ_TRIG</name>
	<description>Number of timeout events before timeout interrupt is generated</description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>DCDC_TIMEOUT_IRQ_RES</name>
	<description>Number of successive non-timed out charge events required to clear timeout event counter</description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>DCDC_TUNE</name>
	<description>Trim current sensing circuitry
00 = +0 %
01 = +4 %
10 = +8 %
11 = +12 %</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>DCDC_LSSUP_TRIM</name>
	<description>Trim low side supply voltage
V = 2 V + 100 mV * N</description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>DCDC_HSGND_TRIM</name>
	<description>Trim high side ground
V = VBAT - (2.2 V + 200 mV * N)</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_IRQ_CLEAR_REG</name>
	<description>DCDC Interrupt Clear Register</description>
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>DCDC_BROWN_OUT_IRQ_CLEAR</name>
	<description>Clear brown out interrupt</description>
	<access>write-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>DCDC_V18P_TIMEOUT_IRQ_CLEAR</name>
	<description>Clear V18P timeout interrupt</description>
	<access>write-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DCDC_VDD_TIMEOUT_IRQ_CLEAR</name>
	<description>Clear VDD timeout interrupt</description>
	<access>write-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DCDC_V18_TIMEOUT_IRQ_CLEAR</name>
	<description>Clear V18 timeout interrupt</description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DCDC_V14_TIMEOUT_IRQ_CLEAR</name>
	<description>Clear V14 timeout interrupt</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_IRQ_MASK_REG</name>
	<description>DCDC Interrupt Clear Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>DCDC_BROWN_OUT_IRQ_MASK</name>
	<description>Mask brown out interrupt</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>DCDC_V18P_TIMEOUT_IRQ_MASK</name>
	<description>Mask V18P timeout interrupt</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DCDC_VDD_TIMEOUT_IRQ_MASK</name>
	<description>Mask VDD timeout interrupt</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DCDC_V18_TIMEOUT_IRQ_MASK</name>
	<description>Mask V18 timeout interrupt</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DCDC_V14_TIMEOUT_IRQ_MASK</name>
	<description>Mask V14 timeout interrupt</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_IRQ_STATUS_REG</name>
	<description>DCDC Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>DCDC_BROWN_OUT_IRQ_STATUS</name>
	<description>Brown out detector triggered (battery voltage below 2.5 V)</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>DCDC_V18P_TIMEOUT_IRQ_STATUS</name>
	<description>Timeout occured on V18P output</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DCDC_VDD_TIMEOUT_IRQ_STATUS</name>
	<description>Timeout occured on VDD output</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DCDC_V18_TIMEOUT_IRQ_STATUS</name>
	<description>Timeout occured on V18 output</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DCDC_V14_TIMEOUT_IRQ_STATUS</name>
	<description>Timeout occured on V14 output</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_RET_0_REG</name>
	<description>DCDC First Retention Mode Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000aaa6</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18P_RET_CYCLES</name>
	<description>Charge cycles for V18P output in sleep mode
Cycles = 1 + 2 * N</description>
	<access>read-write</access>
	<bitRange>[15:13]</bitRange>
	
</field><field>
	<name>DCDC_V18P_CUR_LIM_RET</name>
	<description>V18P output sleep mode current limit
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[12:8]</bitRange>
	
</field><field>
	<name>DCDC_VDD_RET_CYCLES</name>
	<description>Charge cycles for VDD output in sleep mode
Cycles = 1 + 2 * N</description>
	<access>read-write</access>
	<bitRange>[7:5]</bitRange>
	
</field><field>
	<name>DCDC_VDD_CUR_LIM_RET</name>
	<description>VDD output sleep mode current limit
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_RET_1_REG</name>
	<description>DCDC Second Retention Mode Register</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000aa46</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18_RET_CYCLES</name>
	<description>Charge cycles for V18 output in sleep mode
Cycles = 1 + 2 * N</description>
	<access>read-write</access>
	<bitRange>[15:13]</bitRange>
	
</field><field>
	<name>DCDC_V18_CUR_LIM_RET</name>
	<description>V18 output sleep mode current limit
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[12:8]</bitRange>
	
</field><field>
	<name>DCDC_V14_RET_CYCLES</name>
	<description>Charge cycles for V14 output in sleep mode
Cycles = 1 + 2 * N</description>
	<access>read-write</access>
	<bitRange>[7:5]</bitRange>
	
</field><field>
	<name>DCDC_V14_CUR_LIM_RET</name>
	<description>V14 output sleep mode current limit
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_STATUS_0_REG</name>
	<description>DCDC First Status Register</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>DCDC_CHARGE_REG_3</name>
	<description>Charge register position 3</description>
	<access>read-only</access>
	<bitRange>[11:9]</bitRange>
	
</field><field>
	<name>DCDC_CHARGE_REG_2</name>
	<description>Charge register position 2</description>
	<access>read-only</access>
	<bitRange>[8:6]</bitRange>
	
</field><field>
	<name>DCDC_CHARGE_REG_1</name>
	<description>Charge register position 1</description>
	<access>read-only</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>DCDC_CHARGE_REG_0</name>
	<description>Charge register position 0</description>
	<access>read-only</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_STATUS_1_REG</name>
	<description>DCDC Second Status Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18P_AVAILABLE</name>
	<description>Indicates whether V18P is available
Requires that converter is enabled, output is enabled and V_OK and V_NOK have both occured</description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DCDC_VDD_AVAILABLE</name>
	<description>Indicates whether VDD is available
Requires that converter is enabled, output is enabled and V_OK and V_NOK have both occured</description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>DCDC_V18_AVAILABLE</name>
	<description>Indicates whether V18 is available
Requires that converter is enabled, output is enabled and V_OK and V_NOK have both occured</description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>DCDC_V14_AVAILABLE</name>
	<description>Indicates whether V14 is available
Requires that converter is enabled, output is enabled and V_OK and V_NOK have both occured</description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DCDC_V18P_OK</name>
	<description>OK output of V18P comparator</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>DCDC_VDD_OK</name>
	<description>OK output of VDD comparator</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DCDC_V18_OK</name>
	<description>OK output of V18 comparator</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DCDC_V14_OK</name>
	<description>OK output of V14 comparator</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>DCDC_V18P_NOK</name>
	<description>NOK output of V18P comparator</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DCDC_VDD_NOK</name>
	<description>NOK output of VDD comparator</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DCDC_V18_NOK</name>
	<description>NOK output of V18 comparator</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DCDC_V14_NOK</name>
	<description>NOK output of V14 comparator</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_STATUS_2_REG</name>
	<description>DCDC Third Status Register</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18P_SW_STATE</name>
	<description>DCDC state machine V18P output</description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DCDC_VDD_SW_STATE</name>
	<description>DCDC state machine VDD output</description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>DCDC_V18_SW_STATE</name>
	<description>DCDC state machine V18 output</description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>DCDC_V14_SW_STATE</name>
	<description>DCDC state machine V14 output</description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DCDC_NSW_STATE</name>
	<description>DCDC state machine NSW output</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>DCDC_PSW_STATE</name>
	<description>DCDC state machine PSW output</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DCDC_P_COMP_P</name>
	<description>DCDC P side dynamic comparator P output</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DCDC_P_COMP_N</name>
	<description>DCDC P side dynamic comparator N output</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>DCDC_N_COMP_P</name>
	<description>DCDC N side dynamic comparator P output</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DCDC_N_COMP_N</name>
	<description>DCDC N side dynamic comparator N output</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DCDC_P_COMP</name>
	<description>DCDC P side continuous time comparator output</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DCDC_N_COMP</name>
	<description>DCDC N side continuous time comparator output</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_STATUS_3_REG</name>
	<description>DCDC Fourth Status Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000084</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>DCDC_STARTUP_COMPLETE</name>
	<description>Indicates if the converter is enabled and the startup counter has expired (internal biasing settled)</description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DCDC_LV_MODE</name>
	<description>Indicates if the converter is in low battery voltage mode</description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>DCDC_I_LIM_V18P</name>
	<description>Actual V18P current limit</description>
	<access>read-only</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_I_LIM_VDD</name>
	<description>Actual VDD current limit</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_STATUS_4_REG</name>
	<description>DCDC Fifth Status Register</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000084</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>DCDC_I_LIM_V18</name>
	<description>Actual V18 current limit</description>
	<access>read-only</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_I_LIM_V14</name>
	<description>Actual V14 current limit</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_TEST_0_REG</name>
	<description>DCDC Test Register</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_FORCE_COMP_CLK</name>
	<description>Disables automatic comparator clock, clock lines values based on DCDC_COMP_CLK</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DCDC_FORCE_CURRENT</name>
	<description>Force output current setting</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>DCDC_OUTPUT_MONITOR</name>
	<description>Output monitor switch (connect to ADC)
000 = None
001 = V14
010 = V18
011 = VDD
100 = VPA
101 = None
110 = None
111 = None</description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>DCDC_ANA_TEST</name>
	<description>Analog test bus
000 = None
001 = High side ground
010 = Low side supply
011 = 1.2 V buffer output
100 = None
101 = None
110 = None
111 = None</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>DCDC_FORCE_IDLE</name>
	<description>Force idle mode</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>DCDC_FORCE_V18P</name>
	<description>Force V18P switch on</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DCDC_FORCE_VDD</name>
	<description>Force VDD switch on</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DCDC_FORCE_V18</name>
	<description>Force V18 switch on</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>DCDC_FORCE_V14</name>
	<description>Force V14 switch on</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DCDC_FORCE_FW</name>
	<description>Force FW switch on</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DCDC_FORCE_NSW</name>
	<description>Force N switch on</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DCDC_FORCE_PSW</name>
	<description>Force P switch on</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_TEST_1_REG</name>
	<description>DCDC Test Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields>
	<field>
	<name>DCDC_COMP_CLK</name>
	<description>Forced clock values for [COMP_VPA, COMP_VDD, COMP_V18, COMP_V14] (requires DCDC_FORCE_COMP_CLK = 1)</description>
	<access>read-write</access>
	<bitRange>[12:9]</bitRange>
	
</field><field>
	<name>DCDC_TEST_CURRENT</name>
	<description>Current limit setting when current limit is forced</description>
	<access>read-write</access>
	<bitRange>[8:4]</bitRange>
	
</field><field>
	<name>DCDC_TEST_REG</name>
	<description>Determines which register appears on the testbus
0x0 = DCDC_NONE
0x1 = DCDC_STATUS_0
0x2 = DCDC_STATUS_1
0x3 = DCDC_STATUS_2
0x4 = DCDC_STATUS_3
0x5 = DCDC_STATUS_4
0x6 = DCDC_TRIM_0
0x7 = DCDC_TRIM_1
0x8 = DCDC_TRIM_2
0x9 = DCDC_TRIM_3
0xA-0xF = DCDC_NONE</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_TRIM_0_REG</name>
	<description>DCDC V14 Comparator Trim Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>DCDC_V14_TRIM_P</name>
	<description>P comparator trim value when V14 is active
Signed magnitude representation
011111 = +47 mV
000000 = 100000 = +16 mV
111111 = -15 mV</description>
	<access>read-only</access>
	<bitRange>[11:6]</bitRange>
	
</field><field>
	<name>DCDC_V14_TRIM_N</name>
	<description>N comparator trim value when V14 is active
Signed magnitude representation
011111 = +13 mV
000000 = 100000 = -22 mV
111111 = -56 mV</description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_TRIM_1_REG</name>
	<description>DCDC V18 Comparator Trim Register</description>
	<addressOffset>0x0000002e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18_TRIM_P</name>
	<description>P comparator trim value when V18 is active
Signed magnitude representation
011111 = +47 mV
000000 = 100000 = +16 mV
111111 = -15 mV</description>
	<access>read-only</access>
	<bitRange>[11:6]</bitRange>
	
</field><field>
	<name>DCDC_V18_TRIM_N</name>
	<description>N comparator trim value when V18 is active
Signed magnitude representation
011111 = +13 mV
000000 = 100000 = -22 mV
111111 = -56 mV</description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_TRIM_2_REG</name>
	<description>DCDC VDD Comparator Trim Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>DCDC_VDD_TRIM_P</name>
	<description>P comparator trim value when VDD is active
Signed magnitude representation
011111 = +47 mV
000000 = 100000 = +16 mV
111111 = -15 mV</description>
	<access>read-only</access>
	<bitRange>[11:6]</bitRange>
	
</field><field>
	<name>DCDC_VDD_TRIM_N</name>
	<description>N comparator trim value when VDD is active
Signed magnitude representation
011111 = +13 mV
000000 = 100000 = -22 mV
111111 = -56 mV</description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_TRIM_3_REG</name>
	<description>DCDC VPA Comparator Trim Register</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18P_TRIM_P</name>
	<description>P comparator trim value when V18P is active
Signed magnitude representation
011111 = +47 mV
000000 = 100000 = +16 mV
111111 = -15 mV</description>
	<access>read-only</access>
	<bitRange>[11:6]</bitRange>
	
</field><field>
	<name>DCDC_V18P_TRIM_N</name>
	<description>N comparator trim value when V18P is active
Signed magnitude representation
011111 = +13 mV
000000 = 100000 = -22 mV
111111 = -56 mV</description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_TRIM_REG</name>
	<description>DCDC Comparator Trim Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>DCDC_P_COMP_MAN_TRIM</name>
	<description>Trim mode for P side comparator
0 = Automatic
1 = Manual</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DCDC_P_COMP_TRIM</name>
	<description>Manual trim value for P side comparator
Signed magnitude representation
011111 = +47 mV
000000 = 100000 = +16 mV
111111 = -15 mV</description>
	<access>read-write</access>
	<bitRange>[12:7]</bitRange>
	
</field><field>
	<name>DCDC_N_COMP_MAN_TRIM</name>
	<description>Trim mode for N side comparator
0 = Automatic
1 = Manual</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DCDC_N_COMP_TRIM</name>
	<description>Manual trim value for N side comparator
Signed magnitude representation
011111 = +13 mV
000000 = 100000 = -22 mV
111111 = -56 mV</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_V14_0_REG</name>
	<description>DCDC V14 First Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000a1a4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_V14_FAST_RAMPING</name>
	<description>V14 output fast current ramping (improves response time at the cost of more ripple)</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DCDC_V14_VOLTAGE</name>
	<description>V14 output voltage
V = 1.2 V + 25 mV * N</description>
	<access>read-write</access>
	<bitRange>[14:10]</bitRange>
	
</field><field>
	<name>DCDC_V14_CUR_LIM_MAX_HV</name>
	<description>V14 output maximum current limit (high battery voltage mode)
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_V14_CUR_LIM_MIN</name>
	<description>V14 output minimum current limit
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_V14_1_REG</name>
	<description>DCDC V14 Second Control Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000d890</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_V14_ENABLE_HV</name>
	<description>V14 output enable (high battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DCDC_V14_ENABLE_LV</name>
	<description>V14 output enable (low battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>DCDC_V14_CUR_LIM_MAX_LV</name>
	<description>V14 output maximum current limit low battery voltage mode)
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[13:10]</bitRange>
	
</field><field>
	<name>DCDC_V14_IDLE_HYST</name>
	<description>V14 output idle time hysteresis
0 - 3875 ns, 125 ns step size
IDLE_MAX = IDLE_MIN + IDLE_HYST
Maximum idle time before decreasing CUR_LIM</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_V14_IDLE_MIN</name>
	<description>V14 output minimum idle time
0 - 3875 ns, 125 ns step size
Minimum idle time, CUR_LIM is increased if this limit is not reached</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_V18P_0_REG</name>
	<description>DCDC VPA First Control Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000e3e4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18P_FAST_RAMPING</name>
	<description>V18P output fast current ramping (improves response time at the cost of more ripple)</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DCDC_V18P_VOLTAGE</name>
	<description>V18P output voltage
V = 1.2 V + 25 mV * N</description>
	<access>read-write</access>
	<bitRange>[14:10]</bitRange>
	
</field><field>
	<name>DCDC_V18P_CUR_LIM_MAX_HV</name>
	<description>V18P output maximum current limit (high battery voltage mode)
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_V18P_CUR_LIM_MIN</name>
	<description>V18P output minimum current limit
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_V18P_1_REG</name>
	<description>DCDC VPA Second Control Register</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000bc90</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18P_ENABLE_HV</name>
	<description>V18P output enable (high battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DCDC_V18P_ENABLE_LV</name>
	<description>V18P output enable (low battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>DCDC_V18P_CUR_LIM_MAX_LV</name>
	<description>V18P output maximum current limit low battery voltage mode)
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[13:10]</bitRange>
	
</field><field>
	<name>DCDC_V18P_IDLE_HYST</name>
	<description>V18P output idle time hysteresis
0 - 3875 ns, 125 ns step size
IDLE_MAX = IDLE_MIN + IDLE_HYST
Maximum idle time before decreasing CUR_LIM</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_V18P_IDLE_MIN</name>
	<description>V18P output minimum idle time
0 - 3875 ns, 125 ns step size
Minimum idle time, CUR_LIM is increased if this limit is not reached</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_V18_0_REG</name>
	<description>DCDC V18 First Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000e3e4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18_FAST_RAMPING</name>
	<description>V18 output fast current ramping (improves response time at the cost of more ripple)</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DCDC_V18_VOLTAGE</name>
	<description>V18 output voltage
V = 1.2 V + 25 mV * N</description>
	<access>read-write</access>
	<bitRange>[14:10]</bitRange>
	
</field><field>
	<name>DCDC_V18_CUR_LIM_MAX_HV</name>
	<description>V18 output maximum current limit (high battery voltage mode)
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_V18_CUR_LIM_MIN</name>
	<description>V18 output minimum current limit
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_V18_1_REG</name>
	<description>DCDC V18 Second Control Register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000bc90</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_V18_ENABLE_HV</name>
	<description>V18 output enable (high battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DCDC_V18_ENABLE_LV</name>
	<description>V18 output enable (low battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>DCDC_V18_CUR_LIM_MAX_LV</name>
	<description>V18 output maximum current limit low battery voltage mode)
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[13:10]</bitRange>
	
</field><field>
	<name>DCDC_V18_IDLE_HYST</name>
	<description>V18 output idle time hysteresis
0 - 3875 ns, 125 ns step size
IDLE_MAX = IDLE_MIN + IDLE_HYST
Maximum idle time before decreasing CUR_LIM</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_V18_IDLE_MIN</name>
	<description>V18 output minimum idle time
0 - 3875 ns, 125 ns step size
Minimum idle time, CUR_LIM is increased if this limit is not reached</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_VDD_0_REG</name>
	<description>DCDC VDD First Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000c304</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_VDD_FAST_RAMPING</name>
	<description>VDD output fast current ramping (improves response time at the cost of more ripple)</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DCDC_VDD_VOLTAGE</name>
	<description>VDD output voltage
V = 0.8 V + 25 mV * N</description>
	<access>read-write</access>
	<bitRange>[14:10]</bitRange>
	
</field><field>
	<name>DCDC_VDD_CUR_LIM_MAX_HV</name>
	<description>VDD output maximum current limit (high battery voltage mode)
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_VDD_CUR_LIM_MIN</name>
	<description>VDD output minimum current limit
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DCDC_VDD_1_REG</name>
	<description>DCDC VDD Second Control Register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000ec90</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCDC_VDD_ENABLE_HV</name>
	<description>VDD output enable (high battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>DCDC_VDD_ENABLE_LV</name>
	<description>VDD output enable (low battery voltage mode)
0 = Disabled
1 = Enabled</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>DCDC_VDD_CUR_LIM_MAX_LV</name>
	<description>VDD output maximum current limit low battery voltage mode)
I = 30 mA * (1 + N)</description>
	<access>read-write</access>
	<bitRange>[13:10]</bitRange>
	
</field><field>
	<name>DCDC_VDD_IDLE_HYST</name>
	<description>VDD output idle time hysteresis
0 - 3875 ns, 125 ns step size
IDLE_MAX = IDLE_MIN + IDLE_HYST
Maximum idle time before decreasing CUR_LIM</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>DCDC_VDD_IDLE_MIN</name>
	<description>VDD output minimum idle time
0 - 3875 ns, 125 ns step size
Minimum idle time, CUR_LIM is increased if this limit is not reached</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DEM</name>
	<version>1.0</version>
	<description>DEM registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50002e00</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>90</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>RF_AFC_CTRL_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000d5</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>APD_MODE</name>
	<description>Select the mode in the APD FSM:

xx1: Enable the transition from the ADDRESSDETECTION state to the IDLE state when the signal detection is low
x1x: Enable the reset of the AFC filter when the FSM is in the IDLE state
1xx: Enable the time out in the PREAMBLEDETECTION state. The FSM returns to the IDLE state after the time out.</description>
	<access>read-write</access>
	<bitRange>[12:10]</bitRange>
	
</field><field>
	<name>PAD_MODE</name>
	<description>The PAD mode in BLE mode

00: No limits
01: Wrapping
10: Saturate to zero
11: 580 legacy mode</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>POLE2</name>
	<description>Choose the method to use for AFC tracking during the slot
Description TBD </description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>POLE1</name>
	<description>Choose the method to use for AFC tracking during the slot
Description TBD </description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>AFC_MODE</name>
	<description>Choose the method to use for AFC tracking during the slot
Description TBD </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_AGC_CTRL1_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000950d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>AGC_MODE</name>
	<description>Choose the method to use for AGC evaluation
Description TBD </description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>AGC_TH_HIGH</name>
	<description>AGC hysteresis high threshold (switch up one AGC_SETTING_R step when exceeding this level) </description>
	<access>read-write</access>
	<bitRange>[13:7]</bitRange>
	
</field><field>
	<name>AGC_TH_LOW</name>
	<description>AGC hysteresis low threshold (switch down one AGC_SETTING_R step when dropping below this level) </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_AGC_CTRL2_REG</name>
	
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000043</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SLOW_AGC</name>
	<description>Enable the slow AGC mode (no consecutive AGC setting switches) </description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>AGCSETTING_WR</name>
	<description>Fixed AGC setting to be used to configure LNA, VGA1 and VGA2 when AGCSETTING_SEL = 1
0: Highest gain as configured in RF_AGC_LUT_01_REG
1: Lower gain as configured in RF_AGC_LUT_01_REG
2: Still lower gain as configured in RF_AGC_LUT_23_REG
...
9-F: Lowest gain as configured in RF_AGC_LUT_89_REG </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>AGCSETTING_SEL</name>
	<description>LNA, VGA1 and VGA2 gains
'0': controlled by AGC'1': provided manually through AGCSETTING_WR </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>EN_FRZ_GAIN</name>
	<description>'0': AGC always active'1': Freeze gain after Access Address detection </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>RSSI_TH</name>
	<description>RSSI threshold for the packet detection </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_AGC_LUT_01_REG</name>
	
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LNA_GAIN1</name>
	<description>LNA gain setting while in AGC setting 0 </description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>VGA1_GAIN1</name>
	<description>VGA1 gain setting while in AGC setting 1 </description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>VGA2_GAIN1</name>
	<description>VGA2 gain setting while in AGC setting 1 </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>LNA_GAIN0</name>
	<description>LNA gain setting while in AGC setting 0 </description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>VGA1_GAIN0</name>
	<description>VGA1 gain setting while in AGC setting 0 </description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>VGA2_GAIN0</name>
	<description>VGA2 gain setting while in AGC setting 0 </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_AGC_LUT_23_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004202</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LNA_GAIN3</name>
	<description>LNA gain setting while in AGC setting 3 </description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>VGA1_GAIN3</name>
	<description>VGA1 gain setting while in AGC setting 3 </description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>VGA2_GAIN3</name>
	<description>VGA2 gain setting while in AGC setting 3 </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>LNA_GAIN2</name>
	<description>LNA gain setting while in AGC setting 2 </description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>VGA1_GAIN2</name>
	<description>VGA1 gain setting while in AGC setting 2 </description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>VGA2_GAIN2</name>
	<description>VGA2 gain setting while in AGC setting 2 </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_AGC_LUT_45_REG</name>
	
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004b4a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LNA_GAIN5</name>
	<description>LNA gain setting while in AGC setting 5 </description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>VGA1_GAIN5</name>
	<description>VGA1 gain setting while in AGC setting 5 </description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>VGA2_GAIN5</name>
	<description>VGA2 gain setting while in AGC setting 5 </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>LNA_GAIN4</name>
	<description>LNA gain setting while in AGC setting 4 </description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>VGA1_GAIN4</name>
	<description>VGA1 gain setting while in AGC setting 4 </description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>VGA2_GAIN4</name>
	<description>VGA2 gain setting while in AGC setting 4 </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_AGC_LUT_67_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00005b53</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LNA_GAIN7</name>
	<description>LNA gain setting while in AGC setting 7 </description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>VGA1_GAIN7</name>
	<description>VGA1 gain setting while in AGC setting 7 </description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>VGA2_GAIN7</name>
	<description>VGA2 gain setting while in AGC setting 7 </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>LNA_GAIN6</name>
	<description>LNA gain setting while in AGC setting 6 </description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>VGA1_GAIN6</name>
	<description>VGA1 gain setting while in AGC setting 6 </description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>VGA2_GAIN6</name>
	<description>VGA2 gain setting while in AGC setting 6 </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_AGC_LUT_89_REG</name>
	
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00006b63</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LNA_GAIN9</name>
	<description>LNA gain setting while in AGC setting 9 </description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>VGA1_GAIN9</name>
	<description>VGA1 gain setting while in AGC setting 9 </description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>VGA2_GAIN9</name>
	<description>VGA2 gain setting while in AGC setting 9 </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>LNA_GAIN8</name>
	<description>LNA gain setting while in AGC setting 8 </description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>VGA1_GAIN8</name>
	<description>VGA1 gain setting while in AGC setting 8 </description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>VGA2_GAIN8</name>
	<description>VGA2 gain setting while in AGC setting 8 </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_AGC_RESULT_REG</name>
	
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>AGCSETTING_RD</name>
	<description>AGC setting as automatically selected in receive mode to configure LNA, VGA1 and VGA2
0: Highest gain as configured in RF_AGC_LUT_01_REG
1: Lower gain as configured in RF_AGC_LUT_01_REG
2: Still lower gain as configured in RF_AGC_LUT_23_REG
...
9-F: Lowest gain as configured in RF_AGC_LUT_89_REG </description>
	<access>read-only</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>AFC_RD</name>
	<description>Frequency offset estimation (in 2s complement) with a resolution of approximately 5 kHz. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CCA_RSSITH_REG</name>
	
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000708</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SIGDET_TIMEOUT_LEN</name>
	
	<access>read-write</access>
	<bitRange>[15:13]</bitRange>
	
</field><field>
	<name>CCA_RSSITH</name>
	<description>RSSI threshold used during CCA</description>
	<access>read-write</access>
	<bitRange>[12:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DC_OFFSET_CTRL1_REG</name>
	
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00008080</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCOFFSET_Q_WR</name>
	<description>DC offset compensation value in Q channel valid when DCOFFSET_SEL = 1 </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>DCOFFSET_I_WR</name>
	<description>DC offset compensation value in I channel valid when DCOFFSET_SEL = 1 </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DC_OFFSET_CTRL2_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001d2</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCVGA1SCALE_EN</name>
	<description>Enable the DC offset scaling with the VGA1 gain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>DCPARCAL_INIT</name>
	<description>Select the inital value used for the partial DC offset calibration.

0: The DC offset from the previous packet
1: The DC offset found with the full DC offset calibration</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>DCNGAIN</name>
	<description>Number of gain settings for the full DC offset calibration </description>
	<access>read-write</access>
	<bitRange>[8:7]</bitRange>
	
</field><field>
	<name>DCNSTEP</name>
	<description>Number of the steps per.gain setting for the full or partial DC offset calibrations </description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>DCPOLE</name>
	<description>Selects the pole of the digital high pass fitlers
Encoding: TBD </description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>DCPARCAL_EN</name>
	<description>Enable flag for the partial DC offset calibration (executed when the demodulator is enabled). </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DCOFFSET_SEL</name>
	<description>'0': Normal operation
'1': Use the manual DC offset compensation values from RF_DC_OFFSET_CTRL1_REG </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DC_OFFSET_CTRL3_REG</name>
	
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000dce4</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCBETA_Q</name>
	<description>Quadrature feedback gain for the DC offset calibration </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>DCBETA_I</name>
	<description>Inphase feedback gain for the DC offset calibration </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DC_OFFSET_CTRL4_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00009210</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCAGCSETTING_FULL3</name>
	<description>AGC setting for forth last the gain step for the full DC offset calibration </description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>DCAGCSETTING_FULL2</name>
	<description>AGC setting for third last the gain step for the full DC offset calibration </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>DCAGCSETTING_FULL1</name>
	<description>AGC setting for second last the gain step for the full DC offset calibration </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>DCAGCSETTING_FULL0</name>
	<description>AGC setting for last the gain step for the full DC offset calibration </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DC_OFFSET_RESULT_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DCOFFSET_Q_RD</name>
	<description>DC offset compensation value in Q channel valid when DCOFFSET_SEL = 0 </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>DCOFFSET_I_RD</name>
	<description>DC offset compensation value in I channel valid when DCOFFSET_SEL = 0. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DEM_CTRL_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000d9</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>CFE_PPOLE</name>
	<description>Select the smoothing factor (pole) for the planer filter used in the CFE (FTDF mode)

Decoding is TBD</description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>CFE_MEDIAN_EN</name>
	<description>Select the CFE value in FTDF mode

0: Current estimate
1: Median of the last three estimates</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>CFE_DOUBLE_EN</name>
	<description>Select the update rate of the CFE in FTDF mode

0: Every symbol period (16 us)
1: Every second symbol period (32 us)</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>IQCORR_EN</name>
	<description>Enable the IQ mismatch correction

The correction coefficients are define in the RF_DEM_IQCORRECT_REG register</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>BLE_DDC_EN</name>
	<description>Enable the digital conversion in BLE mode</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>EQUAL_EN</name>
	<description>Enable the equalizer in the demodulator </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>MATCH0101_TH</name>
	<description>Threshold for the 0101 pattern matching </description>
	<access>read-write</access>
	<bitRange>[5:2]</bitRange>
	
</field><field>
	<name>DEM_HSI_POL</name>
	<description>Invert "frequency" polarity of the demodulator </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RXDATA_INV</name>
	<description>'0': Normal operation
'1': Invert the polarity of the received bits </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DEM_IQCORRECT_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IQCORR_ALPHA</name>
	
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>IQCORR_BETA</name>
	
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DEM_TESTMODE_REG</name>
	
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>DEM_TESTMODE</name>
	<description>Defines the demodulator test mode

DEM_TESTMODE[3:0] selects the data mapped on the testbus (see demodulator documentation for details.

The upper and lower 16-bits test data are swapped when DEM_TESTMODE[4] is set.

The lower 16-bits are assigned to the test bus when DEM_TESTMODE[5] is set. The input test bus is copied when DEM_TESTMODE[6] is reset.

The upper 16-bits are assigned to the test bus when DEM_TESTMODE[6] is set. The input test bus is copied with DEM_TESTMODE[7] is reset.

The trigger is slected with DEM_TESTMODE[8:7]
00: dem_en
01: Signal detected
10: Set with the rising edge of DEM_EN and reset with the rising edge of SYNC_FOUND_P
11: Set with the rising edge of SYNC_FOUND_P and reset with the falling edge of DEM_EN


DEM_TESTMODE[9] is reserved</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FSSS_I_RESULT_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>FSSS_I_RD</name>
	<description>Inphase result for the FSSS</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FSSS_MAG_RESULT_REG</name>
	
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>FSSS_MAG_RD</name>
	<description>Magnitude result for the FSSS</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FSSS_Q_RESULT_REG</name>
	
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>FSSS_Q_RD</name>
	<description>Quadrature result for the FSSS</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_COBI_HIGH_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000d9c3</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COBI</name>
	
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_COBI_LOW_REG</name>
	
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000522e</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>COBI</name>
	
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_CTRL1_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000087c0</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CHSEL_FILT_MODE2</name>
	<description>Selects the channel selection filter in the coarse frequency estimation

0: Channel selection filter disabled
1: Channel selection filter #1 enabled
2: Channel selection filter #2 enabled
3: Channel selection filter #2 enabled</description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>CFE_NSTEP</name>
	<description>Number of preamble symbols used for the coarse frequency offset estimation</description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>CFE_MODE</name>
	<description>cfe_bias selects when the coarse frequency estimation is triggered

x1: When the start of FTDF signal is set
1x: When the RSSI is higher than the threshold TODO: add register and field name here</description>
	<access>read-write</access>
	<bitRange>[11:10]</bitRange>
	
</field><field>
	<name>CFE_BIAS</name>
	<description>Bias signal for the coarse frequency estimation

Fbias = cfe_bias*1.024 Hz/bit</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_CTRL2_REG</name>
	
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00006810</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PD_OFFSET</name>
	<description>Offset between first found peak and the following seach windows</description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>PD_NWIN</name>
	<description>Size of the search window during the preamble detection [-PD_NWIN;+PD_NWIN]</description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>PD_NPEAK</name>
	<description>Number of preamble detection peaks used for the preamble detection (PD_NPEAK+2)</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>PD_MODE</name>
	<description>Select when the preamble detection is triggered

0: When the start of FTDF flag is set
1: When the RSSI is larger than the threshold TODO: Add register and field names</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>NORM_EN</name>
	
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>CORRTH</name>
	<description>Correlation threshold for the preamble detection

Correlation threshold = CORRTH/4</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_CTRL3_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00005e00</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DS_OFFSET</name>
	<description>Offset between synchronization and frist despreading event</description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>CHSEL_FILT_MODE1</name>
	<description>Selects the channel selection filter in the demodulator

0: Channel selection filter disabled
1: Channel selection filter #1 enabled
2: Channel selection filter #2 enabled
3: Channel selection filter #2 enabled</description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>TIMING_CORR_EN</name>
	<description>Enable the timing tracking loop

0: Timing tracking disabled
1: Timing tracking enabled</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>MATCH_FILT_EN</name>
	<description>Enable the matched filter in the demodulator

0: Matched filter disabled
1: Matched filter enabled</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>FTDF_DDC_EN</name>
	<description>Enable the IQ correction

The correction coefficients are define in the RF_DEM_IQCORRECT_REG register</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>FIF</name>
	<description>Additional frequency triming of the IF (in addition to the fixed 2 MHz)

IF = 2.0 MHz + FIF*1.024 MHz/bit</description>
	<access>read-write</access>
	<bitRange>[8:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_CTRL4_REG</name>
	
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000c3a7</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SO_FTDF_SEL</name>
	<description>Start of FTDF (CCA) selection
0: End of the partial DC offset calibration
1: Enable signal DEM_FTDF_EN</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>CCA_MODE</name>
	<description>cca_mode select whether the CCA status for the energy detection and carrier sense are or'ed or and'ed.

0: CCA_STAT = CCA_STAT_ED &amp;&amp; CCA_STAT_CS
1: CCA_STAT = CCA_STAT_ED || CCA_STAT_CS</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>FTDF_HSI_POL</name>
	<description>The polarity of the HSI in the FTDF mode

0: IF = +2.0 MHz
1: IF = -2.0 MHz</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>LQI_SCALE</name>
	<description>Scale factor for the LQI calculation. The scaling factor equals LQI_SCALE+1</description>
	<access>read-write</access>
	<bitRange>[12:11]</bitRange>
	
</field><field>
	<name>LQI_CORRTH_EN</name>
	<description>Subtract the correlation thress TODO add register and field name from the correction values used in the LQI calculation</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>LQI_SYMBOL_EN</name>
	<description>Use two of the correction values after the preamble detection for the LQI calculation</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>LQI_PREAMBLE_EN</name>
	<description>Use two of the correlation values during the preamble detection for the LQI calculation</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>SFD1</name>
	<description>Most significant nibble of the SFD</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>SFD0</name>
	<description>Least significant nibble of the SFD</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_CTRL5_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004708</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DS_OFFSET_SEL</name>
	
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>FSSS_CLEAR</name>
	
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>FTDF_DDC_INV</name>
	
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>RSSITH</name>
	<description>RSSI threshold used for the CCA-ED</description>
	<access>read-write</access>
	<bitRange>[12:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_LOOP_GAIN_DS_REG</name>
	
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>KI_LF_DS</name>
	<description>Integral gain for the frequency offset tracking loop filter used after the preamble detection</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>KP_LF_DS</name>
	<description>Proportional gain for the frequency offset tracking loop filter used after the preamble dectection</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_LOOP_GAIN_PD_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>KI_LF_PD</name>
	<description>Integral gain for the frequency offset tracking loop filter used during the preamble detection</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>KP_LF_PD</name>
	<description>Proportional gain for the frequency offset tracking loop filter used during the preamble dectection</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_SIGDET_CTRL_REG</name>
	
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>SIGDET_DELAY</name>
	
	<access>read-write</access>
	<bitRange>[14:13]</bitRange>
	
</field><field>
	<name>SIGDET_SFACTOR1</name>
	
	<access>read-write</access>
	<bitRange>[12:11]</bitRange>
	
</field><field>
	<name>SIGDET_SFACTOR2</name>
	
	<access>read-write</access>
	<bitRange>[10:9]</bitRange>
	
</field><field>
	<name>SIGDET_DIFF</name>
	
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>SIGDET_THRESHOLD</name>
	
	<access>read-write</access>
	<bitRange>[7:2]</bitRange>
	
</field><field>
	<name>SIGDET_MODE</name>
	
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PAD_CNT_CTRL_REG</name>
	
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>PAD_CLEAR_COUNT</name>
	
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>PAD_NEG_LIMIT</name>
	
	<access>read-write</access>
	<bitRange>[13:7]</bitRange>
	
</field><field>
	<name>PAD_POS_LIMIT</name>
	
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PAD_CNT_RESULT_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PAD_NEG_CNT_RD</name>
	
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>PAD_POS_CNT_RD</name>
	
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_RSSI_COMP_CTRL_REG</name>
	
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00008777</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RSSI_COMP00</name>
	<description>RSSI compensation value for LNA gain setting 00
'0x0': -8
'0x1': -7
'0x2': -6
'0x3': -5
'0x4': -4
'0x5': -3
'0x6': -2
'0x7': -1
'0x8': 0 (reset)
'0x9': 1
'0xA': 2
'0xB': 3
'0xC': 4
'0xD': 5
'0xE': 6
'0xF': 7 </description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>RSSI_COMP11</name>
	<description>RSSI compensation value for LNA gain setting 11 relative to 00
Coding identical to RSSI_COMP01. </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>RSSI_COMP10</name>
	<description>RSSI compensation value for LNA gain setting 10 relative to 00
Coding identical to RSSI_COMP01. </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>RSSI_COMP01</name>
	<description>RSSI compensation value for LNA gain setting 01 relative to 00
'0x0': -4
'0x1': -3
'0x2': -2
'0x3': -1
'0x4': 0
'0x5': 1
'0x6': 2
'0x7': 3 (reset)
'0x8': 4
'0x9': 5
'0xA': 6
'0xB': 7
'0xC': 8
'0xD': 9
'0xE': 10
'0xF': 11 </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_RSSI_RESULT_REG</name>
	
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RSSI_AVG_RD</name>
	<description>RSSI value measured in averaging mode in continuous RX mode (used for LNA selectivity calibration) </description>
	<access>read-only</access>
	<bitRange>[15:6]</bitRange>
	
</field><field>
	<name>RSSI_PH_RD</name>
	<description>RSSI value measured in peak-hold mode during the preamble and Access Addres detection </description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DMA</name>
	<version>1.0</version>
	<description>DMA registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003500</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>134</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>DMA0_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 0</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA0_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA0_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA0_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA0_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 0</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA0_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA0_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA0_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA0_CTRL_REG</name>
	<description>Control register for the DMA channel 0</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA0_IDX_REG</name>
	<description>Index value of DMA channel 0</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA0_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA0_INT_REG</name>
	<description>DMA receive interrupt register channel 0</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA0_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA0_LEN_REG</name>
	<description>DMA receive length register channel 0</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA0_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA1_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 1</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA1_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA1_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 1</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA1_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA1_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 1</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA1_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA1_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 1</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA1_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA1_CTRL_REG</name>
	<description>Control register for the DMA channel 1</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA1_IDX_REG</name>
	<description>Index value of DMA channel 1</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA1_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA1_INT_REG</name>
	<description>DMA receive interrupt register channel 1</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA1_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA1_LEN_REG</name>
	<description>DMA receive length register channel 1</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA1_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA2_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 2</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA2_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA2_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 2</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA2_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA2_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 2</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA2_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA2_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA2_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA2_CTRL_REG</name>
	<description>Control register for the DMA channel 2</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>AINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address
0 = do not increment
1 = increment according value of BW</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA2_IDX_REG</name>
	<description>Index value of DMA channel 2</description>
	<addressOffset>0x0000002e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA2_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA2_INT_REG</name>
	<description>DMA receive interrupt register channel 2</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA2_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA2_LEN_REG</name>
	<description>DMA receive length register channel 2</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA2_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA3_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 3</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA3_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA3_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 3</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA3_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA3_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 3</description>
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA3_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA3_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 3</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA3_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA3_CTRL_REG</name>
	<description>Control register for the DMA channel 3</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA3_IDX_REG</name>
	<description>Index value of DMA channel 3</description>
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA3_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA3_INT_REG</name>
	<description>DMA receive interrupt register channel 3</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA3_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA3_LEN_REG</name>
	<description>DMA receive length register channel 3</description>
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA3_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA4_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 4</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA4_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA4_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 4</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA4_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA4_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 4</description>
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA4_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA4_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 4</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA4_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA4_CTRL_REG</name>
	<description>Control register for the DMA channel 4</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA4_IDX_REG</name>
	<description>Index value of DMA channel 4</description>
	<addressOffset>0x0000004e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA4_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA4_INT_REG</name>
	<description>DMA receive interrupt register channel 4</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA4_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA4_LEN_REG</name>
	<description>DMA receive length register channel 4</description>
	<addressOffset>0x0000004a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA4_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA5_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 5</description>
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA5_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA5_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 5</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA5_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA5_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 5</description>
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA5_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA5_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 5</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA5_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA5_CTRL_REG</name>
	<description>Control register for the DMA channel 5</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA5_IDX_REG</name>
	<description>Index value of DMA channel 5</description>
	<addressOffset>0x0000005e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA5_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA5_INT_REG</name>
	<description>DMA receive interrupt register channel 5</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA5_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA5_LEN_REG</name>
	<description>DMA receive length register channel 5</description>
	<addressOffset>0x0000005a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA5_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA6_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 6</description>
	<addressOffset>0x00000062</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA6_A_STARTH</name>
	<description>Source start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA6_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 6</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA6_A_STARTL</name>
	<description>Source start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA6_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 6</description>
	<addressOffset>0x00000066</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA6_B_STARTH</name>
	<description>Destination start address, upper 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA6_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 6</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA6_B_STARTL</name>
	<description>Destination start address, lower 16 bits </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA6_CTRL_REG</name>
	<description>Control register for the DMA channel 6</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA6_IDX_REG</name>
	<description>Index value of DMA channel 6</description>
	<addressOffset>0x0000006e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA6_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA6_INT_REG</name>
	<description>DMA receive interrupt register channel 6</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA6_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA6_LEN_REG</name>
	<description>DMA receive length register channel 6</description>
	<addressOffset>0x0000006a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA6_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA7_A_STARTH_REG</name>
	<description>Start address High A of DMA channel 7</description>
	<addressOffset>0x00000072</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA7_A_STARTH</name>
	<description>Source start address, upper 16 bits
NOTE: See also the DMA chapter of the Datasheet for the allowed range of the DMA7 source address in Secure Boot mode.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA7_A_STARTL_REG</name>
	<description>Start address Low A of DMA channel 7</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA7_A_STARTL</name>
	<description>Source start address, lower 16 bits
NOTE: See also the DMA chapter of the Datasheet for the allowed range of the DMA7 source address in Secure Boot mode.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA7_B_STARTH_REG</name>
	<description>Start address High B of DMA channel 7</description>
	<addressOffset>0x00000076</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA7_B_STARTH</name>
	<description>Destination start address, upper 16 bits
NOTE: In Secure Boot mode, this register is overruled to the higher 16 bits of address CRYPTO_KEYS_START_ADDR.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA7_B_STARTL_REG</name>
	<description>Start address Low B of DMA channel 7</description>
	<addressOffset>0x00000074</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA7_B_STARTL</name>
	<description>Destination start address, lower 16 bits
NOTE: In Secure Boot mode, this register is overruled to the lower 16 bits of address CRYPTO_KEYS_START_ADDR.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA7_CTRL_REG</name>
	<description>Control register for the DMA channel 7</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>REQ_SENSE</name>
	<description>0 = DMA operates with level-sensitive peripheral requests (default)
1 = DMA operates with (positive) edge-sensitive peripheral requests</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>DMA_INIT</name>
	<description>0 = DMA performs copy A1 to B1, A2 to B2, etc ...
1 = DMA performs copy of A1 to B1, B2, etc ...
This feature is useful for memory initialization to any value. Thus, BINC must be set to '1', while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE='1'.
NOTE: This bit-field is overruled to '0' when the DMA7 channel is configured as "trusted" channel (in Secure Boot mode).</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>DMA_IDLE</name>
	<description>0 = Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1 = Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read. If DREQ_MODE='1', DMA_IDLE is don't care.
*NOTE: This bit-field is overruled to '0' when the DMA7 channel is configured as "trusted" channel (in Secure Boot mode).</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>CIRCULAR</name>
	<description>0 = Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1 = Circular mode (applicable only if DREQ_MODE = '1'). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0 = do not increment (source address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0 = do not increment (destination address stays the same during the transfer)
1 = increment according to the value of BW bit-field (by 1, when BW="00" ; by 2, when BW="01" ; by 4, when BW="10")</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DREQ_MODE</name>
	<description>0 = DMA channel starts immediately
1 = DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)
*NOTE: This bit-field is overruled to '0' when channel DMA7 is configured as "trusted" channel (in Secure Boot mode).</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IRQ_ENABLE</name>
	<description>0 = disable interrupt on this channel
1 = enable interrupt on this channel</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00 = 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01 = 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10 = 4 Bytes (suggested for Memory-to-Memory transfers)
11 = Reserved
NOTE: This bit-field is overruled to "10" when channel DMA7 is configured as "trusted" channel (in Secure Boot mode).</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DMA_ON</name>
	<description>0 = DMA channel is off, clocks are disabled
1 = DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if circular mode is not enabled. In circular mode, this bit stays set.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA7_IDX_REG</name>
	<description>Index value of DMA channel 7</description>
	<addressOffset>0x0000007e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA7_IDX</name>
	<description>This (read-only) register determines the data items currently fetched by the DMA channel, during an on-going transfer. When the transfer is completed, the register is automatically reset to 0.
The DMA channel uses this register to form the source/destination address of the next DMA cycle, considering also AINC/BINC and BW.</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA7_INT_REG</name>
	<description>DMA receive interrupt register channel 7</description>
	<addressOffset>0x00000078</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA7_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if DMAx_INT_REG is equal to DMAx_IDX_REG and before DMAx_IDX_REG is incremented. The bit-field IRQ_ENABLE of DMAx_CTRL_REG must be set to '1' to let the controller generate the interrupt.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA7_LEN_REG</name>
	<description>DMA receive length register channel 7</description>
	<addressOffset>0x0000007a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA7_LEN</name>
	<description>DMA channel's transfer length. DMAx_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA_CLEAR_INT_REG</name>
	<description>DMA clear interrupt register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA_RST_IRQ_CH7</name>
	<description>Writing a 1 will reset the IRQ of channel 7 ; writing a 0 will have no effect.</description>
	<access>write-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>DMA_RST_IRQ_CH6</name>
	<description>Writing a 1 will reset the IRQ of channel 6 ; writing a 0 will have no effect.</description>
	<access>write-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DMA_RST_IRQ_CH5</name>
	<description>Writing a 1 will reset the IRQ of channel 5 ; writing a 0 will have no effect.</description>
	<access>write-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DMA_RST_IRQ_CH4</name>
	<description>Writing a 1 will reset the IRQ of channel 4 ; writing a 0 will have no effect.</description>
	<access>write-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>DMA_RST_IRQ_CH3</name>
	<description>Writing a 1 will reset the IRQ of channel 3 ; writing a 0 will have no effect.</description>
	<access>write-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DMA_RST_IRQ_CH2</name>
	<description>Writing a 1 will reset the IRQ of channel 2 ; writing a 0 will have no effect.</description>
	<access>write-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DMA_RST_IRQ_CH1</name>
	<description>Writing a 1 will reset the IRQ of channel 1 ; writing a 0 will have no effect.</description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DMA_RST_IRQ_CH0</name>
	<description>Writing a 1 will reset the IRQ of channel 0 ; writing a 0 will have no effect.</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA_INT_STATUS_REG</name>
	<description>DMA interrupt status register</description>
	<addressOffset>0x00000082</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA_IRQ_CH7</name>
	<description>0: IRQ on channel 7 is not set
1: IRQ on channel 7 is set</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>DMA_IRQ_CH6</name>
	<description>0: IRQ on channel 6 is not set
1: IRQ on channel 6 is set</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DMA_IRQ_CH5</name>
	<description>0: IRQ on channel 5 is not set
1: IRQ on channel 5 is set</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DMA_IRQ_CH4</name>
	<description>0: IRQ on channel 4 is not set
1: IRQ on channel 4 is set</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>DMA_IRQ_CH3</name>
	<description>0: IRQ on channel 3 is not set
1: IRQ on channel 3 is set</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DMA_IRQ_CH2</name>
	<description>0: IRQ on channel 2 is not set
1: IRQ on channel 2 is set</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DMA_IRQ_CH1</name>
	<description>0: IRQ on channel 1 is not set
1: IRQ on channel 1 is set</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DMA_IRQ_CH0</name>
	<description>0: IRQ on channel 0 is not set
1: IRQ on channel 0 is set</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DMA_REQ_MUX_REG</name>
	<description>DMA channel assignments</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DMA67_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Here, the first DMA request is mapped on channel 6 and the second on channel 7.
See DMA01_SEL for the peripheral mapping.</description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>DMA45_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Here, the first DMA request is mapped on channel 4 and the second on channel 5.
See DMA01_SEL for the peripherals' mapping.</description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>DMA23_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Here, the first DMA request is mapped on channel 2 and the second on channel 3.
See DMA01_SEL for the peripherals' mapping.</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>DMA01_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
Here, the first DMA request is mapped on channel 0 and the second on channel 1.
0x0: SPI_rx / SPI_tx
0x1: SPI2_rx / SPI2_tx
0x2: UART_rx / UART_tx
0x3: UART2_rx / UART2_tx
0x4: I2C_rx / I2C_tx
0x5: I2C2_rx / I2C2_tx
0x6: USB_rx / USB_tx
0x7: Reserved
0x8: PCM_rx / PCM_tx
0x9: SRC_rx / SRC_tx (for all the supported conversions)
0xA: FTDF_rx / FTDF_tx
0xB: Reserved
0xC: ADC / -
0xD: Reserved
0xE: Reserved
0xF: None

Note: If any of the four available peripheral selector fields (DMA01_SEL, DMA23_SEL, DMA45_SEL, DMA67_SEL) have the same value, the lesser significant selector has higher priority and will control the dma acknowledge. Hence, if DMA01_SEL = DMA23_SEL, the channels 0 and 1 will generate the DMA acknowledge signals for the selected peripheral. Consequently, it is suggested to assign the intended peripheral value to a unique selector field.</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>ECC</name>
	<version>1.0</version>
	<description>ECC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50006000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>20</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>ECC_COMMAND_REG</name>
	<description>Command register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>ECC_CalcR2</name>
	<description>This bit indicates if the IP has to calculate R mod N for the next operation. This bit must be set to 1 when a new prime number has been programmed. This bit is automatically cleared when R mod N has been calculated.
'0': no effect
'1': forces the IP to re-calculate R mod N</description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>ECC_SignB</name>
	<description>Sign of parameter B in equation y2=x3+Ax+B
'0': B is positive
'1': B is negative</description>
	<access>read-write</access>
	<bitRange>[30:30]</bitRange>
	
</field><field>
	<name>ECC_SignA</name>
	<description>Sign of parameter A in equation y2=x3+Ax+B
'0': A is positive
'1': A is negative</description>
	<access>read-write</access>
	<bitRange>[29:29]</bitRange>
	
</field><field>
	<name>ECC_SizeOfOperands</name>
	<description>This field defines the size (= number of 64-bit double words) of the operands for the current operation. Possible values are limited by the generic parameter g_Log2MaxDataSize that defines the max space allocated or reserved to each operand.

Arbitrary Data/Key size from 128 up to 2566 are supported:
0x02 (02d) -&gt; 128-bit Data/Key size
0x03 (02d) -&gt; 256-bit Data/Key size
ECC-ECDSA - Prime Field F(p)
0x03 -&gt; 192-bit (Curve P-192)
0x04 -&gt; 256-bit (Curves P-224 &amp; P-256)
ECC-ECDSA - Binary Field F(2m)
0x03 -&gt; 192-bit (Curve K-163)
0x04 -&gt; 256-bit (Curve K-233)
- 4 Xers: 0x01, 0x02, 0x4, 0x6 -&gt; 64, 128 &amp; multiples of 128 bits</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ECC_Field</name>
	<description>'0': Field is F(p)
'1': Field is F(2m)</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>ECC_TypeOperation</name>
	<description>Primitive Arithmetic Operations F(p) &amp; F(2m)
[6:4] = 0x0
[3:0] =
0x0 -&gt; Reserved
0x1 -&gt; Modular Addition
0x2 -&gt; Modular Subtraction
0x3 -&gt; Modular Multiplication (Odd N)
0x4 -&gt; Modular Reduction (Odd N)
0x5 -&gt; Modular Division (Odd N)
0x6 -&gt; Modular Inversion (Odd N)
0x7 -&gt; Reserved
0x8 -&gt; Multiplication
0x9 -&gt; Modular Inversion (Even N)
0xA -&gt; Modular Reduction (Even N)
others -&gt; Reserved
C = A + B mod N
C = A - B mod N
C = A * B mod N
C = B mod N
C = A/B mod N
C = 1/B mod N
C = A * B
C = 1/B mod N
C = B mod N
High-level RSA, CRT &amp; DSA Operations - F(p) only
([7] forced to 0)
[6:4] = 0x1
[3:0] =
0x0 -&gt; MulModN
0x1 -&gt; MulAddN
0x2 -&gt; ECMQV (part1)
others -&gt; Reserved

Primitive ECC &amp; Check Point Operations F(p) &amp; F(2m)
[6:4] = 0x2
[3:0] =
0x0 -&gt; Point Doubling (Projective Coord.)
0x1 -&gt; ptAdd3
0x2 -&gt; GenSessionKey
0x3 -&gt; Check_AB (ECDSA)
0x4 -&gt; Check_n (ECDSA)
0x5 -&gt; Check single value less than N
0x6 -&gt; Check_Point_On_Curve
0x7-&gt; Reserved
0x8 -&gt; Curve25519 point multiplication
0x9 -&gt; Ed25519 Check point on curve
0xA -&gt; Ed25519 ScalarMult
0xB -&gt; Ed25519 CheckValid
others -&gt; Reserved

High-level ECC ECDSA Operations F(p) &amp; F(2m)
[6:4] = 0x3
[3:0] =
0x0 -&gt; ECMQV (part 2)
0x1 -&gt; Verify ZKP
0x2 -&gt; ECDSA Domain Parameters Validation
others -&gt; Reserved


[6:4]=0x4, 0x5, 0x6, 0x7 -&gt; Reserved</description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>ECC_CONFIG_REG</name>
	<description>Configuration register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x001fffff</resetMask>
	<fields>
	<field>
	<name>ECC_OpPtrC</name>
	<description>When executing primitive arithmetic operations, this pointer defines the location where the result will be stored in Memory.</description>
	<access>read-write</access>
	<bitRange>[20:16]</bitRange>
	
</field><field>
	<name>ECC_OpPtrB</name>
	<description>When executing primitive arithmetic operations, this Pointer defines where operand B is located in memory.</description>
	<access>read-write</access>
	<bitRange>[12:8]</bitRange>
	
</field><field>
	<name>ECC_OpPtrA</name>
	<description>When executing primitive arithmetic operations, this Pointer defines where operand A is located in memory.</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>ECC_CONTROL_REG</name>
	<description>Control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>ECC_Start</name>
	<description>The Start signal is activated when all data and key inputs have been loaded in the external crypto memory and are available for processing. This signal is active high and is sampled on the rising edge of Clk.
When this signal goes high, the PK Command present in the PK_CommandReg[] is initiated and executed. The PK_Start signal is ignored when the core is already processing data and is automatically cleared when the operation is finished</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>ECC_STATUS_REG</name>
	<description>Status register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields>
	<field>
	<name>ECC_Busy</name>
	<description>This Status Signal indicates that the core is processing data. This signal is active high and goes low when the selected algorithm is finished.</description>
	<access>read-only</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>ECC_PrimalityTestResult</name>
	<description>After the Miller-Rabin Primality test, this flag is:
- set to 0 when the random number under test is probably prime
- cleared to 1 when the random number under test is composite</description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>ECC_NotInvertible</name>
	<description>This flag is set to 1 when executing a modular inversion (PK_CommandReg[3:0] = 0x6 or 0x9) if the operand is not invertible.</description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>ECC_Param_AB_NotValid</name>
	<description>Status signal set to 1 when parameters A and B are not valid, i.e 4A+ 27B = 0. This flag is updated after execution of the command Check_AB.</description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>ECC_Signature_NotValid</name>
	<description>This flag indicates if the signature can be accepted or must be rejected.
This flag is set to 1 when the signature is not valid and is updated after execution of the command ECDSA_Generation, ECDSA_Verification, DSA_Generation, DSA_Verification.</description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>ECC_Param_n_NotValid</name>
	<description>Status signal set to 1 when Parameter n is not valid.
This flag is updated after execution of the command Check_n.</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>ECC_Couple_NotValid</name>
	<description>Status signal set to 1 when couple x, y is not valid (i.e. not smaller than the prime).
This flag is updated after execution of the command Check_Couple_Less_Prime.</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ECC_Point_Px_AtInfinity</name>
	<description>Status signal set to 1 when Point Px is at the infinity.
This flag is updated after execution of an ECC operation.</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>ECC_Point_Px_NotOnCurve</name>
	<description>Status signal set to 1 when Point Px is not on the defined EC. This flag is updated after execution of the command Check_Point_OnCurve.</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>ECC_Fail_Address</name>
	<description>Address of the last Point detected as Not On Curve, Not Valid or at the infinity.</description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>ECC_VERSION_REG</name>
	<description>Version register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000400</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ECC_HVN</name>
	<description>Version of IP to be read via CPU interface.</description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ECC_SVN</name>
	<description>Version of Crypto code to be read via CPU interface.Note that this should be read before ECC is used since it corrupts its contents.</description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>FTDF</name>
	<version>1.0</version>
	<description>FTDF registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40080000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>73740</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>FTDF_BUILDTIME_0_REG</name>
	<description>Build time</description>
	<addressOffset>0x00010010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>BUILDTIME</name>
	<description>A 4 words wide register, showing in ASCII the build date (dd mmm yy) and time (hh:mm) of device, eg. 01 Dec 14 14:10. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_BUILDTIME_1_REG</name>
	<description>Build time</description>
	<addressOffset>0x00010014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>BUILDTIME</name>
	<description>A 4 words wide register, showing in ASCII the build date (dd mmm yy) and time (hh:mm) of device, eg. 01 Dec 14 14:10. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_BUILDTIME_2_REG</name>
	<description>Build time</description>
	<addressOffset>0x00010018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>BUILDTIME</name>
	<description>A 4 words wide register, showing in ASCII the build date (dd mmm yy) and time (hh:mm) of device, eg. 01 Dec 14 14:10. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_BUILDTIME_3_REG</name>
	<description>Build time</description>
	<addressOffset>0x0001001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>BUILDTIME</name>
	<description>A 4 words wide register, showing in ASCII the build date (dd mmm yy) and time (hh:mm) of device, eg. 01 Dec 14 14:10. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_DEBUGCONTROL_REG</name>
	<description>Debug control register</description>
	<addressOffset>0x00010390</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000100</resetMask>
	<fields>
	<field>
	<name>DBG_RX_INPUT</name>
	<description>If set to '1', the Rx debug interface will be selected as input for the Rx pipeline rather than the DPHY interface signals.
Note that in this mode, DBG_RX_DATA[3:0] and DBG_RX_SOF are sourced by another source (outside the scope of the LMAC) while the other Rx inputs (CCA_STAT, LQI[7:0] and ED_STAT[7:0]) are forced to 0x00. </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_EVENTCURRVAL_REG</name>
	<description>Value of event generator</description>
	<addressOffset>0x00010058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields>
	<field>
	<name>EVENTCURRVAL</name>
	<description>The value of the captured Event generator (Wake-up counter) (initiated by getGeneratorVal, valid when getGeneratorVal_e is set). </description>
	<access>read-only</access>
	<bitRange>[24:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_FTDF_CE_REG</name>
	<description>Selection register events</description>
	<addressOffset>0x00010250</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>FTDF_CE</name>
	<description>Composite service request from ftdf macro (see FR0400 in v40.100.2.41.pdf), set to '1' if the branch currently contributes to the interrupt.
Bit 0 = unused
Bit 1 = rx interrupts
Bit 2 = unused
Bit 3 = miscelaneous interrupts
Bit 4 = tx interrupts
Bit 5 = Reserved
Upon an interrupt, using the ftdf_ce bits it can be checked which interrupt branch creates this interrupt. </description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_FTDF_CM_REG</name>
	<description>Mask selection register events</description>
	<addressOffset>0x00010254</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>FTDF_CM</name>
	<description>mask bits for ftf_ce.
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_GLOB_CONTROL_0_REG</name>
	<description>Global control register</description>
	<addressOffset>0x00010020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000ff00</resetValue>
	<resetMask>0x0006ff0e</resetMask>
	<fields>
	<field>
	<name>MACTSCHENABLED</name>
	<description>If set to '1', the TSCH mode is enabled </description>
	<access>read-write</access>
	<bitRange>[18:18]</bitRange>
	
</field><field>
	<name>MACLEENABLED</name>
	<description>If set to '1', the Low Energy mode (also called CSL) is enabled </description>
	<access>read-write</access>
	<bitRange>[17:17]</bitRange>
	
</field><field>
	<name>MACSIMPLEADDRESS</name>
	<description>Simple address of the PAN coordinator </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>TX_DMA_REQ</name>
	<description>Source of the TX_DMA_REQ output pin of this block. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RX_DMA_REQ</name>
	<description>Source of the RX_DMA_REQ output pin of this block. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>ISPANCOORDINATOR</name>
	<description>Enable/disable receiver check on address fields (0=enabled, 1=disabled) </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_GLOB_CONTROL_1_REG</name>
	<description>Global control register</description>
	<addressOffset>0x00010024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACSHORTADDRESS</name>
	<description>The short address of the device. The values 0xFFFF and 0xFFFE indicate that no IEEE Short Address is available. </description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>MACPANID</name>
	<description>The PAN ID of this device.
The value 0xFFFF indicates that the device is not associated to a PAN. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_GLOB_CONTROL_2_REG</name>
	<description>Global control register</description>
	<addressOffset>0x00010028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>AEXTENDEDADDRESS_L</name>
	<description>Unique device address, 48 bits wide, lowest 32 bit </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_GLOB_CONTROL_3_REG</name>
	<description>Global control register</description>
	<addressOffset>0x0001002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>AEXTENDEDADDRESS_H</name>
	<description>Unique device address, 48 bits wide, highest 16 bit </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMACRESET_REG</name>
	<description>Lmax reset register</description>
	<addressOffset>0x00010360</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000106df</resetMask>
	<fields>
	<field>
	<name>LMACGLOBRESET_COUNT</name>
	<description>If set, the LMAC performance and traffic counters will be reset.
Use this register for functionally reset these counters. </description>
	<access>write-only</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>LMACRESET_TIMCTRL</name>
	<description>LmacReset_count: A '1' resets LMAC timing control block (for debug and MLME-reset) </description>
	<access>write-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>LMACRESET_COUNT</name>
	<description>LmacReset_count: A '1' resets LMAC mac counters (for debug and MLME-reset) </description>
	<access>write-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>LMACRESET_SEC</name>
	<description>LmacReset_sec: A '1' resets LMAC security (for debug and MLME-reset)

#$LmacReset_wutim@on_off_regmap
#LmacReset_wutim: A '1' Resets LMAC wake-up timer (for debug and MLME-reset) </description>
	<access>write-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>LMACRESET_TSTIM</name>
	<description>LmacReset_tstim: A '1' resets LMAC timestamp timer (for debug and MLME-reset) </description>
	<access>write-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>LMACRESET_OREG</name>
	<description>LmacReset_oreg: A '1' resets LMAC on_off regmap (for debug and MLME-reset)

#$LmacReset_areg@on_off_regmap
#LmacReset_areg: A '1' Resets LMAC always_on regmap (for debug and MLME-reset) </description>
	<access>write-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>LMACRESET_AHB</name>
	<description>LmacReset_ahb: A '1' resets LMAC ahb interface (for debug and MLME-reset) </description>
	<access>write-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>LMACRESET_TX</name>
	<description>LmacReset_tx: A '1' resets LMAC tx pipeline (for debug and MLME-reset) </description>
	<access>write-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>LMACRESET_RX</name>
	<description>LmacReset_rx: A '1' resets LMAC rx pipeline (for debug and MLME-reset) </description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>LMACRESET_CONTROL</name>
	<description>LmacReset_control: A '1' resets LMAC Controller (for debug and MLME-reset) </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_0_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>KEEP_PHY_EN</name>
	<description>When the transmit or receive action is ready (LmacReady4Sleep is set), the PHY_EN signal is cleared unless the control register keep_phy_en is set to '1'.
When the control register keep_phy_en is set to '1', the signal PHY_EN shall remain being set until the keep_phy_en is cleared.
This will help control the behavior of the arbiter between the LMAC and the DPHY. </description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>PTI_RX</name>
	<description>This value will be used during receiving frames, during the auto ACK (when the AR bit is set in the received frame, see [FR0655] and further), a single CCA and ED scan.
In TSCH mode this register will be used during the time slot in which frames can be received and consequently an Enhanced ACK can be transmitted. </description>
	<access>read-write</access>
	<bitRange>[30:27]</bitRange>
	
</field><field>
	<name>RXALWAYSON</name>
	<description>If set to '1', the receiver shall be always on if RxEnable is set to '1'. </description>
	<access>read-write</access>
	<bitRange>[25:25]</bitRange>
	
</field><field>
	<name>RXONDURATION</name>
	<description>The time (in symbol periods) the Rx must be on after setting RxEnable to '1'. </description>
	<access>read-write</access>
	<bitRange>[24:1]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_10_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x0001010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x20000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACRZZEROVAL</name>
	<description>In CSL mode, if the current RZtime is less or Equal to macRZzeroVal an RZtime with value zero is inserted in the wakeup frame. So this is by default the last Wake-up frame of a Wake-up sequence. </description>
	<access>read-write</access>
	<bitRange>[31:28]</bitRange>
	
</field><field>
	<name>MACCSLMARGINRZ</name>
	<description>In CSL mode, the software can set the margin for the expected frame by control register macCSLmarginRZ (in 10 symbol periods).
The LMAC will make sure that the receiver is ready to receive data this amount of time earlier than to be expected by the received RZ time. </description>
	<access>read-write</access>
	<bitRange>[19:16]</bitRange>
	
</field><field>
	<name>MACWURZCORRECTION</name>
	<description>In CSL mode, this register shall be used if the Wake-up frame to be transmitted is larger than 15 octets.
It shall indicate the amount of extra data in a Wake-up frame after the RZ position in the frame (in 10 symbol periods).
This correction is needed to make sure that the correct RZ time is filled in by the LMAC. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_11_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x0001006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7fffffff</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CSMA_CA_BO_THRESHOLD</name>
	<description>If the backoff time calculated in the CSMA-CA procedure as described in [FR3280] is equal to or higher than the control register Csma_Ca_BO_threshold[8] (resolution 320us, see [FR3290]) the event register Csma_Ca_BO_thr_e will be set and an interrupt.
In case Csma_Ca_BO_threshold equals 0xFF no check will be performed and consequently Csma_Ca_BO_thr_e will not be set and no interrupt will be generated. </description>
	<access>read-write</access>
	<bitRange>[31:24]</bitRange>
	
</field><field>
	<name>CSMA_CA_NB_VAL</name>
	<description>Number of backoffs value in case of a CSMA-CA resume action. </description>
	<access>read-write</access>
	<bitRange>[19:17]</bitRange>
	
</field><field>
	<name>MACDISCARXOFFTORZ</name>
	<description>The switching off and on of the PHY Rx (see macRxTotalCycleTime) can be disabled whith the control register macDisCaRxOfftoRZ.
0 : Disabled
1 : Enabled </description>
	<access>read-write</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>MACRXTOTALCYCLETIME</name>
	<description>In CSL mode it can be decided to disable the PHY Rx (Rx-off) after reception of a Wake-up frame and enable the PHY Rx (Rx-on) when the data frame is to be expected, based on the received RZ time.
In order to make it easier to calculate if it is efficient to switch to Rx-off and Rx-on again, a control register indicates the time needed to disable and enable the PHY Rx: macRxTotalCycleTime (resolution is 10 symbol periods) </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_1_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PHYRXATTR_HSI</name>
	<description>HighSide injection. </description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>PHYRXATTR_RF_GPIO_PINS</name>
	<description>Slot-basis signals mapped on GPIO via PPA. </description>
	<access>read-write</access>
	<bitRange>[14:12]</bitRange>
	
</field><field>
	<name>PHYRXATTR_CALCAP</name>
	<description>CalCap value. </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>PHYRXATTR_CN</name>
	<description>Channel Number. </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>PHYRXATTR_DEM_PTI</name>
	<description>DEM packet information. </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_2_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>EDSCANDURATION</name>
	<description>The length of ED scan in symbol periods. </description>
	<access>read-write</access>
	<bitRange>[31:8]</bitRange>
	
</field><field>
	<name>EDSCANENABLE</name>
	<description>If set to '1', the Energy Detect scan will be performed when RxEnable is set to '1' rather than starting a receive action.
The length of this scan is defined by EdScanDuration. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_3_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x070004c4</resetValue>
	<resetMask>0x0fffffff</resetMask>
	<fields>
	<field>
	<name>FTDF_LPDP_ENABLE</name>
	<description>If set, not only is FP_override and SA matching done on data_request frames but to all command and data frame types (in normal mode) </description>
	<access>read-write</access>
	<bitRange>[27:27]</bitRange>
	
</field><field>
	<name>FP_FORCE_VALUE</name>
	<description>In case the control register FP_override is set, the value of the control register FP_force_value will always be the value of the FP bit in the automatic ACK response frame. </description>
	<access>read-write</access>
	<bitRange>[26:26]</bitRange>
	
</field><field>
	<name>FP_OVERRIDE</name>
	<description>In case the control register FP_override is set, the value of the control register FP_force_value will always be the value of the FP bit in the automatic ACK response frame. </description>
	<access>read-write</access>
	<bitRange>[25:25]</bitRange>
	
</field><field>
	<name>ADDR_TAB_MATCH_FP_VALUE</name>
	<description>In case the received source address matches with one of the Exp_SA registers, the value of the control register Addr_tap_match_FP_value will be inserted on the position of the FP bit.
In case there is no match found, the inverse value of Addr_tap_match_FP_value will be inserted. </description>
	<access>read-write</access>
	<bitRange>[24:24]</bitRange>
	
</field><field>
	<name>CCAIDLEWAIT</name>
	<description>Time to wait (in us) after CCA returned medium idle before starting TX-ON.
Notes:
1) extra wait times are involved before a packet is really transmitted, see the relevant timing figures.
2) not applicable in TSCH mode since there macTSRxTx shall be used. </description>
	<access>read-write</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>MACMAXFRAMETOTALWAITTIME</name>
	<description>Max time to wait (in symbol periods) for a requested Data Frame or an announced broadcast frame, triggered by the FP bit in the received frame was set to '1'. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_4_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PHYACKATTR_HSI</name>
	<description>HighSide injection. </description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>PHYACKATTR_RF_GPIO_PINS</name>
	<description>Slot-basis signals mapped on GPIO via PPA. </description>
	<access>read-write</access>
	<bitRange>[30:28]</bitRange>
	
</field><field>
	<name>PHYACKATTR_CALCAP</name>
	<description>CalCap value. </description>
	<access>read-write</access>
	<bitRange>[27:24]</bitRange>
	
</field><field>
	<name>PHYACKATTR_CN</name>
	<description>Channel Number. </description>
	<access>read-write</access>
	<bitRange>[23:20]</bitRange>
	
</field><field>
	<name>PHYACKATTR_DEM_PTI</name>
	<description>DEM packet information. </description>
	<access>read-write</access>
	<bitRange>[19:16]</bitRange>
	
</field><field>
	<name>RXPIPEPROPDELAY</name>
	<description>The control register RxPipePropDelay indicates the propagation delay in ~s of the Rx pipeline between the last symbol being captured at the DPHY interface and the data valid indication to the LMAC controller. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>PHYSLEEPWAIT</name>
	<description>The minume time (in us) required between the clear to '0' and set to '1' of PHY_EN.
When the signal PHY_EN is deasserted, it will not be asserted within the time phySleepWait. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_5_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000008c0</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PHYCSMACAATTR_HSI</name>
	<description>HighSide injection. </description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>PHYCSMACAATTR_RF_GPIO_PINS</name>
	<description>Slot-basis signals mapped on GPIO via PPA. </description>
	<access>read-write</access>
	<bitRange>[30:28]</bitRange>
	
</field><field>
	<name>PHYCSMACAATTR_CALCAP</name>
	<description>CalCap value. </description>
	<access>read-write</access>
	<bitRange>[27:24]</bitRange>
	
</field><field>
	<name>PHYCSMACAATTR_CN</name>
	<description>Channel Number. </description>
	<access>read-write</access>
	<bitRange>[23:20]</bitRange>
	
</field><field>
	<name>PHYCSMACAATTR_DEM_PTI</name>
	<description>DEM packet information. </description>
	<access>read-write</access>
	<bitRange>[19:16]</bitRange>
	
</field><field>
	<name>CCASTATWAIT</name>
	<description>The output CCASTAT is valid after 8 symbols + phyRxStartup.
The 8 symbols are programmable by control registerCcaStatWait (in symbol periods).
Default value is 8d. </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>ACK_RESPONSE_DELAY</name>
	<description>In order to have some flexibility the control register Ack_Response_Delay indicates the Acknowledge response time in ~s.
The default value shall is 192 ~s (12 symbols). </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_6_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000c0c28</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields>
	<field>
	<name>WUIFSPERIOD</name>
	<description>The WakeUp IFS period is programmable by WUifsPeriod (in symbols).
The default is 12 symbols (192 us). </description>
	<access>read-write</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>SIFSPERIOD</name>
	<description>The Short IFS period is programmable by SifsPeriod (in symbols).
The default is 12 symbols (192 is). </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>LIFSPERIOD</name>
	<description>The Long IFS period is programmable by LifsPeriod (in symbols).
The default is 40 symbols (640 us), </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_7_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00420000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACCSLSAMPLEPERIOD</name>
	<description>In CSL mode, when performing a idle listening, the receiver is enabled for at least macCSLsamplePeriod (in symbol oeriods). </description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>MACWUPERIOD</name>
	<description>In CSL mode, the Wake-up duration in symbol periods. During this period, Wake-up frames will be transmitted. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_8_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACCSLSTARTSAMPLETIME</name>
	<description>In CSL mode, the control register macCSLstartSampleTime indicates the TimeStamp generator time (in symbol periods) when to start listening (called idle listening) or transmitting (when tx_flag_status is set). </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_9_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACCSLFRAMEPENDINGWAITT</name>
	<description>In CSL mode, if a non Wake-up frame with Frame Pending bit = '1' is received, the receiver is enabled for at least an extra period of macCSLFramePendingWaitT (in symbol periods) after the end of the received frame.
The time the Enhanced ACK transmission lasts (if applicable) is included in this time. </description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>MACCSLDATAPERIOD</name>
	<description>In CSL mode, after the wake-up sequence a data frame is expected. The receiver will be enabled for at least a period of macCSLdataPeriod (in symbol periods). </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_DELTA_REG</name>
	<description>Lmac delta control register</description>
	<addressOffset>0x00010070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007e</resetMask>
	<fields>
	<field>
	<name>WAKEUPTIMERENABLESTATUS_D</name>
	<description>Delta which indicates that WakeupTimerEnableStatus has changed
This delta bit is set to '1' on each change of this status, contributes to ftdf_ce[3]. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>GETGENERATORVAL_E</name>
	<description>Event, set to '1' to indicate that the the getGeneratorVal request is completed.
This event bit contributes to ftdf_ce[3]. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>SYMBOLTIME2THR_E</name>
	<description>Event, set to '1' when the symboltime counter matched SymbolTime2Thr
This event bit contributes to ftdf_ce[3]. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>SYMBOLTIMETHR_E</name>
	<description>Event, set to '1' when the symboltime counter matched SymbolTimeThr
This event bit contributes to ftdf_ce[3]. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SYNCTIMESTAMP_E</name>
	<description>The SyncTimeStamp_e event is set to '1' when the TimeStampgenerator is loaded with SyncTimeStampVal.
This occurs at the rising edge of lp_clk when SyncTimeStampEna is set and the value of the Event generator is equal to the value SyncTimestampThr.
This event bit contributes to ftdf_ce[3]. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>LMACREADY4SLEEP_D</name>
	<description>Delta bit for register LmacReady4sleep.
This delta bit is set to '1' on each change of this status, contributes to ftdf_ce[3]. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_MASK_REG</name>
	<description>Lmac mask control register</description>
	<addressOffset>0x00010080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007e</resetMask>
	<fields>
	<field>
	<name>WAKEUPTIMERENABLESTATUS_M</name>
	<description>Mask for WakeupTimerEnableStatus_d
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>GETGENERATORVAL_M</name>
	<description>Mask for getGeneratorVal_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>SYMBOLTIME2THR_M</name>
	<description>Mask for SymbolTime2Thr_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>SYMBOLTIMETHR_M</name>
	<description>Mask for SymbolTimeThr_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SYNCTIMESTAMP_M</name>
	<description>Mask bit for event register SyncTimeStamp_e.
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>LMACREADY4SLEEP_M</name>
	<description>Mask bit for delta bit LmacReady4sleep_d.
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_OS_REG</name>
	<description>Lmac control register</description>
	<addressOffset>0x00010050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>CSMA_CA_RESUME_CLEAR</name>
	<description>If set, Csma_Ca_resume_stat is cleared </description>
	<access>write-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>CSMA_CA_RESUME_SET</name>
	<description>If set, Csma_Ca_resume_stat is set </description>
	<access>write-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SINGLECCA</name>
	<description>If set to '1', a single CCA will be performed.
This can be used when e.g. the TSCH timing is not performed by the LMAC but completely by software. </description>
	<access>write-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RXENABLE</name>
	<description>If set, receiving data may be done </description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>GETGENERATORVAL</name>
	<description>If set to '1', the current values of the Wake-up (event) counter/generator (EventCurrVal) and Timestamp (symbol) counter/generator (TimeStampCurrVal and TimeStampCurrPhaseVal) will be captured.
Note that this capture actually has been done when getGeneratorVal_e is set (assuming it was cleared in advance). </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_CONTROL_STATUS_REG</name>
	<description>Lmac status register</description>
	<addressOffset>0x00010054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>CSMA_CA_BO_STAT</name>
	<description>The value of the currently calculated BackOff value. To be used for the sleep time calculation in case of sleep during the BackOff time. </description>
	<access>read-only</access>
	<bitRange>[31:24]</bitRange>
	
</field><field>
	<name>CSMA_CA_RESUME_STAT</name>
	<description>In case Csma_Ca_resume_stat is set the LMAC will
- use the value of Csma_Ca_NB_val in the CSMA-CA process rather than the initial value 0d.
- immediately perform CCA after the sleep, not waiting for the backoff time.
- reset Csma_Ca_resume_stat when it resumes CSMA-CA after the sleep. </description>
	<access>read-only</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>CSMA_CA_NB_STAT</name>
	<description>Current status of the Number of Backoffs. </description>
	<access>read-only</access>
	<bitRange>[18:16]</bitRange>
	
</field><field>
	<name>EDSCANVALUE</name>
	<description>The result of an ED scan. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>WAKEUPTIMERENABLESTATUS</name>
	<description>Status of WakeupTimerEnable after being clocked by LP_CLK (showing it's effective value).
WakeupTimerEnableStatus can be set by setting the one-shot register WakeupTimerEnable_set and cleared by setting the one-shot register WakeupTimerEnable_clear.
When WakeupTimerEnableStatus is set (after being cleared), the event counter will be reset to 0x0.

This status can be used by software since WakeupTimerEnable is used in the slow LP_CLK area.
Rather than waiting for a certain number of LP_CLK periods, simply scanning this status (or enable the interrupt created by WakeupTimerEnableStatus_e) will allow software to determine if this signal has been effected.
Note that the rising edge of WakeupTimerEnable will reset the Wake-up (event) counter. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>CCASTAT</name>
	<description>The value of a single CCA, valid when CCAstat_e is set to '1'. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>LMACREADY4SLEEP</name>
	<description>If set to '1' this register indicates that the LMAC is ready to go to sleep. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_EVENT_REG</name>
	<description>Lmac event regsiter</description>
	<addressOffset>0x00010090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>CSMA_CA_BO_THR_E</name>
	<description>If set, the calculated backoff time is more than Csma_Ca_BO_threshold.
This event bit contributes to ftdf_ce[1]. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RXTIMEREXPIRED_E</name>
	<description>Set to '1' if one of the timers enabling the Rx-on mode expires without having received any valid frame.
This event bit contributes to ftdf_ce[1]. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CCASTAT_E</name>
	<description>If set to '1', the single CCA is ready
This event bit contributes to ftdf_ce[1]. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>EDSCANREADY_E</name>
	<description>The event EdScanReady_e is set to '1' to notify that the ED scan is ready.
This event bit contributes to ftdf_ce[1]. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_MANUAL_1_REG</name>
	<description>Lmax manual PHY register</description>
	<addressOffset>0x000100a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>LMAC_MANUAL_PHY_ATTR_HSI</name>
	<description>HighSide injection. </description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_PHY_ATTR_RF_GPIO_PINS</name>
	<description>Slot-basis signals mapped on GPIO via PPA. </description>
	<access>read-write</access>
	<bitRange>[30:28]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_PHY_ATTR_CALCAP</name>
	<description>CalCap value. </description>
	<access>read-write</access>
	<bitRange>[27:24]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_PHY_ATTR_CN</name>
	<description>Channel Number. </description>
	<access>read-write</access>
	<bitRange>[23:20]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_PHY_ATTR_DEM_PTI</name>
	<description>DEM packet information. </description>
	<access>read-write</access>
	<bitRange>[19:16]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_PTI</name>
	<description>lmac_manual_pti controls the PTI interface signal when lmac_manual_mode is set to '1'. </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_TX_FRM_NR</name>
	<description>lmac_manual_tx_frm_nr controls the entry in the tx buffer to be transmitted when lmac_manual_mode is set to '1'. </description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_ED_REQUEST</name>
	<description>lmac_manual_ed_request controls the ED_REQUEST interface signal when lmac_manual_mode is set to '1'. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_RX_PIPE_EN</name>
	<description>lmac_manual_rx_pipe_en controls the rx_enable signal towards the rx pipeline when lmac_manual_mode is set to '1'. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_RX_EN</name>
	<description>lmac_manual_rx_en controls the RX_EN interface signal when lmac_manual_mode is set to '1'. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_TX_EN</name>
	<description>lmac_manual_tx_en controls the TX_EN interface signal when lmac_manual_mode is set to '1'. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_PHY_EN</name>
	<description>lmac_manual_phy_en controls the PHY_EN interface signal when lmac_manual_mode is set to '1'. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_MODE</name>
	<description>If the control register lmac_manual_mode is set to '1', the LMAC controller control signals should be controlled by the lmac_manual_control registers </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_MANUAL_OS_REG</name>
	<description>One shot register triggers transmission in manual mode</description>
	<addressOffset>0x000100a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>LMAC_MANUAL_TX_START</name>
	<description>One shot register which triggers the transmission of a frame from the tx buffer in lmac_manual_mode to '1'. </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_MANUAL_STATUS_REG</name>
	<description>Lmac status register in manual mode</description>
	<addressOffset>0x000100a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ff01</resetMask>
	<fields>
	<field>
	<name>LMAC_MANUAL_ED_STAT</name>
	<description>lmac_manual_ed_stat shows the status of the ED_STAT DPHY interface signal. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>LMAC_MANUAL_CCA_STAT</name>
	<description>lmac_manual_cca_stat shows the status of the CCA_STAT DPHY interface signal. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LMAC_MASK_REG</name>
	<description>Lmac mask register</description>
	<addressOffset>0x00010094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>CSMA_CA_BO_THR_M</name>
	<description>Mask bit for event Csma_Ca_BO_thr_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RXTIMEREXPIRED_M</name>
	<description>Mask bit for event RxTimerExpired_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CCASTAT_M</name>
	<description>Mask bit for event CCAstat_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>EDSCANREADY_M</name>
	<description>Mask bit for event EdScanReady_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LONG_ADDR_0_0_REG</name>
	
	<addressOffset>0x00012000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>EXP_SA_L</name>
	<description>Lowest part of the 64 bits long source address or SA entry 1 resp. SA entry 0 in case of short source address. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_LONG_ADDR_1_0_REG</name>
	
	<addressOffset>0x00012004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>EXP_SA_H</name>
	<description>Highest part of the 64 bits long source address or SA entry 3 resp. SA entry 2 in case of short source address. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_MACACKWAITDURATION_REG</name>
	<description>Maximum time to wait for a ACK</description>
	<addressOffset>0x00010038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000036</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>MACACKWAITDURATION</name>
	<description>Maximum time (in symbol periods) to wait for an ACK response after transmitting a frame with the AR bit set to '1'.
This value is used in the normal mode for the wait of an ACK response, irrespective if the ACK is a normal ACK or an Enhanced ACK. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_MACENHACKWAITDURATION_REG</name>
	<description>Maximum time to wait for an enhanced ACK frame</description>
	<addressOffset>0x0001003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000360</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MACENHACKWAITDURATION</name>
	<description>Maximum time (in us) to wait for an Enhanced ACK response after transmitting a frame with the AR bit set to '1'.
This value is used in the LE/CSL mode for the wait of an ACK response (which is always an Enhanced ACK). </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_MACFCSERRORCOUNT_REG</name>
	<description>Lmac FCS error register</description>
	<addressOffset>0x00010340</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACFCSERRORCOUNT</name>
	<description>metrics counter: the number of received frames that were discarded due to an incorrect FCS after the last deep-sleep cycle. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_MACRXADDRFAILFRMCNT_REG</name>
	<description>Discarded frames register</description>
	<addressOffset>0x00010318</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACRXADDRFAILFRMCNT</name>
	<description>Traffic counter: the number of frames discarded due to incorrect address or PAN Id after the last deep-sleep cycle. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_MACRXSTDACKFRMOKCNT_REG</name>
	<description>Received acknowledgment frames</description>
	<addressOffset>0x00010314</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACRXSTDACKFRMOKCNT</name>
	<description>Traffic counter: the number of Standard Acknowledgment frames received after the last deep-sleep cycle. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_MACRXUNSUPFRMCNT_REG</name>
	<description>Unsupported frames register</description>
	<addressOffset>0x0001031c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACRXUNSUPFRMCNT</name>
	<description>Traffic counter: the number of frames which do pass the checks but are not supported after the last deep-sleep cycle. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_MACTSTXACKDELAYVAL_REG</name>
	<description>Time left until next ACK is sent (us)</description>
	<addressOffset>0x00010078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MACTSTXACKDELAYVAL</name>
	<description>The time (in us) left until the ack frame is sent by the lmac.
This can be used by software to determine if there is enough time left to send the, by software created, Enhanced ACK frame. </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_MACTXSTDACKFRMCNT_REG</name>
	<description>Transmitted acknowledgment frames</description>
	<addressOffset>0x00010310</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACTXSTDACKFRMCNT</name>
	<description>Traffic counter: the number of standard Acknowledgment frames transmitted after the last deep-sleep cycle. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_PHY_PARAMETERS_0_REG</name>
	<description>Lmac PHY parameter register</description>
	<addressOffset>0x00010180</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x76543210</resetValue>
	<resetMask>0x77777777</resetMask>
	<fields>
	<field>
	<name>RXBITPOS_7</name>
	<description>DPHY interface: see rxBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[30:28]</bitRange>
	
</field><field>
	<name>RXBITPOS_6</name>
	<description>DPHY interface: see rxBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[26:24]</bitRange>
	
</field><field>
	<name>RXBITPOS_5</name>
	<description>DPHY interface: see rxBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[22:20]</bitRange>
	
</field><field>
	<name>RXBITPOS_4</name>
	<description>DPHY interface: see rxBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[18:16]</bitRange>
	
</field><field>
	<name>RXBITPOS_3</name>
	<description>DPHY interface: see rxBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[14:12]</bitRange>
	
</field><field>
	<name>RXBITPOS_2</name>
	<description>DPHY interface: see rxBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>RXBITPOS_1</name>
	<description>DPHY interface: see rxBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>RXBITPOS_0</name>
	<description>DPHY interface: control rxBitPos(8)(3) controls the position that a bit should have at the DPHY interface.
So the default values are rxBitPos_0 = 0, rxBitPos_1 = 1, rxBitPos_2 = 2, etc.

Note1 that this is a conversion from rx DPHY interface to the internal data byte
So
for(n=7;n&gt;=0;n--)
rx_data(n) = dphy_bit(tx_BitPos(n))
endfor

Note2 that rxBitPos and txBitPos must have inverse functions. </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_PHY_PARAMETERS_1_REG</name>
	<description>Lmac PHY parameter register</description>
	<addressOffset>0x00010184</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x76543210</resetValue>
	<resetMask>0x77777777</resetMask>
	<fields>
	<field>
	<name>TXBITPOS_7</name>
	<description>DPHY interface: see txBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[30:28]</bitRange>
	
</field><field>
	<name>TXBITPOS_6</name>
	<description>DPHY interface: see txBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[26:24]</bitRange>
	
</field><field>
	<name>TXBITPOS_5</name>
	<description>DPHY interface: see txBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[22:20]</bitRange>
	
</field><field>
	<name>TXBITPOS_4</name>
	<description>DPHY interface: see txBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[18:16]</bitRange>
	
</field><field>
	<name>TXBITPOS_3</name>
	<description>DPHY interface: see txBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[14:12]</bitRange>
	
</field><field>
	<name>TXBITPOS_2</name>
	<description>DPHY interface: see txBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>TXBITPOS_1</name>
	<description>DPHY interface: see txBitPos_0 </description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>TXBITPOS_0</name>
	<description>DPHY interface: control txBitPos(8)(3) controls the position that a bit should have at the DPHY interface.
So the default values are txBitPos_0 = 0, txBitPos_1 = 1, txBitPos_2 = 2, etc.

Note1 that this is a conversion from internal data byte to the DPHY interface.
So
for(n=7;n&gt;=0;n--)
tx_dphy_bit(n) = tx_data(tx_BitPos(n))
endfor

Note2 that txBitPos and rxBitPos must have inverse functions. </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_PHY_PARAMETERS_2_REG</name>
	<description>Lmac PHY parameter register</description>
	<addressOffset>0x00010188</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PHYTRXWAIT</name>
	<description>DPHY interface: Phy wait time (in us) between deassertion of TX_EN and assertion of RX_EN or vice versa. </description>
	<access>read-write</access>
	<bitRange>[31:24]</bitRange>
	
</field><field>
	<name>PHYTXFINISH</name>
	<description>DPHY interface: Phy wait time (in us) before deasserting TX_EN after deasserting TX_VALID. </description>
	<access>read-write</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>PHYTXLATENCY</name>
	<description>DPHY interface: phy delay (in us) between DPHY interface and air interface. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>PHYTXSTARTUP</name>
	<description>DPHY interface: the phy wait time (in us) before transmission of a frame may start. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_PHY_PARAMETERS_3_REG</name>
	<description>Lmac PHY parameter register</description>
	<addressOffset>0x0001018c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x01000000</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields>
	<field>
	<name>USE_LEGACY_PHY_EN</name>
	<description>If the control register use_legacy_phy_en is set (default), the output signal PHY_TRANSACTION will be sourced by PHY_EN rather than PHY_TRANSACTION. </description>
	<access>read-write</access>
	<bitRange>[24:24]</bitRange>
	
</field><field>
	<name>PHYENABLE</name>
	<description>DPHY interface: Asserting the DPHY interface signals TX_EN or RX_EN does not take place within the time phyEnable after asserting the signal PHY_EN.
(in us). </description>
	<access>read-write</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>PHYRXLATENCY</name>
	<description>DPHY interface: Phy delay (in us) between air and DPHY interface. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>PHYRXSTARTUP</name>
	<description>DPHY interface: Phy wait time (in us) before receiving of a frame may start. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_REL_NAME_0_REG</name>
	<description>Name of the release</description>
	<addressOffset>0x00010000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>REL_NAME</name>
	<description>A 4 words wide register, showing in ASCII the name of the release, eg. ftdf_107. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_REL_NAME_1_REG</name>
	<description>Name of the release</description>
	<addressOffset>0x00010004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>REL_NAME</name>
	<description>A 4 words wide register, showing in ASCII the name of the release, eg. ftdf_107. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_REL_NAME_2_REG</name>
	<description>Name of the release</description>
	<addressOffset>0x00010008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>REL_NAME</name>
	<description>A 4 words wide register, showing in ASCII the name of the release, eg. ftdf_107. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_REL_NAME_3_REG</name>
	<description>Name of the release</description>
	<addressOffset>0x0001000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>REL_NAME</name>
	<description>A 4 words wide register, showing in ASCII the name of the release, eg. ftdf_107. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_CONTROL_0_REG</name>
	<description>Receive control register</description>
	<addressOffset>0x00010200</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0fffffff</resetMask>
	<fields>
	<field>
	<name>DISRXACKRECEIVEDCA</name>
	<description>If set to '1', the LMAC controller shall ignore all consequent actions upon a set AR bit in the transmitted frame (e.g. enabling Rx-on mode after the transmission and wait for an ACK). </description>
	<access>read-write</access>
	<bitRange>[27:27]</bitRange>
	
</field><field>
	<name>MACIMPLICITBROADCAST</name>
	<description>If set to '1', Frame Version 2 frames without Daddr or DPANId shall be accepted. </description>
	<access>read-write</access>
	<bitRange>[26:26]</bitRange>
	
</field><field>
	<name>MACPASSWAKEUP</name>
	<description>In CSL mode, if set to '1', WakeUp frames will be put into the Rx buffer.
This can be useful for software to parse the WakeUp frame. </description>
	<access>read-write</access>
	<bitRange>[25:25]</bitRange>
	
</field><field>
	<name>MACALWAYSPASSWAKEUP</name>
	<description>In CSL mode, if the control register macAlwaysPassWakeUp is set to '1', received Wake- up frames for this device are put into the Rx packet buffer without notifying the LMAC Controller (part of transparent mode control). </description>
	<access>read-write</access>
	<bitRange>[24:24]</bitRange>
	
</field><field>
	<name>MACALWAYSPASSFRMTYPE</name>
	<description>The control registers macAlwaysPassFrmType[7:0], shall control if this Frame Type shall be dropped.
If a bit is set to '1', the Frame Type corresponding with the bit position is not dropped, even in case of a CRC error.
Example:
if bit 3 is set to '1', Frame Type 3 shall not be dropped.
If there is a FCS error, the error shall be reported in the Rx meta data (crc16_error is set to '1'). </description>
	<access>read-write</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>MACALWAYSPASSTOPANCOORDINATOR</name>
	<description>When the control register macAlwaysPassToPanCoordinator is set to '1', the frame is not dropped due to a span_coord_error.
However, in case of an FCS error, the packet is dropped. </description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>MACALWAYSPASSBEACONWRONGPANID</name>
	<description>If the control register macAlwaysPassBeaconWrongPANId is set, the frame is not dropped in case of a mismatch in PAN-ID, irrespective of the setting of RxBeaconOnly. </description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>MACALWAYSPASSWRONGDADDR</name>
	<description>If set to '1', a packet with a wrong DAddr is not dropped </description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>MACALWAYSPASSWRONGDPANID</name>
	<description>If register macAlwaysPassWrongDPANId is set to '1', packet with a wrong Destiantion PanID will not be dropped.
However, in case of an FCS error, the packet is dropped. </description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>MACALWAYSPASSRESFRAMEVERSION</name>
	<description>If set to '1', a packet with a reserved FrameVersion shall not be dropped </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>DISDATAREQUESTCA</name>
	<description>When the control register DisDataRequestCa is set, the notification of the received Data Request is disabled. </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>MACALWAYSPASSCRCERROR</name>
	<description>If set to '1', a FCS error will not drop the frame. However, an FCS error will be reported in the Rx meta data (crc16_error is set to '1'). </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>DISRXACKREQUESTCA</name>
	<description>When the control register DisRxAckRequestca is set to '1' all consequent actions for a received Acknowledge Request bit are disabled. </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DISRXFRMPENDINGCA</name>
	<description>Whan the control register DisRxFrmPendingCa is set to '1', the notification of the received FP bit to the LMAC Controller is disabled and thus no consequent actions will take place. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>RX_READ_BUF_PTR</name>
	<description>Indication where new data will be read
All four bits shall be used when using these pointer values (0d - 15d).
However, the Receive Packet buffer has a size of 8 entries.
So reading the Receive Packet buffer entries shall use the mod8 of the pointer values. </description>
	<access>read-write</access>
	<bitRange>[6:3]</bitRange>
	
</field><field>
	<name>RXCOORDREALIGNONLY</name>
	<description>If set to '1', only Coordinator Realignment frames are accepted </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RXBEACONONLY</name>
	<description>If set to '1', only Beacons frames are accepted </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DBGRXTRANSPARENTMODE</name>
	<description>If set yo '1', Rx pipe is fully set in transparent mode (for debug purpose). </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_EVENT_REG</name>
	<description>Receive event register</description>
	<addressOffset>0x00010204</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>RXBYTE_E</name>
	<description>If set to '1' it indicates that the first byte of a new packet has been received
This event bit contributes to ftdf_ce[1]. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RX_BUF_AVAIL_E</name>
	<description>If set to '1' it indicates that a new valid packet has been completely received
This event bit contributes to ftdf_ce[1]. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RX_OVERFLOW_E</name>
	<description>If set to '1' it indicates that the Rx packet buffer has an overflow.
This event bit contributes to ftdf_ce[1]. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RXSOF_E</name>
	<description>Set to '1' when RX_SOF has been detected.
This event bit contributes to ftdf_ce[1]. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_FIFO_0_0_REG</name>
	<description>Address receive fifo 0</description>
	<addressOffset>0x00008000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_FIFO</name>
	<description>Receive fifo ram, contains 32 addresses per entry (32b x 32a = 128B). There are 8 entries supported. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_FIFO_1_0_REG</name>
	<description>Address transmit fifo 1</description>
	<addressOffset>0x00008080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_FIFO</name>
	<description>Receive fifo ram, contains 32 addresses per entry (32b x 32a = 128B). There are 8 entries supported. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_FIFO_2_0_REG</name>
	<description>Address transmit fifo 2</description>
	<addressOffset>0x00008100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_FIFO</name>
	<description>Receive fifo ram, contains 32 addresses per entry (32b x 32a = 128B). There are 8 entries supported. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_FIFO_3_0_REG</name>
	<description>Address transmit fifo 3</description>
	<addressOffset>0x00008180</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_FIFO</name>
	<description>Receive fifo ram, contains 32 addresses per entry (32b x 32a = 128B). There are 8 entries supported. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_FIFO_4_0_REG</name>
	<description>Address transmit fifo 4</description>
	<addressOffset>0x00008200</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_FIFO</name>
	<description>Receive fifo ram, contains 32 addresses per entry (32b x 32a = 128B). There are 8 entries supported. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_FIFO_5_0_REG</name>
	<description>Address transmit fifo 5</description>
	<addressOffset>0x00008280</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_FIFO</name>
	<description>Receive fifo ram, contains 32 addresses per entry (32b x 32a = 128B). There are 8 entries supported. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_FIFO_6_0_REG</name>
	<description>Address transmit fifo 6</description>
	<addressOffset>0x00008300</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_FIFO</name>
	<description>Receive fifo ram, contains 32 addresses per entry (32b x 32a = 128B). There are 8 entries supported. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_FIFO_7_0_REG</name>
	<description>Address transmit fifo 7</description>
	<addressOffset>0x00008380</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_FIFO</name>
	<description>Receive fifo ram, contains 32 addresses per entry (32b x 32a = 128B). There are 8 entries supported. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_MASK_REG</name>
	<description>Receive event mask register</description>
	<addressOffset>0x00010208</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>RXBYTE_M</name>
	<description>Mask bit for event rxbyte_e.
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RX_BUF_AVAIL_M</name>
	<description>Mask bit for event rx_buf_avail_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RX_OVERFLOW_M</name>
	<description>Mask bit for event rx_overflow_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RXSOF_M</name>
	<description>Mask bit for event RxSof_e.
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_0_0_REG</name>
	<description>Receive metadata register 0</description>
	<addressOffset>0x00000280</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_TIMESTAMP</name>
	<description>Rx meta data per entry: Timestamp taken when frame was received </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_0_1_REG</name>
	<description>Receive metadata register 1</description>
	<addressOffset>0x00000290</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_TIMESTAMP</name>
	<description>Rx meta data per entry: Timestamp taken when frame was received </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_0_2_REG</name>
	<description>Receive metadata register 2</description>
	<addressOffset>0x000002a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_TIMESTAMP</name>
	<description>Rx meta data per entry: Timestamp taken when frame was received </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_0_3_REG</name>
	<description>Receive metadata register 3</description>
	<addressOffset>0x000002b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_TIMESTAMP</name>
	<description>Rx meta data per entry: Timestamp taken when frame was received </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_0_4_REG</name>
	<description>Receive metadata register 4</description>
	<addressOffset>0x000002c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_TIMESTAMP</name>
	<description>Rx meta data per entry: Timestamp taken when frame was received </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_0_5_REG</name>
	<description>Receive metadata register 5</description>
	<addressOffset>0x000002d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_TIMESTAMP</name>
	<description>Rx meta data per entry: Timestamp taken when frame was received </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_0_6_REG</name>
	<description>Receive metadata register 6</description>
	<addressOffset>0x000002e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_TIMESTAMP</name>
	<description>Rx meta data per entry: Timestamp taken when frame was received </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_0_7_REG</name>
	<description>Receive metadata register 7</description>
	<addressOffset>0x000002f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>RX_TIMESTAMP</name>
	<description>Rx meta data per entry: Timestamp taken when frame was received </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_1_0_REG</name>
	<description>Receive metadata register 0</description>
	<addressOffset>0x00000284</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000fffd</resetMask>
	<fields>
	<field>
	<name>QUALITY_INDICATOR</name>
	<description>Rx meta data per entry: the Link Quality Indication value during reception of this frame.

# $software_scratch@retention_ram
# TX ram not used by hardware, can be used by software as scratch ram with retention. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ISPANID_COORD_ERROR</name>
	<description>Rx meta data per entry: if set to '1', the received frame is not for PAN coordinator, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DADDR_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination Address error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RES_FRM_VERSION_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame version, applicable when frame is not discarded. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RES_FRM_TYPE_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame type, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CRC16_ERROR</name>
	<description>Rx meta data per entry: if set, a CRC error has occurred in this frame, applicable for transparent mode only </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_1_1_REG</name>
	<description>Receive metadata register 1</description>
	<addressOffset>0x00000294</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000fffd</resetMask>
	<fields>
	<field>
	<name>QUALITY_INDICATOR</name>
	<description>Rx meta data per entry: the Link Quality Indication value during reception of this frame.

# $software_scratch@retention_ram
# TX ram not used by hardware, can be used by software as scratch ram with retention. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ISPANID_COORD_ERROR</name>
	<description>Rx meta data per entry: if set to '1', the received frame is not for PAN coordinator, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DADDR_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination Address error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RES_FRM_VERSION_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame version, applicable when frame is not discarded. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RES_FRM_TYPE_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame type, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CRC16_ERROR</name>
	<description>Rx meta data per entry: if set, a CRC error has occurred in this frame, applicable for transparent mode only </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_1_2_REG</name>
	<description>Receive metadata register 2</description>
	<addressOffset>0x000002a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000fffd</resetMask>
	<fields>
	<field>
	<name>QUALITY_INDICATOR</name>
	<description>Rx meta data per entry: the Link Quality Indication value during reception of this frame.

# $software_scratch@retention_ram
# TX ram not used by hardware, can be used by software as scratch ram with retention. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ISPANID_COORD_ERROR</name>
	<description>Rx meta data per entry: if set to '1', the received frame is not for PAN coordinator, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DADDR_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination Address error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RES_FRM_VERSION_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame version, applicable when frame is not discarded. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RES_FRM_TYPE_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame type, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CRC16_ERROR</name>
	<description>Rx meta data per entry: if set, a CRC error has occurred in this frame, applicable for transparent mode only </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_1_3_REG</name>
	<description>Receive metadata register 3</description>
	<addressOffset>0x000002b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000fffd</resetMask>
	<fields>
	<field>
	<name>QUALITY_INDICATOR</name>
	<description>Rx meta data per entry: the Link Quality Indication value during reception of this frame.

# $software_scratch@retention_ram
# TX ram not used by hardware, can be used by software as scratch ram with retention. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ISPANID_COORD_ERROR</name>
	<description>Rx meta data per entry: if set to '1', the received frame is not for PAN coordinator, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DADDR_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination Address error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RES_FRM_VERSION_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame version, applicable when frame is not discarded. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RES_FRM_TYPE_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame type, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CRC16_ERROR</name>
	<description>Rx meta data per entry: if set, a CRC error has occurred in this frame, applicable for transparent mode only </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_1_4_REG</name>
	<description>Receive metadata register 4</description>
	<addressOffset>0x000002c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000fffd</resetMask>
	<fields>
	<field>
	<name>QUALITY_INDICATOR</name>
	<description>Rx meta data per entry: the Link Quality Indication value during reception of this frame.

# $software_scratch@retention_ram
# TX ram not used by hardware, can be used by software as scratch ram with retention. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ISPANID_COORD_ERROR</name>
	<description>Rx meta data per entry: if set to '1', the received frame is not for PAN coordinator, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DADDR_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination Address error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RES_FRM_VERSION_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame version, applicable when frame is not discarded. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RES_FRM_TYPE_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame type, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CRC16_ERROR</name>
	<description>Rx meta data per entry: if set, a CRC error has occurred in this frame, applicable for transparent mode only </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_1_5_REG</name>
	<description>Receive metadata register 5</description>
	<addressOffset>0x000002d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000fffd</resetMask>
	<fields>
	<field>
	<name>QUALITY_INDICATOR</name>
	<description>Rx meta data per entry: the Link Quality Indication value during reception of this frame.

# $software_scratch@retention_ram
# TX ram not used by hardware, can be used by software as scratch ram with retention. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ISPANID_COORD_ERROR</name>
	<description>Rx meta data per entry: if set to '1', the received frame is not for PAN coordinator, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DADDR_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination Address error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RES_FRM_VERSION_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame version, applicable when frame is not discarded. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RES_FRM_TYPE_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame type, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CRC16_ERROR</name>
	<description>Rx meta data per entry: if set, a CRC error has occurred in this frame, applicable for transparent mode only </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_1_6_REG</name>
	<description>Receive metadata register 6</description>
	<addressOffset>0x000002e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000fffd</resetMask>
	<fields>
	<field>
	<name>QUALITY_INDICATOR</name>
	<description>Rx meta data per entry: the Link Quality Indication value during reception of this frame.

# $software_scratch@retention_ram
# TX ram not used by hardware, can be used by software as scratch ram with retention. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ISPANID_COORD_ERROR</name>
	<description>Rx meta data per entry: if set to '1', the received frame is not for PAN coordinator, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DADDR_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination Address error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RES_FRM_VERSION_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame version, applicable when frame is not discarded. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RES_FRM_TYPE_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame type, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CRC16_ERROR</name>
	<description>Rx meta data per entry: if set, a CRC error has occurred in this frame, applicable for transparent mode only </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_META_1_7_REG</name>
	<description>Receive metadata register 7</description>
	<addressOffset>0x000002f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000fffd</resetMask>
	<fields>
	<field>
	<name>QUALITY_INDICATOR</name>
	<description>Rx meta data per entry: the Link Quality Indication value during reception of this frame.

# $software_scratch@retention_ram
# TX ram not used by hardware, can be used by software as scratch ram with retention. </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ISPANID_COORD_ERROR</name>
	<description>Rx meta data per entry: if set to '1', the received frame is not for PAN coordinator, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DADDR_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination Address error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DPANID_ERROR</name>
	<description>Rx meta data per entry: if set to '1', a destination PAN ID error has occurred, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RES_FRM_VERSION_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame version, applicable when frame is not discarded. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RES_FRM_TYPE_ERROR</name>
	<description>Rx meta data per entry: if set to '1' this frame is a not supported frame type, applicable when frame is not discarded </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CRC16_ERROR</name>
	<description>Rx meta data per entry: if set, a CRC error has occurred in this frame, applicable for transparent mode only </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_STATUS_DELTA_REG</name>
	<description>Receive status delta register</description>
	<addressOffset>0x00010220</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>RX_BUFF_IS_FULL_D</name>
	<description>Delta bit of status rx_buff_is_full.
This delta bit is set to '1' on each change of this status, contributes to ftdf_ce[1]. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_STATUS_MASK_REG</name>
	<description>Receive status delta mask register</description>
	<addressOffset>0x00010224</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>RX_BUFF_IS_FULL_M</name>
	<description>Mask bit for delta bit rx_buff_is_full_d
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_RX_STATUS_REG</name>
	<description>Receive status register</description>
	<addressOffset>0x0001020c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>RX_WRITE_BUF_PTR</name>
	<description>Indication where new data will be written.
All four bits shall be used when using these pointer values (0d - 15d).
However, the Receive Packet buffer has a size of 8 entries.
So reading the Receive Packet buffer entries shall use the mod8 of the pointer values. </description>
	<access>read-only</access>
	<bitRange>[4:1]</bitRange>
	
</field><field>
	<name>RX_BUFF_IS_FULL</name>
	<description>If set to '1', it indicates that the Rx packet buffer is full </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECKEY_0_REG</name>
	<description>Seckey register</description>
	<addressOffset>0x00010118</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SECKEY_0</name>
	<description>Encryption/decryption mode: Registers secKey[0..3] contain the key to be used. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECKEY_1_REG</name>
	<description>Seckey register</description>
	<addressOffset>0x0001011c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SECKEY_1</name>
	<description>Encryption/decryption mode: see register secKey_0 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECKEY_2_REG</name>
	<description>SecKey register</description>
	<addressOffset>0x00010120</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SECKEY_2</name>
	<description>Encryption/decryption mode: see register secKey_0 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECKEY_3_REG</name>
	<description>Seckey register</description>
	<addressOffset>0x00010124</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SECKEY_3</name>
	<description>Encryption/decryption mode: see register secKey_0</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECNONCE_0_REG</name>
	<description>Nonce register used for encryption/decryption</description>
	<addressOffset>0x00010128</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SECNONCE_0</name>
	<description>Encryption/decryption mode: register secNonce[0..3] contains the Nonce to be used for encryption/decryption. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECNONCE_1_REG</name>
	<description>Nonce register used for encryption/decryption</description>
	<addressOffset>0x0001012c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SECNONCE_1</name>
	<description>Encryption/decryption mode: see register Nonce_0 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECNONCE_2_REG</name>
	<description>Nonce register used for encryption/decryption</description>
	<addressOffset>0x00010130</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SECNONCE_2</name>
	<description>Encryption/decryption mode: see register Nonce_0 </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECNONCE_3_REG</name>
	<description>Nonce register used for encryption/decryption</description>
	<addressOffset>0x00010134</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>SECNONCE_3</name>
	<description>Encryption/decryption mode: see register Nonce_0 </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECURITY_0_REG</name>
	<description>Security register</description>
	<addressOffset>0x00010110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SECENCDECN</name>
	<description>Encryption/decryption mode: the control register secEncDecn indicates whether to encrypt ('1') or decrypt ('0') the data. </description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>SECMLENGTH</name>
	<description>Encryption/decryption mode: the length of the m_data is indicated by control register secMlength (in bytes). </description>
	<access>read-write</access>
	<bitRange>[30:24]</bitRange>
	
</field><field>
	<name>SECALENGTH</name>
	<description>Encryption/decryption mode: the length of the a_data is indicated by control register secAlength (in bytes).
The end of the a_data is the start point of the m_data. So secAlength must also be set if security level==4. </description>
	<access>read-write</access>
	<bitRange>[22:16]</bitRange>
	
</field><field>
	<name>SECENTRY</name>
	<description>Encryption/decryption mode: the software indicates by the control registers secEntry and secTxRxn which entry to use and if it's from the Tx or Rx buffer ('1' resp. '0'). </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>SECTXRXN</name>
	<description>Encryption/decryption mode: see register secEntry. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECURITY_1_REG</name>
	<description>Security register</description>
	<addressOffset>0x00010114</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SECENCRFLAGS</name>
	<description>Encryption/decryption mode: register secEncrFlags contains the encryption flags field.
Bits [2:0] are the 3-bit encoding flags of a_data, the other bits msut be set to '0'. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SECAUTHFLAGS</name>
	<description>Encryption/decryption mode: register secAuthFlags contains the authentication flags fields.
bit[7] is '0'
bit[6] is A_data present
bit[5:3]: 3-bit security level of m_data
bit[2:0]: 3-bit security level of a_data. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECURITY_EVENTMASK_REG</name>
	<description>security event mask register</description>
	<addressOffset>0x00010154</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>SECREADY_M</name>
	<description>Mask bit for event secReady_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECURITY_EVENT_REG</name>
	<description>security event register</description>
	<addressOffset>0x00010150</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>SECREADY_E</name>
	<description>Encryption/decryption mode: the Event bit secReady_e is set to '1' when the authentication process is ready (i.e. secBusy is cleared).
This event bit contributes to ftdf_ce[3]. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECURITY_OS_REG</name>
	<description>One shot register to start encryption/decryption</description>
	<addressOffset>0x00010138</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>SECSTART</name>
	<description>Encryption/decryption mode: one_shot register to start the encryption, decryption and authentication support task. </description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SECABORT</name>
	<description>Encryption/decryption mode: see register Nonce_0 </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SECURITY_STATUS_REG</name>
	<description>Security status register</description>
	<addressOffset>0x00010140</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>SECAUTHFAIL</name>
	<description>Encryption/decryption mode: in case of decryption, the status bit secAuthFail will be set when the authentication has failed. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SECBUSY</name>
	<description>Encryption/decryption mode: register secBusy indicates if the encryption/decryption process is still running. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SIZE_AND_VAL_0_REG</name>
	
	<addressOffset>0x00012008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>SHORT_LONGNOT</name>
	<description>A '1' indicates that Exp_SA contains four short SA's, a '0' indicates one long SA. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>VALID_SA</name>
	<description>Indication which SA entry is valid (if set). In case of 4 short SA Valid bit 3 belongs to SA entry 3 etc.
In case of a long SA Valid bit 0 is the valid indication. </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SYMBOLTIME2THR_REG</name>
	<description>Symboltime threshold register 2</description>
	<addressOffset>0x00010384</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SYMBOLTIME2THR</name>
	<description>Symboltime 2 Threshold to generate a general interrupt when this value matches the symbol counter value. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SYMBOLTIMESNAPSHOTVAL_REG</name>
	<description>Value timestamp generator</description>
	<addressOffset>0x00010210</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SYMBOLTIMESNAPSHOTVAL</name>
	<description>The Status register SymbolTimeSnapshotVal indicates the actual value of the TimeStamp generator.
This can be useful for software to use e.g. in CSL mode at creating an Enhanced ACK to calculate the CSL phase and period. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SYMBOLTIMETHR_REG</name>
	<description>Symboltime threshold register 1</description>
	<addressOffset>0x00010380</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SYMBOLTIMETHR</name>
	<description>Symboltime Threshold to generate a general interrupt when this value matches the symbol counter value. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SYNCTIMESTAMPPHASEVAL_REG</name>
	<description>Timestamp phase value regsiter</description>
	<addressOffset>0x00010320</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>SYNCTIMESTAMPPHASEVAL</name>
	<description>Value to synchronize the timestamp counter phase with at the moment indicated by SyncTimeStampThr.
Please note the +1 correction needed for most accurate result (+0.5 is than the average error, resulting is a just too fast clock). </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SYNCTIMESTAMPTHR_REG</name>
	<description>Threshold timestamp generator</description>
	<addressOffset>0x00010304</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x01ffffff</resetMask>
	<fields>
	<field>
	<name>SYNCTIMESTAMPTHR</name>
	<description>Threshold for synchronize the timestamp counter: at this value of the event counter the synchronization of the timestamp (symbol) counter is done (if SyncTimeStampEna is set to '1').
If SyncTimeStamp_e is set to '1' the synchronization has taken place. </description>
	<access>read-write</access>
	<bitRange>[24:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_SYNCTIMESTAMPVAL_REG</name>
	<description>Value timestamp generator</description>
	<addressOffset>0x00010308</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>SYNCTIMESTAMPVAL</name>
	<description>Value to synchronize the timestamp counter with at the moment indicated by SyncTimeStampThr. </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TIMER_CONTROL_1_REG</name>
	<description>Timer control register</description>
	<addressOffset>0x0001030c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000002</resetMask>
	<fields>
	<field>
	<name>SYNCTIMESTAMPENA</name>
	<description>If set to '1', the synchronization of the timestamp counter after a deep-sleep cycle will be performed when SyncTimeStampThr matches the value of the event (wake-up) counter. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TIMESTAMPCURRPHASEVAL_REG</name>
	<description>Value of timestamp generator phase within a symbol</description>
	<addressOffset>0x00010074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>TIMESTAMPCURRPHASEVAL</name>
	<description>Value of captured timestamp generator phase within a symbol (initiated by getGeneratorVal, valid when getGeneratorVal_e is set) </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TIMESTAMPCURRVAL_REG</name>
	<description>Value of timestamp generator</description>
	<addressOffset>0x0001005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TIMESTAMPCURRVAL</name>
	<description>The value of captured timestamp generator (symbol counter) (initiated by getGeneratorVal, valid when getGeneratorVal_e is set) </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TSCH_CONTROL_0_REG</name>
	<description>Lmac tsch control register</description>
	<addressOffset>0x00010160</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x089803e8</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACTSRXWAIT</name>
	<description>TSCH mode: The times to wait for start of frame </description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>MACTSTXACKDELAY</name>
	<description>TSCH mode: the time between the end of a Rx frame and the start of an Enhanced Acknowlegde frame. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TSCH_CONTROL_1_REG</name>
	<description>Lmac tsch control register</description>
	<addressOffset>0x00010164</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000c0</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MACTSRXTX</name>
	<description>TSCH mode: The time between the CCA and the TX of a frame </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TSCH_CONTROL_2_REG</name>
	<description>Lmac tsch control register</description>
	<addressOffset>0x00010168</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x01900320</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>MACTSACKWAIT</name>
	<description>TSCH mode: The minimum time to wait for start of an Acknowledgement </description>
	<access>read-write</access>
	<bitRange>[31:16]</bitRange>
	
</field><field>
	<name>MACTSRXACKDELAY</name>
	<description>TSCH mode: End of frame to when the transmitter shall listen for Acknowledgement </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TXBYTE_E_REG</name>
	<description>Transmit first byte register</description>
	<addressOffset>0x00010394</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>TX_LAST_SYMBOL_E</name>
	<description>If set to '1', it indicates the last symbol of a frame is transmitted
This event bit contributes to ftdf_ce[4]. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>TXBYTE_E</name>
	<description>If set to '1', it indicates the first byte of a frame is transmitted
This event bit contributes to ftdf_ce[4]. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TXBYTE_M_REG</name>
	<description>Transmit first byte mask register</description>
	<addressOffset>0x00010398</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>TX_LAST_SYMBOL_M</name>
	<description>Mask bit for event tx_last_symbol_e.
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>TXBYTE_M</name>
	<description>Mask bit for event txbyte_e.
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TXPIPEPROPDELAY_REG</name>
	<description>Prop delay transmit register</description>
	<addressOffset>0x00010034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>TXPIPEPROPDELAY</name>
	<description>Propagation delay (in us) of the tx pipe, between start of transmission (indicated by setting tx_flag_status) to the DPHY.
The reset value is 0 us, which is also the closest value to the real implementation figure. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_CLEAR_OS_REG</name>
	<description>One shot register to clear flag</description>
	<addressOffset>0x00010484</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_CLEAR</name>
	<description>Tx meta data per entry: if set to '1', the tx_flag_stat will be cleared to '0'. </description>
	<access>write-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_CONTROL_0_REG</name>
	<description>Transmit control register</description>
	<addressOffset>0x00010240</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00004350</resetValue>
	<resetMask>0x00007ff1</resetMask>
	<fields>
	<field>
	<name>MACMAXCSMABACKOFFS</name>
	<description>CSMA-CA: Maximum number of CSMA-CA backoffs (range 0-5) </description>
	<access>read-write</access>
	<bitRange>[14:12]</bitRange>
	
</field><field>
	<name>MACMINBE</name>
	<description>CSMA-CA: Minimum Backoff Exponent (range 0-macMaxBE) </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>MACMAXBE</name>
	<description>CSMA-CA: Maximum Backoff Exponent (range 3-8) </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>DBGTXTRANSPARENTMODE</name>
	<description>If set to '1', the MPDU octets pass transparently through the MAC in the transmit direction (for debug purpose). </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FIFO_0_0_REG</name>
	<description>Address transmit fifo 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TX_FIFO</name>
	<description>Transmit fifo buffer, contains 32 addresses per entry (32b x 32a = 128B). There are 4 entries supported.
Note that, despite the name, this fifo is NOT retained when the LMAC is put into deep-sleep! </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FIFO_1_0_REG</name>
	<description>Address transmit fifo 1</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TX_FIFO</name>
	<description>Transmit fifo buffer, contains 32 addresses per entry (32b x 32a = 128B). There are 4 entries supported.
Note that, despite the name, this fifo is NOT retained when the LMAC is put into deep-sleep! </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FIFO_2_0_REG</name>
	<description>Address transmit fifo 2</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TX_FIFO</name>
	<description>Transmit fifo buffer, contains 32 addresses per entry (32b x 32a = 128B). There are 4 entries supported.
Note that, despite the name, this fifo is NOT retained when the LMAC is put into deep-sleep! </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FIFO_3_0_REG</name>
	<description>Address transmit fifo 3</description>
	<addressOffset>0x00000180</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TX_FIFO</name>
	<description>Transmit fifo buffer, contains 32 addresses per entry (32b x 32a = 128B). There are 4 entries supported.
Note that, despite the name, this fifo is NOT retained when the LMAC is put into deep-sleep! </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_CLEAR_E_0_REG</name>
	<description>Clear flag register 0</description>
	<addressOffset>0x00010404</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_CLEAR_E</name>
	<description>Tx meta data per entry: if set to '1' the LMAC hardware has cleared the tx_flag_stat status.
This event bit contributes to ftdf_ce[4]. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_CLEAR_E_1_REG</name>
	<description>Clear flag register 1</description>
	<addressOffset>0x00010424</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_CLEAR_E</name>
	<description>Tx meta data per entry: if set to '1' the LMAC hardware has cleared the tx_flag_stat status.
This event bit contributes to ftdf_ce[4]. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_CLEAR_E_2_REG</name>
	<description>Clear flag register 2</description>
	<addressOffset>0x00010444</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_CLEAR_E</name>
	<description>Tx meta data per entry: if set to '1' the LMAC hardware has cleared the tx_flag_stat status.
This event bit contributes to ftdf_ce[4]. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_CLEAR_E_3_REG</name>
	<description>Clear flag register 3</description>
	<addressOffset>0x00010464</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_CLEAR_E</name>
	<description>Tx meta data per entry: if set to '1' the LMAC hardware has cleared the tx_flag_stat status.
This event bit contributes to ftdf_ce[4]. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_CLEAR_M_0_REG</name>
	<description>Mask flag register 0</description>
	<addressOffset>0x00010408</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_CLEAR_M</name>
	<description>Tx meta data per entry: Mask bit for event tx_flag_clear_e.
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_CLEAR_M_1_REG</name>
	<description>Mask flag register 1</description>
	<addressOffset>0x00010428</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_CLEAR_M</name>
	<description>Tx meta data per entry: Mask bit for event tx_flag_clear_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_CLEAR_M_2_REG</name>
	<description>Clear flag register 2</description>
	<addressOffset>0x00010448</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_CLEAR_M</name>
	<description>Tx meta data per entry: Mask bit for event tx_flag_clear_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_CLEAR_M_3_REG</name>
	<description>Clear flag register 3</description>
	<addressOffset>0x00010468</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_CLEAR_M</name>
	<description>Tx meta data per entry: Mask bit for event tx_flag_clear_e
The mask bit is masking when cleared to '0' (default value) and will enable the contribution to the interrupt when set to '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_S_0_REG</name>
	<description>Transmit packet ready for transmission register 0</description>
	<addressOffset>0x00010400</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_STAT</name>
	<description>Tx meta data per entry: if set to '1', the packet is ready for transmission </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_S_1_REG</name>
	<description>Transmit packet ready for transmission register 1</description>
	<addressOffset>0x00010420</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_STAT</name>
	<description>Tx meta data per entry: if set to '1', the packet is ready for transmission </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_S_2_REG</name>
	<description>Transmit packet ready for transmission register 2</description>
	<addressOffset>0x00010440</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_STAT</name>
	<description>Tx meta data per entry: if set to '1', the packet is ready for transmission </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_FLAG_S_3_REG</name>
	<description>Transmit packet ready for transmission register 3</description>
	<addressOffset>0x00010460</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_STAT</name>
	<description>Tx meta data per entry: if set to '1', the packet is ready for transmission </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_META_DATA_0_0_REG</name>
	<description>Transmit metadata register 0</description>
	<addressOffset>0x00000200</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x57ffffff</resetMask>
	<fields>
	<field>
	<name>CRC16_ENA</name>
	<description>Tx meta data per entry: Indicates whether CRC16 insertion must be enabled or not.
0 : No hardware inserted CRC16
1 : Hardware inserts CRC16 </description>
	<access>read-write</access>
	<bitRange>[30:30]</bitRange>
	
</field><field>
	<name>ACKREQUEST</name>
	<description>Tx meta data per entry: '1' indicates that an acknowledge is expected from the recipient of this packet. </description>
	<access>read-write</access>
	<bitRange>[28:28]</bitRange>
	
</field><field>
	<name>CSMACA_ENA</name>
	<description>Tx meta data per entry: '1' indicates that a CSMA-CA is required for the transmission of this packet. </description>
	<access>read-write</access>
	<bitRange>[26:26]</bitRange>
	
</field><field>
	<name>FRAMETYPE</name>
	<description>Tx meta data per entry: the frame type of the data to be transmitted (Data/Cmd/Ack/wakeup frame/etc.). </description>
	<access>read-write</access>
	<bitRange>[25:23]</bitRange>
	
</field><field>
	<name>PHYATTR_HSI</name>
	<description>HighSide injection. </description>
	<access>read-write</access>
	<bitRange>[22:22]</bitRange>
	
</field><field>
	<name>PHYATTR_RF_GPIO_PINS</name>
	<description>Slot-basis signals mapped on GPIO via PPA. </description>
	<access>read-write</access>
	<bitRange>[21:19]</bitRange>
	
</field><field>
	<name>PHYATTR_CALCAP</name>
	<description>CalCap value. </description>
	<access>read-write</access>
	<bitRange>[18:15]</bitRange>
	
</field><field>
	<name>PHYATTR_CN</name>
	<description>Channel Number. </description>
	<access>read-write</access>
	<bitRange>[14:11]</bitRange>
	
</field><field>
	<name>PHYATTR_DEM_PTI</name>
	<description>DEM packet information. </description>
	<access>read-write</access>
	<bitRange>[10:7]</bitRange>
	
</field><field>
	<name>FRAME_LENGTH</name>
	<description>Tx meta data per entry: Frame length (in bytes) </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_META_DATA_0_1_REG</name>
	<description>Transmit metadata register 1</description>
	<addressOffset>0x00000210</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x57ffffff</resetMask>
	<fields>
	<field>
	<name>CRC16_ENA</name>
	<description>Tx meta data per entry: Indicates whether CRC16 insertion must be enabled or not.
0 : No hardware inserted CRC16
1 : Hardware inserts CRC16 </description>
	<access>read-write</access>
	<bitRange>[30:30]</bitRange>
	
</field><field>
	<name>ACKREQUEST</name>
	<description>Tx meta data per entry: '1' indicates that an acknowledge is expected from the recipient of this packet. </description>
	<access>read-write</access>
	<bitRange>[28:28]</bitRange>
	
</field><field>
	<name>CSMACA_ENA</name>
	<description>Tx meta data per entry: '1' indicates that a CSMA-CA is required for the transmission of this packet. </description>
	<access>read-write</access>
	<bitRange>[26:26]</bitRange>
	
</field><field>
	<name>FRAMETYPE</name>
	<description>Tx meta data per entry: the frame type of the data to be transmitted (Data/Cmd/Ack/wakeup frame/etc.). </description>
	<access>read-write</access>
	<bitRange>[25:23]</bitRange>
	
</field><field>
	<name>PHYATTR_HSI</name>
	<description>HighSide injection. </description>
	<access>read-write</access>
	<bitRange>[22:22]</bitRange>
	
</field><field>
	<name>PHYATTR_RF_GPIO_PINS</name>
	<description>Slot-basis signals mapped on GPIO via PPA. </description>
	<access>read-write</access>
	<bitRange>[21:19]</bitRange>
	
</field><field>
	<name>PHYATTR_CALCAP</name>
	<description>CalCap value. </description>
	<access>read-write</access>
	<bitRange>[18:15]</bitRange>
	
</field><field>
	<name>PHYATTR_CN</name>
	<description>Channel Number. </description>
	<access>read-write</access>
	<bitRange>[14:11]</bitRange>
	
</field><field>
	<name>PHYATTR_DEM_PTI</name>
	<description>DEM packet information. </description>
	<access>read-write</access>
	<bitRange>[10:7]</bitRange>
	
</field><field>
	<name>FRAME_LENGTH</name>
	<description>Tx meta data per entry: Frame length (in bytes) </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_META_DATA_0_2_REG</name>
	<description>Transmit metadata register 2</description>
	<addressOffset>0x00000220</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x57ffffff</resetMask>
	<fields>
	<field>
	<name>CRC16_ENA</name>
	<description>Tx meta data per entry: Indicates whether CRC16 insertion must be enabled or not.
0 : No hardware inserted CRC16
1 : Hardware inserts CRC16 </description>
	<access>read-write</access>
	<bitRange>[30:30]</bitRange>
	
</field><field>
	<name>ACKREQUEST</name>
	<description>Tx meta data per entry: '1' indicates that an acknowledge is expected from the recipient of this packet. </description>
	<access>read-write</access>
	<bitRange>[28:28]</bitRange>
	
</field><field>
	<name>CSMACA_ENA</name>
	<description>Tx meta data per entry: '1' indicates that a CSMA-CA is required for the transmission of this packet. </description>
	<access>read-write</access>
	<bitRange>[26:26]</bitRange>
	
</field><field>
	<name>FRAMETYPE</name>
	<description>Tx meta data per entry: the frame type of the data to be transmitted (Data/Cmd/Ack/wakeup frame/etc.). </description>
	<access>read-write</access>
	<bitRange>[25:23]</bitRange>
	
</field><field>
	<name>PHYATTR_HSI</name>
	<description>HighSide injection. </description>
	<access>read-write</access>
	<bitRange>[22:22]</bitRange>
	
</field><field>
	<name>PHYATTR_RF_GPIO_PINS</name>
	<description>Slot-basis signals mapped on GPIO via PPA. </description>
	<access>read-write</access>
	<bitRange>[21:19]</bitRange>
	
</field><field>
	<name>PHYATTR_CALCAP</name>
	<description>CalCap value. </description>
	<access>read-write</access>
	<bitRange>[18:15]</bitRange>
	
</field><field>
	<name>PHYATTR_CN</name>
	<description>Channel Number. </description>
	<access>read-write</access>
	<bitRange>[14:11]</bitRange>
	
</field><field>
	<name>PHYATTR_DEM_PTI</name>
	<description>DEM packet information. </description>
	<access>read-write</access>
	<bitRange>[10:7]</bitRange>
	
</field><field>
	<name>FRAME_LENGTH</name>
	<description>Tx meta data per entry: Frame length (in bytes) </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_META_DATA_0_3_REG</name>
	<description>Transmit metadata register 3</description>
	<addressOffset>0x00000230</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x57ffffff</resetMask>
	<fields>
	<field>
	<name>CRC16_ENA</name>
	<description>Tx meta data per entry: Indicates whether CRC16 insertion must be enabled or not.
0 : No hardware inserted CRC16
1 : Hardware inserts CRC16 </description>
	<access>read-write</access>
	<bitRange>[30:30]</bitRange>
	
</field><field>
	<name>ACKREQUEST</name>
	<description>Tx meta data per entry: '1' indicates that an acknowledge is expected from the recipient of this packet. </description>
	<access>read-write</access>
	<bitRange>[28:28]</bitRange>
	
</field><field>
	<name>CSMACA_ENA</name>
	<description>Tx meta data per entry: '1' indicates that a CSMA-CA is required for the transmission of this packet. </description>
	<access>read-write</access>
	<bitRange>[26:26]</bitRange>
	
</field><field>
	<name>FRAMETYPE</name>
	<description>Tx meta data per entry: the frame type of the data to be transmitted (Data/Cmd/Ack/wakeup frame/etc.). </description>
	<access>read-write</access>
	<bitRange>[25:23]</bitRange>
	
</field><field>
	<name>PHYATTR_HSI</name>
	<description>HighSide injection. </description>
	<access>read-write</access>
	<bitRange>[22:22]</bitRange>
	
</field><field>
	<name>PHYATTR_RF_GPIO_PINS</name>
	<description>Slot-basis signals mapped on GPIO via PPA. </description>
	<access>read-write</access>
	<bitRange>[21:19]</bitRange>
	
</field><field>
	<name>PHYATTR_CALCAP</name>
	<description>CalCap value. </description>
	<access>read-write</access>
	<bitRange>[18:15]</bitRange>
	
</field><field>
	<name>PHYATTR_CN</name>
	<description>Channel Number. </description>
	<access>read-write</access>
	<bitRange>[14:11]</bitRange>
	
</field><field>
	<name>PHYATTR_DEM_PTI</name>
	<description>DEM packet information. </description>
	<access>read-write</access>
	<bitRange>[10:7]</bitRange>
	
</field><field>
	<name>FRAME_LENGTH</name>
	<description>Tx meta data per entry: Frame length (in bytes) </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_META_DATA_1_0_REG</name>
	<description>Transmit metadata register 0</description>
	<addressOffset>0x00000204</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>MACSN</name>
	<description>Tx meta data per entry: Sequence Number of this packet. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_META_DATA_1_1_REG</name>
	<description>Transmit metadata register 1</description>
	<addressOffset>0x00000214</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>MACSN</name>
	<description>Tx meta data per entry: Sequence Number of this packet. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_META_DATA_1_2_REG</name>
	<description>Transmit metadata register 2</description>
	<addressOffset>0x00000224</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>MACSN</name>
	<description>Tx meta data per entry: Sequence Number of this packet. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_META_DATA_1_3_REG</name>
	<description>Transmit metadata register 3</description>
	<addressOffset>0x00000234</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>MACSN</name>
	<description>Tx meta data per entry: Sequence Number of this packet. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_PRIORITY_0_REG</name>
	<description>Transmit priority register 0</description>
	<addressOffset>0x00010410</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000f1f</resetMask>
	<fields>
	<field>
	<name>PTI_TX</name>
	<description>This register has 4 entries, belonging to the entry of the Tx frame to send, to be used during transmitting frames and the CMSA-CA phase before (when requested).
In TSCH mode this register shall be used during the time slot in which frames can be transmitted and consequently an Enhanced ACK can be received.
Since pti_tx belongs to a certain frame to be transmitted, pti_tx can be considered as extra Tx meta data. </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>ISWAKEUP</name>
	<description>Tx meta data per entry: A basic wake-up frame can be generated by the UMAC in the Tx buffer.
The meta data control bit IsWakeUp must be set to indicate that this is a Wake-up frame. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TX_PRIORITY</name>
	<description>Tx meta data per entry: Priority of packet </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_PRIORITY_1_REG</name>
	<description>Transmit priority register 1</description>
	<addressOffset>0x00010430</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000f1f</resetMask>
	<fields>
	<field>
	<name>PTI_TX</name>
	<description>This register has 4 entries, belonging to the entry of the Tx frame to send, to be used during transmitting frames and the CMSA-CA phase before (when requested).
In TSCH mode this register shall be used during the time slot in which frames can be transmitted and consequently an Enhanced ACK can be received.
Since pti_tx belongs to a certain frame to be transmitted, pti_tx can be considered as extra Tx meta data. </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>ISWAKEUP</name>
	<description>Tx meta data per entry: A basic wake-up frame can be generated by the UMAC in the Tx buffer.
The meta data control bit IsWakeUp must be set to indicate that this is a Wake-up frame. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TX_PRIORITY</name>
	<description>Tx meta data per entry: Priority of packet </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_PRIORITY_2_REG</name>
	<description>Transmit priority register 2</description>
	<addressOffset>0x00010450</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000f1f</resetMask>
	<fields>
	<field>
	<name>PTI_TX</name>
	<description>This register has 4 entries, belonging to the entry of the Tx frame to send, to be used during transmitting frames and the CMSA-CA phase before (when requested).
In TSCH mode this register shall be used during the time slot in which frames can be transmitted and consequently an Enhanced ACK can be received.
Since pti_tx belongs to a certain frame to be transmitted, pti_tx can be considered as extra Tx meta data. </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>ISWAKEUP</name>
	<description>Tx meta data per entry: A basic wake-up frame can be generated by the UMAC in the Tx buffer.
The meta data control bit IsWakeUp must be set to indicate that this is a Wake-up frame. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TX_PRIORITY</name>
	<description>Tx meta data per entry: Priority of packet </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_PRIORITY_3_REG</name>
	<description>Transmit priority register 3</description>
	<addressOffset>0x00010470</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000f1f</resetMask>
	<fields>
	<field>
	<name>PTI_TX</name>
	<description>This register has 4 entries, belonging to the entry of the Tx frame to send, to be used during transmitting frames and the CMSA-CA phase before (when requested).
In TSCH mode this register shall be used during the time slot in which frames can be transmitted and consequently an Enhanced ACK can be received.
Since pti_tx belongs to a certain frame to be transmitted, pti_tx can be considered as extra Tx meta data. </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>ISWAKEUP</name>
	<description>Tx meta data per entry: A basic wake-up frame can be generated by the UMAC in the Tx buffer.
The meta data control bit IsWakeUp must be set to indicate that this is a Wake-up frame. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TX_PRIORITY</name>
	<description>Tx meta data per entry: Priority of packet </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_RETURN_STATUS_0_0_REG</name>
	<description>Transmit status register 0</description>
	<addressOffset>0x00000240</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TXTIMESTAMP</name>
	<description>Tx return status per entry: Transmit Timestamp
The Timestamp of the transmitted packet. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_RETURN_STATUS_0_1_REG</name>
	<description>Transmit status register 1</description>
	<addressOffset>0x00000250</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TXTIMESTAMP</name>
	<description>Tx return status per entry: Transmit Timestamp
The Timestamp of the transmitted packet. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_RETURN_STATUS_0_2_REG</name>
	<description>Transmit status register 2</description>
	<addressOffset>0x00000260</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TXTIMESTAMP</name>
	<description>Tx return status per entry: Transmit Timestamp
The Timestamp of the transmitted packet. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_RETURN_STATUS_0_3_REG</name>
	<description>Transmit status register 3</description>
	<addressOffset>0x00000270</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TXTIMESTAMP</name>
	<description>Tx return status per entry: Transmit Timestamp
The Timestamp of the transmitted packet. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_RETURN_STATUS_1_0_REG</name>
	<description>Transmit status register 0</description>
	<addressOffset>0x00000244</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>CSMACANRRETRIES</name>
	<description>Tx return status per entry: Number of CSMA-CA retries before this frame has been transmitted </description>
	<access>read-only</access>
	<bitRange>[4:2]</bitRange>
	
</field><field>
	<name>CSMACAFAIL</name>
	<description>Tx return status per entry: CSMA-CA status
0 : SUCCESS
1 : FAIL </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ACKFAIL</name>
	<description>Tx return status per entry: Acknowledgement status
0 : SUCCESS
1 : FAIL </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_RETURN_STATUS_1_1_REG</name>
	<description>Transmit status register 1</description>
	<addressOffset>0x00000254</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>CSMACANRRETRIES</name>
	<description>Tx return status per entry: Number of CSMA-CA retries before this frame has been transmitted </description>
	<access>read-only</access>
	<bitRange>[4:2]</bitRange>
	
</field><field>
	<name>CSMACAFAIL</name>
	<description>Tx return status per entry: CSMA-CA status
0 : SUCCESS
1 : FAIL </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ACKFAIL</name>
	<description>Tx return status per entry: Acknowledgement status
0 : SUCCESS
1 : FAIL </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_RETURN_STATUS_1_2_REG</name>
	<description>Transmit status register 2</description>
	<addressOffset>0x00000264</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>CSMACANRRETRIES</name>
	<description>Tx return status per entry: Number of CSMA-CA retries before this frame has been transmitted </description>
	<access>read-only</access>
	<bitRange>[4:2]</bitRange>
	
</field><field>
	<name>CSMACAFAIL</name>
	<description>Tx return status per entry: CSMA-CA status
0 : SUCCESS
1 : FAIL </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ACKFAIL</name>
	<description>Tx return status per entry: Acknowledgement status
0 : SUCCESS
1 : FAIL </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_RETURN_STATUS_1_3_REG</name>
	<description>Transmit status register 3</description>
	<addressOffset>0x00000274</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>CSMACANRRETRIES</name>
	<description>Tx return status per entry: Number of CSMA-CA retries before this frame has been transmitted </description>
	<access>read-only</access>
	<bitRange>[4:2]</bitRange>
	
</field><field>
	<name>CSMACAFAIL</name>
	<description>Tx return status per entry: CSMA-CA status
0 : SUCCESS
1 : FAIL </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ACKFAIL</name>
	<description>Tx return status per entry: Acknowledgement status
0 : SUCCESS
1 : FAIL </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_TX_SET_OS_REG</name>
	<description>One shot register to set flag</description>
	<addressOffset>0x00010480</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>TX_FLAG_SET</name>
	<description>Tx meta data per entry: if set to '1', the tx_flag_stat will be set to '1'. </description>
	<access>write-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_WAKEUP_CONTROL_OS_REG</name>
	
	<addressOffset>0x00010364</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>WAKEUPTIMERENABLE_CLEAR</name>
	<description>If set, WakeupTimerEnableStatus will be cleared. </description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>WAKEUPTIMERENABLE_SET</name>
	<description>If set, WakeupTimerEnableStatus will be set. </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>FTDF_WAKEUP_CONTROL_REG</name>
	<description>Wakeup timer vcontrol register</description>
	<addressOffset>0x00011000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x40000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>WAKEUP_MODE</name>
	<description>The Control register WakeUp_mode controls the behavior of the Event counter:
0d = off, 1d = free running (default), 2d = one shot with auto clear, 3d = configurable period (timer
mode). </description>
	<access>read-write</access>
	<bitRange>[31:30]</bitRange>
	
</field><field>
	<name>WAKEUPENABLE</name>
	<description>If set to '1', the WakeUpIntThr is enabled to generate an WAKEUP_IRQ interrupt. </description>
	<access>read-write</access>
	<bitRange>[29:29]</bitRange>
	
</field><field>
	<name>WAKEUPINTTHR</name>
	<description>Threshold for wake-up interrupt. When WakeUpEnable is set to '1' and the Wake-up (event) counter matches this value, the interrupt WAKEUP_IRQ is set to '1' for the duration of one LP_CLK period. </description>
	<access>read-write</access>
	<bitRange>[24:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GP_TIMERS</name>
	<version>1.0</version>
	<description>GP_TIMERS registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003400</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>32</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>BREATH_CFG_REG</name>
	<description>Breath configuration register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>BRTH_STEP</name>
	<description>Defines the number of PWM periods minus 1, in which duty cycle will be constant</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>BRTH_DIV</name>
	<description>Defines the breath PWM frequecny. Breath PWM frequency is 16MHz / (BRTH_DIV+1)</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BREATH_CTRL_REG</name>
	<description>Breath control register</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>BRTH_PWM_POL</name>
	<description>Defines the output polarity. '0' line is low in idle state. '1' line is high in idle state.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>BRTH_EN</name>
	<description>'1' enable the Breath operation</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BREATH_DUTY_MAX_REG</name>
	<description>Breath max duty cycle register</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000a</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>BRTH_DUTY_MAX</name>
	<description>Defines the maximum duty cycle of the PWM breath function. Max duty cycle = BRTH_DUTY_MAX / (BRTH_DIV+1)</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>BREATH_DUTY_MIN_REG</name>
	<description>Breath min duty cycle register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>BRTH_DUTY_MIN</name>
	<description>Defines the minimum duty cycle of the PWM breath function. Min duty cycle = BRTH_DUTY_MIN / (BRTH_DIV+1)</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PWM2_END_CYCLE</name>
	<description>Defines end Cycle for PWM2</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PWM2_START_CYCLE</name>
	<description>Defines start Cycle for PWM2</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PWM3_END_CYCLE</name>
	<description>Defines end Cycle for PWM3</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PWM3_START_CYCLE</name>
	<description>Defines start Cycle for PWM3</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PWM4_END_CYCLE</name>
	<description>Defines end Cycle for PWM4</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>END_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes low. If end_cycle is larger then freq and start_cycle is not larger then freq, output is always 1</description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PWM4_START_CYCLE</name>
	<description>Defines start Cycle for PWM4</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>START_CYCLE</name>
	<description>Defines the cycle in which the PWM becomes high. if start_cycle is larger than freq or end_cycle is equal to start_cycle, pwm out is always 0</description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TIMER0_CTRL_REG</name>
	<description>Timer0 control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PWM_MODE</name>
	<description>'0' = PWM signals are '1' during high time.
'1' = PWM signals send out the (fast) clock divided by 2 during high time. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>TIM0_CLK_DIV</name>
	<description>'1' = Timer0 uses selected clock frequency as is.
'0' = Timer0 uses selected clock frequency divided by 10.
Note that this applies only to the ON-counter.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>TIM0_CLK_SEL</name>
	<description>'1' = Timer0 uses fast clock frequency.
'0' = Timer0 uses 32 kHz (slow) clock frequency. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>TIM0_CTRL</name>
	<description>'0' = Timer0 is off and in reset state.
'1' = Timer0 is running. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TIMER0_ON_REG</name>
	<description>Timer0 on control register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>TIM0_ON</name>
	<description>Timer0 On reload value.
If read the actual counter value ON_CNTer is returned </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TIMER0_RELOAD_M_REG</name>
	<description>16 bits reload value for Timer0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>TIM0_M</name>
	<description>Timer0 'high' reload value.
If read the actual counter value T0_CNTer is returned </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TIMER0_RELOAD_N_REG</name>
	<description>16 bits reload value for Timer0</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>TIM0_N</name>
	<description>Timer0 'low' reload value.
If read the actual counter value T0_CNTer is returned </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TRIPLE_PWM_CTRL_REG</name>
	<description>PWM 2 3 4 Control register</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000c</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>TRIPLE_PWM_CLK_SEL</name>
	<description>'1' = Triple PWM uses fast clock frequency.
'0' = Triple PWM uses 32 Khz (slow) clock frequency</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>HW_PAUSE_EN</name>
	<description>'1' = HW can pause PWM 2,3,4 and BREATH timer</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SW_PAUSE_EN</name>
	<description>'1' = PWM 2 3 4 and BREATH timer (if applicable) are paused </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>TRIPLE_PWM_ENABLE</name>
	<description>'1' = PWM 2 3 4 is enabled </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TRIPLE_PWM_FREQUENCY</name>
	<description>Defines the PMW2,3,4 frequency</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>FREQ</name>
	<description>Defines the frequency of PWM 2 3 4, period = TMR2_CLK * ( FREQ+1)</description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPADC</name>
	<version>1.0</version>
	<description>GPADC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001900</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>14</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>GP_ADC_CLEAR_INT_REG</name>
	<description>General Purpose ADC Clear Interrupt Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GP_ADC_CLR_INT</name>
	<description>Writing any value to this register will clear the ADC_INT interrupt. Reading returns 0. </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>GP_ADC_CTRL2_REG</name>
	<description>General Purpose ADC Second Control Register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GP_ADC_STORE_DEL</name>
	<description>0: Data is stored after handshake synchronisation
1: Data is stored two ADC_CLK cycles after internal start trigger
15: Data is stored sixteen ADC_CLK cycles after internal start trigger</description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>GP_ADC_SMPL_TIME</name>
	<description>0: The sample time (switch is closed) is one ADC_CLK cycle
1: The sample time is 1*32 ADC_CLK cycles
2: The sample time is 2*32 ADC_CLK cycles
15: The sample time is 15*32 ADC_CLK cycles</description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>GP_ADC_CONV_NRS</name>
	<description>0: 1 sample is taken or 2 in case ADC_CHOP is active.
1: 2 samples are taken.
2: 4 samples are taken.
7: 128 samples are taken.</description>
	<access>read-write</access>
	<bitRange>[7:5]</bitRange>
	
</field><field>
	<name>GP_ADC_DMA_EN</name>
	<description>0: DMA functionality disabled
1: DMA functionality enabled</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>GP_ADC_I20U</name>
	<description>1: Adds 20uA constant load current at the ADC LDO to minimize ripple on the reference voltage of the ADC.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>GP_ADC_IDYN</name>
	<description>1: Enables dynamic load current at the ADC LDO to minimize ripple on the reference voltage of the ADC.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>GP_ADC_ATTN3X</name>
	<description>0: Input voltages up to 1.2V allowed.
1: Input voltages up to 3.6V allowed by enabling 3x attenuator. (if ADC_SEL=7 or 8, this bit is automatically set to 1) Enabling the attenuator requires a longer sampling time.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>GP_ADC_CTRL3_REG</name>
	<description>General Purpose ADC Third Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GP_ADC_INTERVAL</name>
	<description>Defines the interval between two ADC conversions in case GP_ADC_CONT is set.
0: No extra delay between two conversions.
1: 1.024ms interval between two conversions.
2: 2.048ms interval between two conversions.
255: 261.12ms interval between two conversions.</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>GP_ADC_EN_DEL</name>
	<description>Defines the delay for enabling the ADC after enabling the LDO.
0: Not allowed
1: 32x ADC_CLK period.
n: n*32x ADC_CLK period.</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>GP_ADC_CTRL_REG</name>
	<description>General Purpose ADC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GP_ADC_LDO_ZERO</name>
	<description>1: Samples and disconnects VREF, should be refreshed frequently. Note that the LDO consumpes power when bit is set.</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>GP_ADC_CHOP</name>
	<description>0: Chopper mode off
1: Chopper mode enabled. Takes two samples with opposite GP_ADC_SIGN to cancel the internal offset voltage of the ADC; Highly recommended for DC-measurements.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>GP_ADC_SIGN</name>
	<description>0: Default
1: Conversion with opposite sign at input and output to cancel out the internal offset of the ADC and low-frequency</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>GP_ADC_SEL</name>
	<description>ADC input selection.
If GP_ADC_SE = 1 (single ended mode):
0: P1[2]
1: P1[4]
2: P1[3]
3: P0[7]
4: AVS
5: Internal VDD_REF (used for offset calibration)
6: VDCDC (see DCDC_TEST_0_REG.DCDC_OUTPUT_MONITOR for more information; GP_ADC_ATTN3X scaler automatically selected)
7: V33 (GP_ADC_ATTN3X scaler automatically selected)
8: V33 (GP_ADC_ATTN3X scaler automatically selected)
9: VBAT (5V to 1.2V scaler selected)
16: P0[6]
17: P1[0]
18: P1[5]
19: P2[4]
All other combinations are reserved.
If GP_ADC_SE = 0 (differential mode):
0: P1[2] vs P1[4]
All other combinations are P1[3] vs P0[7].</description>
	<access>read-write</access>
	<bitRange>[12:8]</bitRange>
	
</field><field>
	<name>GP_ADC_MUTE</name>
	<description>0: Normal operation
1: Mute ADC input. Takes sample at mid-scale (to dertermine the internal offset and/or noise of the ADC with regards to VDD_REF which is also sampled by the ADC).</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>GP_ADC_SE</name>
	<description>0: Differential mode
1: Single ended mode</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>GP_ADC_MINT</name>
	<description>0: Disable (mask) GP_ADC_INT.
1: Enable GP_ADC_INT to ICU.</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>GP_ADC_INT</name>
	<description>1: AD conversion ready and has generated an interrupt. Must be cleared by writing any value to GP_ADC_CLEAR_INT_REG.</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>GP_ADC_CLK_SEL</name>
	<description>0: Internal high-speed ADC clock used (recommended).
1: Digital clock used (ADC_CLK).</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>GP_ADC_CONT</name>
	<description>0: Manual ADC mode, a single result will be generated after setting the GP_ADC_START bit.
1: Continuous ADC mode, new ADC results will be constantly stored in GP_ADC_RESULT_REG. Still GP_ADC_START has to be set to start the execution. The time between conversions is configurable with GP_ADC_INTERVAL.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>GP_ADC_START</name>
	<description>0: ADC conversion ready.
1: If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the GP_ADC_INT bit will be set. It is not allowed to write this bit while it is not (yet) zero.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>GP_ADC_EN</name>
	<description>0: LDO is off and ADC is disabled..
1: LDO is turned on and afterwards the ADC is enabled.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>GP_ADC_OFFN_REG</name>
	<description>General Purpose ADC Negative Offset Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GP_ADC_OFFN</name>
	<description>Offset adjust of 'negative' array of ADC-network (effective if "GP_ADC_SE=0", or "GP_ADC_SE=1 AND GP_ADC_SIGN=1")</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>GP_ADC_OFFP_REG</name>
	<description>General Purpose ADC Positive Offset Register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GP_ADC_OFFP</name>
	<description>Offset adjust of 'positive' array of ADC-network (effective if "GP_ADC_SE=0", or "GP_ADC_SE=1 AND GP_ADC_SIGN=0")</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>GP_ADC_RESULT_REG</name>
	<description>General Purpose ADC Result Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GP_ADC_VAL</name>
	<description>Returns the 10 up to 16 bits linear value of the last AD conversion. The upper 10 bits are always valid, the lower 6 bits are only valid in case oversampling has been applied. Two samples results in one extra bit and 64 samples results in six extra bits.</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPIO</name>
	<version>1.0</version>
	<description>GPIO registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>250</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>BIST_CTRL_REG</name>
	
	<addressOffset>0x000000e0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SHOW_BIST</name>
	<description>Read version of bist status </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>SYSRAMBIST_ENABLE</name>
	<description>Read version of bist status </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>RAMBIST_ENABLE</name>
	<description>Enable the RAM bists </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>ROMBIST_ENABLE</name>
	<description>Enable the ROM bist </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RAM_BIST_PATTERN</name>
	<description>Pattern to use for the BIST tests:
00 = Use 0x5555 as test data
01 = Use 0x5A5A as test data
10 = Use 0x0000 as test data
11 = Use 0x0F0F as test data </description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>RAM_BIST_CONFIG</name>
	<description>Bist configuration for RAMBIST:
00 = Perform all 8 phases
01 = Perform only phase 1
10 = Perform only phase 3 and 4
11 = Perform only phase 6
Bist configuration for ROMBIST (from ES2):
00 = Perform all 2 phases
01 = Perform only phase 1
10 = Perform only phase 2
11 = Reserved</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>GPIO_CLK_SEL</name>
	<description>Select which clock to map on port in PPA</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>FUNC_CLOCK_SEL</name>
	<description>Select which clock to map when PID = FUNC_CLOCK.
0x0: XTAL32K
0x1: RC32K
0x2: RCX
0x3: XTAL16M
0x4: RC16M
0x5: DIVN
0x6: Reserved
0x7: Reserved</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P00_MODE_REG</name>
	<description>P00 Mode Register</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>Function of port
0: GPIO, PUPD see above
1: UART_RX
2: UART_TX
3: UART_IRDA_RX
4: UART_IRDA_TX
5: UART2_RX
6: UART2_TX
7: UART2_IRDA_RX
8: UART2_IRDA_TX
9: UART2_CTSN
10: UART2_RTSN
11: SPI_DI
12: SPI_DO
13: SPI_CLK14: SPI_EN
15: SPI2_DI
16: SPI2_DO
17: SPI2_CLK
18: SPI2_EN
19: I2C_SCL
20: I2C_SDA
21: I2C2_SCL
22: I2C2_SDA
23: PWM0
24: PWM1
25: PWM2
26: PWM3
27: PWM4
28: BLE_DIAG (ble_diag_0: pins P2_0 and P3_0, ble_diag_1: pins P2_1 and P3_1, ble_diag_2: pins P2_2 and P3_2, ble_diag_3: pins P1_0 and P3_3, ble_diag_4: pins P1_1 and P3_4, ble_diag_5: pins P1_2 and P3_5, ble_diag_6: pins P1_3 and P3_6, ble_diag_7: pins P2_3 and P3_7)
29: FTDF_DIAG (ftdf_diag_0: pins P1_4 and P4_0, ftdf_diag_1: pins P1_5 and P4_1, ftdf_diag_2: pins P1_6 and P4_2, ftdf_diag_3: pins P1_7 and P4_3, ftdf_diag_4: pins P0_6 and P4_4, ftdf_diag_5: pins P0_7 and P4_5, ftdf_diag_6: pins P1_3 and P4_6, ftdf_diag_7: pins P2_3 and P4_7)
30: PCM_DI
31: PCM_DO
32: PCM_FSC
33: PCM_CLK
34: PDM_DI
35: PDM_DO
36: PDM_CLK
37: USB_SOF
38: ADC (only for P0[7:6], P1[5:2,0] and P2[4])
38: USB (only for P2[2] and P1[1])
38: XTAL32 (only for P2[1:0])
39: QD_CHA_X
40: QD_CHB_X
41: QD_CHA_Y
42: QD_CHB_Y
43: QD_CHA_Z
44: QD_CHB_Z
45: IR_OUT
46: BREATH
47: KB_ROW
48: COEX_EXT_ACT0
49: COEX_EXT_ACT1
50: COEX_SMART_ACT
51: COEX_SMART_PRI
52: CLOCK
53: ONESHOT
54: PWM5
55: PORT0_DCF
56: PORT1_DCF
57: PORT2_DCF
58: PORT3_DCF
59: PORT4_DCF
60: RF_ANT_TRIM[0]
61: RF_ANT_TRIM[1]
62: RF_ANT_TRIM[2]
63: Reserved</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P01_MODE_REG</name>
	<description>P01 Mode Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P02_MODE_REG</name>
	<description>P02 Mode Register</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P03_MODE_REG</name>
	<description>P03 Mode Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P04_MODE_REG</name>
	<description>P04 Mode Register</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P05_MODE_REG</name>
	<description>P05 Mode Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P06_MODE_REG</name>
	<description>P06 Mode Register</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P07_MODE_REG</name>
	<description>P07 Mode Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P0_DATA_REG</name>
	<description>P0 Data input / output Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P0_DATA</name>
	<description>Set P0 output register when written; Returns the value of P0 port when read </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P0_PADPWR_CTRL_REG</name>
	<description>P0 Output Power Control Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P0_OUT_CTRL</name>
	<description>1 = P0_x port output is powered by VDD1V8P rail
0 = P0_x port output is powered by V33 rail
bit 6 controls the power supply of P0[6],
bit 7 controls the power supply of P0[7]</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field></fields>
</register><register>
	<name>P0_RESET_DATA_REG</name>
	<description>P0 Reset port pins Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P0_RESET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P0_SET_DATA_REG</name>
	<description>P0 Set port pins Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P0_SET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P10_MODE_REG</name>
	<description>P10 Mode Register</description>
	<addressOffset>0x0000002e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P11_MODE_REG</name>
	<description>P11 Mode Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P12_MODE_REG</name>
	<description>P12 Mode Register</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P13_MODE_REG</name>
	<description>P13 Mode Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P14_MODE_REG</name>
	<description>P14 Mode Register</description>
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P15_MODE_REG</name>
	<description>P15 Mode Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P16_MODE_REG</name>
	<description>P24 Mode Register</description>
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P17_MODE_REG</name>
	<description>P25 Mode Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P1_DATA_REG</name>
	<description>P1 Data input / output Register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P1_DATA</name>
	<description>Set P1 output register when written; Returns the value of P1 port when read </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P1_PADPWR_CTRL_REG</name>
	<description>P1 Output Power Control Register</description>
	<addressOffset>0x000000c2</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P1_OUT_CTRL</name>
	<description>1 = P1_x port output is powered by VDD1V8P rail
0 = P1_x port output is powered by V33 rail
bit x controls the power supply of P1[x]</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P1_RESET_DATA_REG</name>
	<description>P1 Reset port pins Register</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P1_RESET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P1_SET_DATA_REG</name>
	<description>P1 Set port pins Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P1_SET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P20_MODE_REG</name>
	<description>P20 Mode Register</description>
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P21_MODE_REG</name>
	<description>P21 Mode Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P22_MODE_REG</name>
	<description>P22 Mode Register</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P23_MODE_REG</name>
	<description>P23 Mode Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P24_MODE_REG</name>
	<description>P24 Mode Register</description>
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P2_DATA_REG</name>
	<description>P2 Data input / output Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P2_DATA</name>
	<description>Set P2 output register when written; Returns the value of P2 port when read </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P2_PADPWR_CTRL_REG</name>
	<description>P2 Output Power Control Register</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P2_OUT_CTRL</name>
	<description>1 = P2_x port output is powered by VDD1V8P rail
0 = P2_x port output is powered by V33 rail
bit x controls the power supply of P2[x]</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P2_RESET_DATA_REG</name>
	<description>P2 Reset port pins Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P2_RESET</name>
	<description>Writing a 1 to P2[y] sets P2[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<access>write-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P2_SET_DATA_REG</name>
	<description>P2 Set port pins Register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P2_SET</name>
	<description>Writing a 1 to P2[y] sets P2[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<access>write-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P30_MODE_REG</name>
	<description>P30 Mode Register</description>
	<addressOffset>0x0000004e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P31_MODE_REG</name>
	<description>P31 Mode Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P32_MODE_REG</name>
	<description>P32 Mode Register</description>
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P33_MODE_REG</name>
	<description>P33 Mode Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P34_MODE_REG</name>
	<description>P34 Mode Register</description>
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P35_MODE_REG</name>
	<description>P35 Mode Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P36_MODE_REG</name>
	<description>P36 Mode Register</description>
	<addressOffset>0x0000005a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P37_MODE_REG</name>
	<description>P37 Mode Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P3_DATA_REG</name>
	<description>P3 Data input / output Register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P3_DATA</name>
	<description>Set P3 output register when written; Returns the value of P3 port when read </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P3_PADPWR_CTRL_REG</name>
	<description>P3 Output Power Control Register</description>
	<addressOffset>0x000000c6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P3_OUT_CTRL</name>
	<description>1 = P3_x port output is powered by VDD1V8P rail
0 = P3_x port output is powered by V33 rail
bit x controls the power supply of P3[x]</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P3_RESET_DATA_REG</name>
	<description>P3 Reset port pins Register</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P3_RESET</name>
	<description>Writing a 1 to P3[y] sets P3[y] to 0. Writing 0 is discarded;
Reading returns 0</description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P3_SET_DATA_REG</name>
	<description>P3 Set port pins Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P3_SET</name>
	<description>Writing a 1 to P3[y] sets P3[y] to 1. Writing 0 is discarded; Reading returns 0</description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P40_MODE_REG</name>
	<description>P40 Mode Register</description>
	<addressOffset>0x0000005e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P41_MODE_REG</name>
	<description>P41 Mode Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P42_MODE_REG</name>
	<description>P42 Mode Register</description>
	<addressOffset>0x00000062</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P43_MODE_REG</name>
	<description>P43 Mode Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P44_MODE_REG</name>
	<description>P44 Mode Register</description>
	<addressOffset>0x00000066</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P45_MODE_REG</name>
	<description>P45 Mode Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P46_MODE_REG</name>
	<description>P46 Mode Register</description>
	<addressOffset>0x0000006a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P47_MODE_REG</name>
	<description>P47 Mode Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>PID</name>
	<description>See P00_MODE_REG[PID] </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P4_DATA_REG</name>
	<description>P4 Data input / output Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P4_DATA</name>
	<description>Set P4 output register when written; Returns the value of P4 port when read </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P4_PADPWR_CTRL_REG</name>
	<description>P4 Output Power Control Register</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P4_OUT_CTRL</name>
	<description>1 = P4_x port output is powered by VDD1V8P rail
0 = P4_x port output is powered by V33 rail
bit x controls the power supply of P4[x]</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P4_RESET_DATA_REG</name>
	<description>P4 Reset port pins Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P4_RESET</name>
	<description>Writing a 1 to P4[y] sets P4[y] to 0. Writing 0 is discarded;
Reading returns 0</description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>P4_SET_DATA_REG</name>
	<description>P4 Set port pins Register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>P4_SET</name>
	<description>Writing a 1 to P4[y] sets P4[y] to 1. Writing 0 is discarded; Reading returns 0</description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RAMBIST_STATUS1_REG</name>
	
	<addressOffset>0x000000e2</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000036db</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ROM_BIST_BUSY</name>
	<description>status of internal signal "busy" of rom bist </description>
	<access>read-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>QSPIRAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of qspiram bist </description>
	<access>read-only</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>QSPIRAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of qspiram bist </description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>QSPIRAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of qspiram bist </description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>USBRAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of usbram bist </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>USBRAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of usbram bist </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>USBRAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of usbram bist </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>CDRAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of cdram bist </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>CDRAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of cdram bist </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>CDRAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of cdram bist </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>CTRAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of ctram bist </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>CTRAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of ctram bist </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>CTRAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of ctram bist </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SYSRAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of sysram bist </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SYSRAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of sysram bist </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SYSRAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of sysram bist </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RAMBIST_STATUS2_REG</name>
	
	<addressOffset>0x000000e4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000036db</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CRYPTORAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of cryptoram bist </description>
	<access>read-only</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>CRYPTORAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of cryptoram bist </description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>CRYPTORAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of cryptoram bist </description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>ECC_TCMRAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of ecc_tcmram bist </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>ECC_TCMRAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of ecc_tcmram bist </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>ECC_TCMRAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of ecc_tcmram bist </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>ECC_CODERAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of ecc_coderam bist </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>ECC_CODERAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of ecc_coderam bist </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>ECC_CODERAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of ecc_coderam bist </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>FTDF_RXRAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of ftdf_rxram bist </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>FTDF_RXRAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of ftdf_rxram bist </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>FTDF_RXRAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of ftdf_rxram bist </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>FTDF_TXRAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of ftdf_txram bist </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>FTDF_TXRAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of ftdf_txram bist </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>FTDF_TXRAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail" of ftdf_txram bist </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RAMBIST_STATUS3_REG</name>
	
	<addressOffset>0x000000e6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>FTDF_FPRAM_BIST_BUSY</name>
	<description>status of internal signal "busy" of ftdf_fpram bist</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>FTDF_FPRAM_BIST_FAIL</name>
	<description>status of internal signal "fail" of ftdf_fpram bist</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>FTDF_FPRAM_BIST_LINE_FAIL</name>
	<description>status of internal signal "line_fail"of ftdf_fpram bist</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>ROMBIST_RESULTH_REG</name>
	
	<addressOffset>0x000000ea</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ROMBIST_RESULTH</name>
	<description>Read version of bist status, result[31:16] </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>ROMBIST_RESULTL_REG</name>
	
	<addressOffset>0x000000e8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ROMBIST_RESULTL</name>
	<description>Read version of bist status, result[15:0] </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TEST_CTRL2_REG</name>
	
	<addressOffset>0x000000f2</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RF_IN_TESTMUX_CTRL</name>
	<description>Connect the RF input testbus to pins:
Switch 1 (bit 8) connects T0 of the radio test input bus to P0[7]
Switch 2 (bit 9) connects T1 of the radio test input bus to P1[3]
If this bit is 0, the switch is open (not conducting).</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>ANA_TESTMUX_CTRL</name>
	<description>Control of analog test bus switches:
Switch 1 connects T0 of the radio test output bus to P1[7]
Switch 2 connects T1 of the radio test output bus to P1[4]
Switch 3 connects T0 of the analog test output bus to P1[7]
Switch 4 connects T1 of the analog test output bus to P1[4]

0: all switches open
1: only switch 1 closed
2: only switch 2 closed
3: only switch 3 closed
4: only switch 4 closed
5: switches 1 &amp; 2 closed
6: switches 1 &amp; 4 closed
7: switches 2 &amp; 3 closed
8: switches 3 &amp; 4 closed </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TEST_CTRL3_REG</name>
	
	<addressOffset>0x000000f4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RF_TEST_OUT_PARAM</name>
	<description>Select which test will be enabled on the block selected by the RF output testbus (see </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>VBUS_COMPARATOR_TEST</name>
	<description>Control for the testability of VBUS input on V33 comparator</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>RF_TEST_OUT_SEL</name>
	<description>Select a radio block to have its testbus connected to P1[1] and P1[2]. See
Table 7
for more information.
NOTE: all 0 represent no testmode and the testbusses are shorted to ground to prevent floating busses. </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TEST_CTRL4_REG</name>
	
	<addressOffset>0x000000f6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RF_TEST_IN_PARAM</name>
	<description>Select which test will be enabled on the block selected by the RF output testbus (see </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>RF_TEST_IN_SEL</name>
	<description>Select an RF block to have its test input connected to the input testbus at pins P0[0] and P0[3]. NOTE: all 0 represent no testmode and the testbusses are shorted to ground to prevent floating busses. </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TEST_CTRL5_REG</name>
	
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>TEST_POR_VBAT_NOK_AVD</name>
	
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>TEST_VREF_1V2_A</name>
	
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>TEST_VCONT_A</name>
	
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>TEST_I_DCDC_FILT</name>
	
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TEST_BOD_VREF_IN</name>
	
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>TEST_BOD_VREF_OUT</name>
	
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>TEST_SIMO_BUCK</name>
	
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>TEST_BANDGAP_I_TEST</name>
	
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>TEST_LDO_PLL</name>
	
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>TEST_LDO_ADC</name>
	
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>TEST_LDO_1V8_PA</name>
	
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TEST_LDO_CORE</name>
	
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>TEST_LDO_1V8_FLASH</name>
	
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>TEST_LDO_1V4</name>
	
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>TEST_BUS_TO_AVS</name>
	
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TEST_CTRL_REG</name>
	
	<addressOffset>0x000000f0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>XTAL16M_TRIM_TEST_EN</name>
	<description>0: normal port function, 1: shows xtal16m_trim_sw1_isolated to pin P15 and xtal16m_trim_sw2_isolated to pin P16</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>XTAL16M_TST_SYS</name>
	<description>xtal16m_tst_sys[0]:
'0': Normal operation, '1': Disables the current in the main oscillator stage. Suggested to set it to '1' only when measuring the varicap.
xtal16m_tst_sys[1]:
'0 ': Normal operation, '1': Amplifies by 10 the current passing through a resistor series of the XTAL, compared to the case where this bit is '0'.
The voltage over this resistor series is set to the testbus and it can be measured either on a pin or by the ADC. The resistance value
of this resistor series is determined by CLK_16M_REG.XTAL16_CUR_SET.</description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>SHOW_PWR_TST_OUT</name>
	<description>0: Normal operation
1: P1[7:1] = ldo_1v8_flash_ret_enable, ldo_supply_vbat_ok, ldo_supply_usb_ok, ldo_1v8_pa_ret_enable, bandgap_bgr_ok, 0, ldo_vbat_ret_enable
2: P1[7:1] = ldo_vbat_ret_vref_hold, ldo_core_ok, pll_status_reg_isolated_1, ldo_radio_ok,ldo_1v8_pa_ok, ldo_1v8_flash_ok, ldo_supply_usb_enable
3: P1[7:1] = ldo_1v8_flash_ret_vref_hold, vbus_available, newbat, clear_newbat, ldo_1v8_pa_ret_vref_hold, 0, power_on_reset
4: P1[7:1] = comp_v18_pa_high, comp_v18_flash_high, comp_vdd_high, comp_vbus_low, comp_vbus_high, comp_v33_high, comp_vbat_ok
5: P1[7:1] = charge_gate_enable, bod_v18_pa_low, bod_v33_low, bod_v18_flash_low, bod_vdd_low, bod_vbat_low, bod_clk
</description>
	<access>read-write</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>SHOW_TXDAC_MOD</name>
	<description>0: Normal operation
1: show the TxDAC_MOD bus on P1[6:4]</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>PLL_TST_MODE</name>
	<description>0: Normal operation
1: Show the PLL test mode signals:
P07 = RCLK
P16 = NCLK
P13 = CP_UP
P11 = CP_DOWN
Notes:
- The control signal should go to the radio to enable this test mode. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>SHOW_IF_RO</name>
	<description>0: Normal Port function.
1: Show IF filter Reference Oscillator I and Q signals.
P10 = iff_ro_out_i
P06 = iff_ro_out_q </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>XTAL16M_CAP_TEST_EN</name>
	<description>0: Normal Port function.
1: Show xtal16m_cap_test_outoutput P1[1:0]
Notes:
- The control signal should go to the radio to enable this test mode.
- This register should be zero during scan test! </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>SHOW_DCDC_TESTBUS</name>
	<description>0: normal port function
1: map the DCDC testbus [11:0] on the following GPIO's (MSB first): P23,P21,P20,P1[7:0],P07</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SHOW_PLL_TEST_OUT</name>
	<description>0: normal port function
1: map pll_out_div_test_out on P06 and pll_loop_div_test_out on P10</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>ENABLE_RFPT</name>
	<description>0: normal port function
1: enable the RF Production Test Unit. Used to store RX ADC samples or PLL TDC samples in SRAM.
See RFPT_CTRL_REG, RFPT_ADDR_REG and RFPT_LEN_REG for details. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SHOW_CLOCKS</name>
	<description>0: normal port function
1: show DIVN clock on P10
</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPREG</name>
	<version>1.0</version>
	<description>GPREG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003300</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>26</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>BLE_FINECNT_SAMP_REG</name>
	<description>BLE FINECNT sampled value while in deep sleep state.</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>BLE_FINECNT_SAMP</name>
	<description>This register is located at the Always On Power Domain and it holds the automatically sampled value of the BLE FINECNT timer
The HW automatically samples the value into this register during the sequence of "BLE Sleep On" and restores automatically the value during the BLE Wake up sequence.
The Software may read and modify the value while the BLE is in Sleep state. While the BLE is awake, the value of the register has no meaning, while changing the value by writing another one will have no effect in the operation of the BLE core.</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>DEBUG_REG</name>
	<description>Various debug information register.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>DEBUGS_FREEZE_EN</name>
	<description>Default '1', freezing of the on-chip timers is enabled when the Cortex-M0 is halted in DEBUG State.
If '0', freezing of the on-chip timers is depending on FREEZE_REG when the Cortex-M0 is halted in DEBUG State except the watchdog timer. The watchdog timer is always frozen when the Cortex-M0 is halted in DEBUG State.
Note: This bit is retained.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>ECC_BASE_ADDR_REG</name>
	<description>Base address of the ECC Crypto memory register.</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ECC_BASE_ADDR</name>
	<description>Contains the base address of the ECC Crypto memory.
Memory allocation is in pages of 1KB and up to 127KB.
Since the ECC has an address range of 2KB and the total addressable memory range is 128KB, the maximum value of 0x7F (127KB offset) will result in 1KB at the top of the memory range and the other 1KB at the bottom of the memory range.</description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>GP_CONTROL_REG</name>
	<description>General purpose system control register.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>BLE_WAKEUP_LP_IRQ</name>
	<description>The current value of the BLE_WAKEUP_LP_IRQ interrupt request.</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>BLE_H2H_BRIDGE_BYPASS</name>
	<description>If '1', the AHB-to-AHB bridge is bypassed, needed to access the BLE Register file, only when the system clock source is the XTAL and both hclk and ble_hclk are running at 16MHz, i.e. at the XTAL clock rate.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>BLE_WAKEUP_REQ</name>
	<description>If '1', the BLE wakes up. Must be kept high at least for 1 low power clock period. 
If the BLE is in deep sleep state, then by setting this bit it will cause the wakeup LP IRQ to be asserted with a delay of 3 to 4 low power cycles.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>GP_STATUS_REG</name>
	<description>General purpose system status register.</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAL_PHASE</name>
	<description>If '1', it designates that the chip is in Calibration Phase i.e. the OTP has been initially programmed but no Calibration has occured. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>LED_CONTROL_REG</name>
	<description>Controls muxing and enabling of the LEDs.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LED_TRIM</name>
	<description>LED current trimming bits.</description>
	<access>read-write</access>
	<bitRange>[9:6]</bitRange>
	
</field><field>
	<name>LED3_EN</name>
	<description>0: LED3 disabled,
1: LED3 enabled.</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>LED2_EN</name>
	<description>0: LED2 disabled,
1: LED2 enabled.</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>LED1_EN</name>
	<description>0: LED1 disabled,
1: LED1 enabled.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>LED3_SRC_SEL</name>
	<description>0: LED3 = PWM4,
1: LED3 = Breathing Timer.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>LED2_SRC_SEL</name>
	<description>0: LED2 = PWM3,
1: LED2 = Breathing Timer.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>LED1_SRC_SEL</name>
	<description>0: LED1 = PWM2,
1: LED1 = Breathing Timer.
Note: The PWM2/3/4 can also be routed to GPIOs using PID 25/26/27 respectively.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PLL_SYS_CTRL1_REG</name>
	<description>System PLL control register 1.</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PLL_R_DIV</name>
	<description>PLL Output dvider R (x means divide by x, 0 means divide by 1)</description>
	<access>read-write</access>
	<bitRange>[14:8]</bitRange>
	
</field><field>
	<name>LDO_PLL_VREF_HOLD</name>
	<description>0: indicates that the reference input is tracked,
1: indicates that the reference input is sampled.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>LDO_PLL_ENABLE</name>
	<description>0: LDO PLL off,
1: LDO PLL on.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>PLL_EN</name>
	<description>0: Power down
1: PLL on </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PLL_SYS_CTRL2_REG</name>
	<description>System PLL control register 2.</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00002006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PLL_SEL_MIN_CUR_INT</name>
	<description>0: VCO current read from min_current &lt;5:0&gt;,
1: VCO current is internally determined with a calibration algoritm.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>PLL_DEL_SEL</name>
	<description>PLL manual delay value for Phase Frequency Detector.
0: 0.493
1: 0.814
2: 1.13 ns &lt;- default
3: 1.44 ns </description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>PLL_N_DIV</name>
	<description>PLL Loop divider N (x means divide by x, 0 means divide by 1) </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PLL_SYS_CTRL3_REG</name>
	<description>System PLL control register 3.</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003c09</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PLL_RECALIB</name>
	<description>Recalibrate</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>PLL_START_DEL</name>
	<description>Programmable delay time for the loop filter voltage preset value. After PLL_EN is set, the loopfilter precharge resistors are disabled after this delay time. One LSB is 48 ns </description>
	<access>read-write</access>
	<bitRange>[14:10]</bitRange>
	
</field><field>
	<name>PLL_ICP_SEL</name>
	<description>PLL charge pump current select
One LSB is 5uA. </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PLL_SYS_STATUS_REG</name>
	<description>System PLL status register.</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PLL_CALIBR_END</name>
	<description>Indicates that calibration has finished.</description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>PLL_PLL_BEST_MIN_CUR</name>
	<description>Calibrated VCO frequency band.</description>
	<access>read-only</access>
	<bitRange>[10:5]</bitRange>
	
</field><field>
	<name>LDO_PLL_OK</name>
	<description>1: Indicates that LDO PLL is in regulation.</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>PLL_LOCK_FINE</name>
	<description>1: PLL locked </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PLL_SYS_TEST_REG</name>
	<description>System PLL test register.</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000070</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PLL_LOCK_DET_RES_CNT</name>
	<description>Lock measurement time in &lt;tbd&gt; clock cycle of xx usec. After this period PLL_LOCK_FINE is calculated based on the difference of the M and N counted pulses in that period. If PLL_LOCK_FINE is still 0, the lock state machine restarts until PLL_LOCK_FINE gets 1
0: &lt;tbd&gt; usec
7: &lt;tbd&gt; usec </description>
	<access>read-write</access>
	<bitRange>[15:13]</bitRange>
	
</field><field>
	<name>PLL_SEL_R_DIV_TEST</name>
	<description>Select test mode for output divider R
Maps PLL_R_DIV input on pins &lt;tbd&gt; and divider output on pin &lt;tbd&gt; </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>PLL_SEL_N_DIV_TEST</name>
	<description>Select test mode for loop divider N.
Maps PLL_N_DIV input on pins &lt;tbd&gt; and divider output on pin &lt;tbd&gt; </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>PLL_CHANGE</name>
	<description>0: normal value
1: reverse charge pump up/down signals </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>PLL_OPEN_LOOP</name>
	<description>1: set to open loop to termine max frequency </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>PLL_TEST_VCTR</name>
	<description>1: map loopfilter voltage on external pin &lt;tbd&gt; </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>PLL_MIN_CURRENT</name>
	<description>VCO current trimming.</description>
	<access>read-write</access>
	<bitRange>[6:1]</bitRange>
	
</field><field>
	<name>PLL_DIS_LOOPFILT</name>
	<description>1: disable PLL internal loop filter </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RESET_FREEZE_REG</name>
	<description>Controls unfreezing of various timers/counters (incl. DMA and USB).</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>FRZ_SWTIM2</name>
	<description>If '1', the SW Timer (TIMER2) continues, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>FRZ_SWTIM1</name>
	<description>If '1', the SW Timer (TIMER1) continues, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA continues, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>FRZ_USB</name>
	<description>If '1', the USB continues, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>FRZ_WDOG</name>
	<description>If '1', the watchdog timer continues, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>FRZ_BLETIM</name>
	<description>If '1', the BLE master clock continues, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>FRZ_SWTIM0</name>
	<description>If '1', the SW Timer (TIMER0) continues, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer continues, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SET_FREEZE_REG</name>
	<description>Controls freezing of various timers/counters (incl. DMA and USB).</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>FRZ_SWTIM2</name>
	<description>If '1', the SW Timer (TIMER2) is frozen, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>FRZ_SWTIM1</name>
	<description>If '1', the SW Timer (TIMER1) is frozen, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>FRZ_DMA</name>
	<description>If '1', the DMA is frozen, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>FRZ_USB</name>
	<description>If '1', the USB is frozen, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>FRZ_WDOG</name>
	<description>If '1', the watchdog timer is frozen, '0' is discarded. WATCHDOG_CTRL_REG[NMI_RST] must be '0' to allow the freeze function. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>FRZ_BLETIM</name>
	<description>If '1', the BLE master clock is frozen, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>FRZ_SWTIM0</name>
	<description>If '1', the SW Timer (TIMER0) is frozen, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If '1', the Wake Up Timer is frozen, '0' is discarded. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C</name>
	<version>1.0</version>
	<description>I2C registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001400</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>I2C_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_COMP2_VERSION</name>
	<description>I2C Component2 Version Register</description>
	<addressOffset>0x000000fa</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003132</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP2_VERSION</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_COMP_PARAM1_REG</name>
	<description>Component Parameter Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP_PARAM1</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_COMP_PARAM2_REG</name>
	<description>Component Parameter Register 2</description>
	<addressOffset>0x000000f6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP_PARAM2</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_COMP_TYPE2_REG</name>
	<description>I2C Component2 Type Register</description>
	<addressOffset>0x000000fe</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004457</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP2_TYPE</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_COMP_TYPE_REG</name>
	<description>I2C Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000140</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP_TYPE</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_COMP_VERSION_REG</name>
	<description>I2C Component Version Register</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000302a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP_VERSION</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000007d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s) </description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received. When 1, If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. When 0 If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. Reset value: 0x0</description>
	<access>write-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received. When 1 STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. When 0 STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0</description>
	<access>write-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a "don't care" because writes to this register are not required. In slave-transmitter mode, a "0" indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a "1" is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<access>write-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. 0 = Transmit DMA disabled 1 = Transmit DMA enabled </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. 0 = Receive DMA disabled 1 = Receive DMA enabled </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CTRL_ENABLE</name>
	<description>Controls whether the controller is enabled.
0: Disables the controller (TX and RX FIFOs are held in an erased state)
1: Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver
operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1.
When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1). </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000017</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a "transmit abort".
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a "transmit abort".
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-3,a value of 0 sets the threshold for 1 entry, and a value of 3 sets the threshold for 4 entries. </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. </description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_SDA_HOLD</name>
	<description>SDA Hold time</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. This register must be programmed with a value equal to or greater than 2. It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000048</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000004f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Slave FSM is in IDLE state so the Slave part of the controller is not Active
1: Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Master FSM is in IDLE state so the Master part of the controller is not Active
1: Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0: Receive FIFO is not full
1: Receive FIFO is full </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0: Receive FIFO is empty
1: Receive FIFO is not empty </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0: Transmit FIFO is not empty
1: Transmit FIFO is empty </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0: Transmit FIFO is full
1: Transmit FIFO is not full </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPECIAL</name>
	<description>This bit indicates whether software performs a General Call or
START BYTE command.
0: ignore bit 10 GC_OR_START and use IC_TAR normally
1: perform special I2C command as specified in GC_OR_START
bit </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>GC_OR_START</name>
	<description>If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1: START BYTE </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave
Writes to this register succeed only when IC_ENABLE[0] is set to 0</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ABRT_SLVRD_INTX</name>
	<description>1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2 IC_DATA_CMD register </description>
	<access>read-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>1: Slave lost the bus while transmitting data to a remote master.
I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never "owns" the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus. </description>
	<access>read-only</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>1: Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO. </description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>ARB_LOST</name>
	<description>1: Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time. </description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>1: User tries to initiate a Master operation with the Master mode disabled. </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode. </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>1: Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>1: Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior). </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>1: the controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1). </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>1: the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>1: This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s). </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>1: Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>1: Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>1: Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>TX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-3, a value of 0 sets the threshold for 0 entries, and a value of 3 sets the threshold for 4 entries.. </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C2</name>
	<version>1.0</version>
	<description>I2C2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001500</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>I2C2_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_COMP2_VERSION</name>
	<description>I2C Component2 Version Register</description>
	<addressOffset>0x000000fa</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003132</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP2_VERSION</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_COMP_PARAM1_REG</name>
	<description>Component Parameter Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP_PARAM1</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_COMP_PARAM2_REG</name>
	<description>Component Parameter Register 2</description>
	<addressOffset>0x000000f6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP_PARAM2</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_COMP_TYPE2_REG</name>
	<description>I2C Component2 Type Register</description>
	<addressOffset>0x000000fe</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004457</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP2_TYPE</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_COMP_TYPE_REG</name>
	<description>I2C Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000140</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP_TYPE</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_COMP_VERSION_REG</name>
	<description>I2C Component Version Register</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000302a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_COMP_VERSION</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000007d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0=slave is enabled
1=slave is disabled
Software should ensure that if this bit is written with '0', then bit 0 should also be written with a '0'. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0= disable
1=enable </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0= 7-bit addressing
1= 10-bit addressing </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1= standard mode (100 kbit/s)
2= fast mode (400 kbit/s) </description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0= master disabled
1= master enabled
Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received. When 1, If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. When 0 If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead. Reset value: 0x0</description>
	<access>write-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received. When 1 STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus. When 0 STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. Reset value: 0x0</description>
	<access>write-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a "don't care" because writes to this register are not required. In slave-transmitter mode, a "0" indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a "1" is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<access>write-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA channel. 0 = Transmit DMA disabled 1 = Transmit DMA enabled </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel. 0 = Receive DMA disabled 1 = Receive DMA enabled </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CTRL_ENABLE</name>
	<description>Controls whether the controller is enabled.
0: Disables the controller (TX and RX FIFOs are held in an erased state)
1: Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver
operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1.
When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1). </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000017</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a "transmit abort".
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
=&gt; Disabling the I2C Ctrl
=&gt; Reading the IC_CLR_ACTIVITY register
=&gt; Reading the IC_CLR_INTR register
=&gt; System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a "transmit abort".
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-3,a value of 0 sets the threshold for 1 entry, and a value of 3 sets the threshold for 4 entries. </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. </description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_SDA_HOLD</name>
	<description>SDA Hold time</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. This register must be programmed with a value equal to or greater than 2. It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000048</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other
times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000004f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Slave FSM is in IDLE state so the Slave part of the controller is not Active
1: Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0: Master FSM is in IDLE state so the Master part of the controller is not Active
1: Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0: Receive FIFO is not full
1: Receive FIFO is full </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0: Receive FIFO is empty
1: Receive FIFO is not empty </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0: Transmit FIFO is not empty
1: Transmit FIFO is empty </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0: Transmit FIFO is full
1: Transmit FIFO is not full </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPECIAL</name>
	<description>This bit indicates whether software performs a General Call or
START BYTE command.
0: ignore bit 10 GC_OR_START and use IC_TAR normally
1: perform special I2C command as specified in GC_OR_START
bit </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>GC_OR_START</name>
	<description>If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0: General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1: START BYTE </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave
Writes to this register succeed only when IC_ENABLE[0] is set to 0</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ABRT_SLVRD_INTX</name>
	<description>1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2 IC_DATA_CMD register </description>
	<access>read-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>1: Slave lost the bus while transmitting data to a remote master.
I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never "owns" the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus. </description>
	<access>read-only</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>1: Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO. </description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>ARB_LOST</name>
	<description>1: Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time. </description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>1: User tries to initiate a Master operation with the Master mode disabled. </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode. </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte. </description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode </description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>1: Master has sent a START Byte and the START Byte was acknowledged (wrong behavior). </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>1: Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior). </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>1: the controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1). </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>1: the controller in master mode sent a General Call and no slave on the bus acknowledged the General Call. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>1: This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s). </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>1: Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>1: Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>1: Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>I2C2_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>TX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-3, a value of 0 sets the threshold for 0 entries, and a value of 3 sets the threshold for 4 entries.. </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>IR</name>
	<version>1.0</version>
	<description>IR registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001700</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>20</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>IR_CTRL_REG</name>
	<description>IR control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>IR_IRQ_EN</name>
	<description>1 = Enables the interrupt generation upon TX completion
0 = masks out the interrupt generation upon TX completion
</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>IR_LOGIC_ONE_FORMAT</name>
	<description>1 = Logic one starts with a Space followed by a Mark
0 = Logic one starts with a Mark followed by a Space
</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>IR_LOGIC_ZERO_FORMAT</name>
	<description>1 = Logic zero starts with a Space followed by a Mark
0 = Logic zero starts with a Mark followed by a Space</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>IR_INVERT_OUTPUT</name>
	<description>1 = IR output is inverted
0 = IR output is not inverted
</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>IR_REPEAT_TYPE</name>
	<description>1 = repeat command is defined at Repeat FIFO
0 = repeat command is defined at Code FIFO
</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IR_TX_START</name>
	<description>1 = IR transmits a command
0 = IR is stopped
While this bit is 1 and SW programs it to 0, the code FIFO will be flushed automatically.
</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>IR_ENABLE</name>
	<description>1 = IR block is enabled
0 = IR block is disabled and at reset state. This also resets the pointers at the FIFOs
</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>IR_REP_FIFO_RESET</name>
	<description>1 = Flush Repeat FIFO (auto clear)</description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>IR_CODE_FIFO_RESET</name>
	<description>1 = Flush Code FIFO (auto clear)</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>IR_FREQ_CARRIER_OFF_REG</name>
	<description>Defnes the carrier signal low duration</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>IR_FREQ_CARRIER_OFF</name>
	<description>Defines the carrier signal low duration in IR_clk cycles</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>IR_FREQ_CARRIER_ON_REG</name>
	<description>Defines the carrier signal  high duration</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>IR_FREQ_CARRIER_ON</name>
	<description>Defines the carrier signal high duration in IR_clk cycles. 0x0 is not allowed as a value.</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>IR_IRQ_STATUS_REG</name>
	<description>IR interrupt status register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>IR_IRQ_ACK</name>
	<description>When read Interrupt line is cleared</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>IR_LOGIC_ONE_TIME_REG</name>
	<description>Defines the logic one waveform</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000101</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IR_LOGIC_ONE_MARK</name>
	<description>Defines the mark duration in carrier clock cycles. Must be &gt;0</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>IR_LOGIC_ONE_SPACE</name>
	<description>Defines the space duration in carrier clock cycles. Must be &gt;0</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>IR_LOGIC_ZERO_TIME_REG</name>
	<description>Defines the logic zero wavefrom</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000101</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IR_LOGIC_ZERO_MARK</name>
	<description>Defines the mark duration in carrier clock cycles. Must be &gt;0</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>IR_LOGIC_ZERO_SPACE</name>
	<description>Defines the space duration in carrier clock cycles. Must be &gt;0</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>IR_MAIN_FIFO_REG</name>
	<description>Main fifo write register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IR_CODE_FIFO_DATA</name>
	<description>Code FIFO data write port</description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>IR_REPEAT_FIFO_REG</name>
	<description>Repeat fifo write register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IR_REPEAT_FIFO_DATA</name>
	<description>Repeat FIFO data write port</description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>IR_REPEAT_TIME_REG</name>
	<description>Defines the repeat time</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IR_REPEAT_TIME</name>
	<description>Defines the repeat time in carrier clock cycles. The repeat timer will start counting from the start of the command and will trigger the output of the same command residing in the Code FIFO or the special command residing in the Repeat FIFO as soon as it expires.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>IR_STATUS_REG</name>
	<description>IR status register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>IR_BUSY</name>
	<description>1 = IR generator is busy sending a message
0 = IR generator is idle
</description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>IR_REP_FIFO_WRDS</name>
	<description>Contains the amount of words in Repeat FIFO (updated only on write)</description>
	<access>read-only</access>
	<bitRange>[9:6]</bitRange>
	
</field><field>
	<name>IR_CODE_FIFO_WRDS</name>
	<description>Contains the amount of words in Code FIFO (updated only on write)</description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>KBSCAN</name>
	<version>1.0</version>
	<description>KBSCAN registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001600</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>92</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>KBSCN_CTRL2_REG</name>
	<description>Keyboard scanner control 2 register</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>KBSCN_ROW_ACTIVE_TIME</name>
	<description>Define the row active time in keyboard clock cycles</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_CTRL_REG</name>
	<description>Keyboard scanner control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>KBSCN_RESET_FIFO</name>
	<description>'1' reset fifo, read always '0'</description>
	<access>write-only</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>KBSCN_CLKDIV</name>
	<description>Defines keyboard clk. "00" div/1, "01" div/4, "10" div/16, "11" div/64</description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>KBSCN_INACTIVE_EN</name>
	<description>'1' After inactive time the keyboard scanner stops the key maxtrix scan</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>KBSCN_INACTIVE_TIME</name>
	<description>Defines the inactive time in scan cycles. Value 0 is not allowed</description>
	<access>read-write</access>
	<bitRange>[10:4]</bitRange>
	
</field><field>
	<name>KBSCN_IRQ_FIFO_MASK</name>
	<description>'1' Enable IRQ for fifo over and under flow</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>KBSCN_IRQ_INACTIVE_MASK</name>
	<description>'1' : Enable IRQ for inactive</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>KBSCN_IRQ_MESSAGE_MASK</name>
	<description>'1' : Enable IRQ for message</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>KBSCN_EN</name>
	<description>'1' : Enable keyboard scanner, Auto clear when inactive enable and inactive case</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_DEBOUNCE_REG</name>
	<description>Defines the debounce time for key press and release</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000082</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>KBSCN_DEBOUNCE_PRESS_TIME</name>
	<description>Defines the press debounce time in cycles of full matrix scan. One means no debounce, zero is reserved</description>
	<access>read-write</access>
	<bitRange>[11:6]</bitRange>
	
</field><field>
	<name>KBSCN_DEBOUNCE_RELEASE_TIME</name>
	<description>Defines the press debounce time in cycles of full matrix scan. One means no debounce, zero is reserved</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_MATRIX_SIZE_REG</name>
	<description>Defines the number of rows and columns of the matrix</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>KBSCN_MATRIX_COLUMN</name>
	<description>Defines the number of the columns of the keyboard matrix minus 1. Zero means number of columns 1</description>
	<access>read-write</access>
	<bitRange>[8:4]</bitRange>
	
</field><field>
	<name>KBSCN_MATRIX_ROW</name>
	<description>Defines the number of the rows of the keyboard matrix minus 1. Zero means number of rows 1</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_MESSAGE_KEY_REG</name>
	<description>Returns a key message from the message queue</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>KBSCN_LAST_ENTRY</name>
	<description>'1' : this message is the last of the group message, else '0'. When '1' bits 9:0 are all '1' </description>
	<access>read-only</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>KBSCN_KEY_STATE</name>
	<description>'0' : New key state is release
'1' : New key state is press</description>
	<access>read-only</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>KBSCN_KEYID_COLUMN</name>
	<description>Defines the column id of key</description>
	<access>read-only</access>
	<bitRange>[8:4]</bitRange>
	
</field><field>
	<name>KBSCN_KEYID_ROW</name>
	<description>Defines the row id of key</description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P00_MODE_REG</name>
	<description>Defines the keyboard mode for P00</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P01_MODE_REG</name>
	<description>Defines the keyboard mode for P01</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P02_MODE_REG</name>
	<description>Defines the keyboard mode for P02</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P03_MODE_REG</name>
	<description>Defines the keyboard mode for P03</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P04_MODE_REG</name>
	<description>Defines the keyboard mode for P04</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P05_MODE_REG</name>
	<description>Defines the keyboard mode for P05</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P06_MODE_REG</name>
	<description>Defines the keyboard mode for P06</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P07_MODE_REG</name>
	<description>Defines the keyboard mode for P07</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P10_MODE_REG</name>
	<description>Defines the keyboard mode for P10</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P11_MODE_REG</name>
	<description>Defines the keyboard mode for P11</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P12_MODE_REG</name>
	<description>Defines the keyboard mode for P12</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P13_MODE_REG</name>
	<description>Defines the keyboard mode for P13</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P14_MODE_REG</name>
	<description>Defines the keyboard mode for P14</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P15_MODE_REG</name>
	<description>Defines the keyboard mode for P15</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P16_MODE_REG</name>
	<description>Defines the keyboard mode for P16</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P17_MODE_REG</name>
	<description>Defines the keyboard mode for P17</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P20_MODE_REG</name>
	<description>Defines the keyboard mode for P20</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P21_MODE_REG</name>
	<description>Defines the keyboard mode for P21</description>
	<addressOffset>0x0000002e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P22_MODE_REG</name>
	<description>Defines the keyboard mode for P22</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P23_MODE_REG</name>
	<description>Defines the keyboard mode for P23</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P24_MODE_REG</name>
	<description>Defines the keyboard mode for P24</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P30_MODE_REG</name>
	<description>Defines the keyboard mode for P30</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P31_MODE_REG</name>
	<description>Defines the keyboard mode for P31</description>
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P32_MODE_REG</name>
	<description>Defines the keyboard mode for P32</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P33_MODE_REG</name>
	<description>Defines the keyboard mode for P33</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P34_MODE_REG</name>
	<description>Defines the keyboard mode for P34</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P35_MODE_REG</name>
	<description>Defines the keyboard mode for P35</description>
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P36_MODE_REG</name>
	<description>Defines the keyboard mode for P36</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P37_MODE_REG</name>
	<description>Defines the keyboard mode for P37</description>
	<addressOffset>0x0000004a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P40_MODE_REG</name>
	<description>Defines the keyboard mode for P40</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P41_MODE_REG</name>
	<description>Defines the keyboard mode for P41</description>
	<addressOffset>0x0000004e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P42_MODE_REG</name>
	<description>Defines the keyboard mode for P42</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P43_MODE_REG</name>
	<description>Defines the keyboard mode for P43</description>
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P44_MODE_REG</name>
	<description>Defines the keyboard mode for P44</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P45_MODE_REG</name>
	<description>Defines the keyboard mode for P45</description>
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P46_MODE_REG</name>
	<description>Defines the keyboard mode for P46</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_P47_MODE_REG</name>
	<description>Defines the keyboard mode for P47</description>
	<addressOffset>0x0000005a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>KBSCN_GPIO_EN</name>
	<description>'1' GPIO is enable for row or column</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>KBSCN_ROW</name>
	<description>'1' GPIO is row, '0' GPIO is column</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>KBSCN_MODE</name>
	<description>Defines the row/column index that has to be connected</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>KBSCN_STATUS_REG</name>
	<description>keyboard scanner Interrupt status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>KBSCN_FIFO_UNDERFL</name>
	<description>'1' Fifo Underflow occurred</description>
	<access>read-only</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>KBSCN_FIFO_OVERFL</name>
	<description>'1' Fifo Overflow occurred</description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>KBSCN_NUM_MESSAGE</name>
	<description>Defines how many messages there are in the fifo.</description>
	<access>read-only</access>
	<bitRange>[6:2]</bitRange>
	
</field><field>
	<name>KBSCN_INACTIVE_IRQ_STATUS</name>
	<description>There is no keyboard activity for a predefined time</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>KBSCN_MES_IRQ_STATUS</name>
	<description>There is at least one last message in the fifo. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>OTPC</name>
	<version>1.0</version>
	<description>OTPC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x07f40000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>52</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>OTPC_AHBADR_REG</name>
	<description>AHB master start address</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07fc0000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_AHBADR</name>
	<description>It is the AHB address used by the AHB master interface of the controller (the bits [31:2]). The bits [1:0] of the address are considered always as equal to zero.
The value of the register remains unchanged, by the internal logic of the controller. </description>
	<access>read-write</access>
	<bitRange>[31:2]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_CELADR_REG</name>
	<description>Macrocell start address</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_CELADR_LV</name>
	<description>This is a readonly field that contains the "live" value of the OTP cell address as it is used by the hardware of the OTPC controller during the AREAD and the APROG modes. The value of the register is updated only while the OTPC is in AREAD or the APROG mode. </description>
	<access>read-only</access>
	<bitRange>[29:16]</bitRange>
	
</field><field>
	<name>OTPC_CELADR</name>
	<description>It represents an OTP address, where the OTP word width should be considered equal to 32-bits.
The physical word width of the OTP memory is 72 bits. The 8-bits of them are used for the implementation of an error correcting code and are not available for the application. The remaining 64 bits of the physical word are available for the application. 
The OTPC_CELADDR can distinguish the upper 32 bits from the lower 32 bits of the available for the application bits of the OTP word.
When OTPC_CELADDR[0] = 1 the address refers to the upper 32 bits of the physical OTP address OTPC_CELADDR[14:1].
The register is used during the modes: AREAD and APROG.
The value of the register remains unchanged, by the internal logic of the controller.</description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_FFPRT_REG</name>
	<description>Ports access to fifo logic</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_FFPRT</name>
	<description>Provides access to the fifo through an access port.
Write to this register with the corresponding data, when the APROG mode is selected and the dma is disabled.
Read from this register the corresponding data, when the AREAD mode is selected and the dma is disabled.
The software should check the OTPCC_STAT_FWORDS register for the availability of data/space, before accessing the fifo.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_FFRD_REG</name>
	<description>The data which have taken with the latest read from the OTPC_FFPRT_REG</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_FFRD</name>
	<description>Contains the value which taken from the fifo, after a read of the OTPC_FFPRT_REG register. </description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_MODE_REG</name>
	<description>Mode register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_MODE_RLD_RR_REQ</name>
	<description>Write with 1 in order to be requested the reloading of the repair records. The reloading of the repair records will be performed at the next enabling of the OTP cell. That means that first the controller should be configured to the STBY mode and after should be activated any other mode. The hardware will clear this register, when the reloading will be performed.
The reloading has meaning only if the repair records have been updated manually (MPROG mode).</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>OTPC_MODE_USE_SP_ROWS</name>
	<description>Selects the memory area of the OTP cell that will be used.
0: Uses the normal memory area of the OTP cell
1: Uses the spare rows of the OTP cell
This selection has meaning only if the mode of the controller is not TDEC and TWR. The controller should be in STBY mode, in order to takes into account this bit. The selection will take effect at the next mode that will be enabled.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>OTPC_MODE_ERR_RESP_DIS</name>
	<description>When is performed a read from the OTP memory in the MREAD mode, a double error is likely be detected during the retrieving of the data from the OTP. This error condition is always indicated in the status bit OTPC_STAT_REG[OTPC_STAT_RERROR]. However, the OTP controller has also the ability to indicates this error condition, by generating an ERROR response in the AHB bus.
The generation of the ERROR response can be avoided with the help of this configuration bit.
0: The OTP controller generates an ERROR response in the AHB bus, when a double error is detected during a reading in MREAD mode. The OTPC_STAT_REG[OTPC_STAT_RERROR] is also updated. The receiving of an ERROR response by the CPU causes a Hard Fault exception in the CPU.
1: Only the OTPC_STAT_REG[OTPC_STAT_RERROR] is updated in a case of such error. The OTP controller will not generate an ERROR response in the AHB bus.
</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>OTPC_MODE_FIFO_FLUSH</name>
	<description>By writing with 1, removes any content from the fifo. This bit returns automatically to value 0. </description>
	<access>write-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>OTPC_MODE_USE_DMA</name>
	<description>Selects the use of the dma, when the controller is configured in one of the modes: AREAD or APROG.
0: The dma is not used. The data should be transferred from/to controller through the register OTPC_FFPRT_REG.
1: The dma is used. The data transfers from/to controller are performed automatically, with the help of the internal DMA of the OTP controller. The AHB base address should be configured in register OTPC_AHBADR_REG, before the selection of one of the two modes: AREAD or APROG.</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>OTPC_MODE_MODE</name>
	<description>Defines the mode of operation of the OTPC controller. The encoding of the modes is as follows:
0x0: STBY mode
0x1: MREAD mode
0x2: MPROG mode
0x3: AREAD mode
0x4: APROG mode
0x5: TBLANK mode
0x6: TDEC mode
0x7: TWR mode </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_NWORDS_REG</name>
	<description>Number of words</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_NWORDS</name>
	<description>The number of words (minus one) for reading /programming during the AREAD/APROG mode.
The width of the word should be considered equal to 32-bits.
The value of the register remains unchanged, by the internal logic of the controller.
During mirroring, this register reflects the current ammount of copied data.</description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_PCTRL_REG</name>
	<description>Bit-programming control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_PCTRL_PSTART</name>
	<description>Write with '1' to trigger the programming of one OTP word, in the case where the MPROG mode is selected. The bit is cleared automatically. The 64-bits that will be programmed into the OTP memory are contained into the two registers OTPC_PWORDx_REG.
This bit should be used when a new programming is initiated, but also when the programming must be retried.
The OTPC_PCTRL_WADDR defines the OTP position where will be performed the programming.</description>
	<access>write-only</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>OTPC_PCTRL_PRETRY</name>
	<description>It distinguishes the first attempt of a programming of an OTP position, from a retry of programming.
0: A new value will be programmed in a blank OTP position. The hardware will try to write all the bits that are equal to '1'.
1: The programming that is applied is not the first attempt, but is a request for reprogramming. Will be processed only the bits that were failed to be programmed during the previous attempt. The hardware knows the bits that were failed during the previous attempt.
The registers OTPC_PWORDx_REG should contain the 64 bits of the value that should be programmed, independent of the value of the OTPC_PCTRL_PRETRY bit.
Also, the OTPC_PCTRL_WADDR should contain always the required OTP address.
A retry of a programming should be requested only if the previous action was the first attempt of programming or a retry of programming. Should not be requested a retry if the first attempt has not been performed.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>OTPC_PCTRL_WADDR</name>
	<description>Defines the OTP position where will be programmed the 64-bits that are contained into the registers OTPC_PWORDx_REG. It points to a physical 72 bits OTP word.</description>
	<access>read-write</access>
	<bitRange>[12:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_PWORDH_REG</name>
	<description>The 32 higher bits of the 64-bit word that will be programmed, when the MPROG mode is used.</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_PWORDH</name>
	<description>Contains the upper 32 bits that can be programmed with the help of the OTPC_PCTRL_REG, while the controller is in MPROG mode.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_PWORDL_REG</name>
	<description>The 32 lower bits of the 64-bit word that will be programmed, when the MPROG mode is used.</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_PWORDL</name>
	<description>Contains the lower 32 bits that can be programmed with the help of the OTPC_PCTRL_REG, while the controller is in MPROG mode.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_STAT_REG</name>
	<description>Status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000051</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_STAT_NWORDS</name>
	<description>It contains the "live" value of the number of (32 bits) words that remain to be processed by the controller.</description>
	<access>read-only</access>
	<bitRange>[29:16]</bitRange>
	
</field><field>
	<name>OTPC_STAT_FWORDS</name>
	<description>Indicates the number of words which contained in the fifo of the controller.</description>
	<access>read-only</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>OTPC_STAT_RERROR</name>
	<description>Indicates that during a normal reading (MREAD or AREAD) was reported a double error by the SECDED logic. That means that the data are corrupted.
0: The read data are considered as correct.
1: The SECDED logic detects a double error.
This bit can be cleared only with a write with '1'.
</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>OTPC_STAT_ARDY</name>
	<description>Should be used to monitor the progress of the AREAD and APROG modes.
0: One of the APROG or AREAD mode is selected. The controller is busy.
1: The controller is not in an active AREAD or APROG mode.
</description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>OTPC_STAT_TERROR</name>
	<description>Indicates the result of a test sequence. Should be checked after the end of a TBLANK, TDEC and TWR mode (OTPC_STAT_TRDY = 1).
0: The test sequence ends with no error.
1: The test sequence has failed.</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>OTPC_STAT_TRDY</name>
	<description>Indicates the state of a test mode. Should be used to monitor the progress of the TBLANK, TDEC and TWR modes.
0: The controller is busy. One of the test modes is in progress.
1: There is no active test mode.</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>OTPC_STAT_PZERO</name>
	<description>Indicates that the programming sequence has been avoided during a programming request, due to that the word that should be programmed is equal to zero.
0: At least one bit has been programmed into the OTP.
1: The programming has not been performed. All the bits of the word that should be programmed are equal to zero.
When the controller is in MPROG mode, this bit can be checked after the end of the programming process (OTPC_STAT_PRDY = 1).
During APROG mode, the value of this field it is normal to changing periodically. After the end of the APROG mode (OTPC_STAT_ARDY = 1), this field indicates that one or more of words that have been processed are equal to zero.</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>OTPC_STAT_PERR_COR</name>
	<description>Indicates that a correctable error has been occurred during the word programming process.
0: There is no correctable error in the word-programming process.
1: The process of word - programming reported a correctable error.
The correctable error occurs when exactly one bit in an OTP position cannot take the required value. This is not a critical failure in the programming process. The data can still be retrieved correctly by the OTP memory, due to that the error correcting algorithm can repair the corrupted bit.
When the controller is in MPROG mode, this bit can be checked after the end of the programming process (OTPC_STAT_PRDY = 1).
During APROG mode, the value of this field it is normal to changing periodically. After the end of the APROG mode (OTPC_STAT_ARDY = 1), this field indicates that one or more words had a correctable error.</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>OTPC_STAT_PERR_UNC</name>
	<description>Indicates that an uncorrectable error has been occurred during the word programming process.
0: There is no uncorrectable error in the word-programming process.
1: The process of word-programming failed due to an uncorrectable error.
An uncorrectable error is considered when two or more of the bits in an OTP position cannot take the required values. This is a critical failure in the programming process, which means that the data cannot corrected by the single error correcting algorithm.
When the controller is in MPROG mode, this bit should be checked after the end of the programming process (OTPC_STAT_PRDY = 1).
During APROG mode, the value of this field it is normal to changing periodically. After the end of the APROG mode (OTPC_STAT_ARDY = 1), this field indicates if the programming was failed or ended successfully.</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>OTPC_STAT_PRDY</name>
	<description>Indicates the state of a bit-programming process.
0: The controller is busy. A bit-programming is in progress
1: The logic which performs bit-programming is idle.
When the controller is in MPROG mode, this bit should be used to monitor the progress of a programming request.
During APROG mode, the value of this field it is normal to changing periodically. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_TEST_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_USED_RR</name>
	<description>Indicates the source from which have been retrieved the data when is performed a reading from the OTP memory. This bit is updated after every reading from the OTP memory.
0: The data have been retrieved from the OTP memory itself.
1: The data have been retrieved from a repair record and not for the OTP memory itself.

When OTPC_USED_RR=1, the OTPC_SECDED_STAT and the OTPC_SECDED_RAW_ECC are invalid.</description>
	<access>read-only</access>
	<bitRange>[26:26]</bitRange>
	
</field><field>
	<name>OTPC_SECDED_STAT</name>
	<description>This is the status of the SECDED circuit, after the decoding of a retrieved word. It is updated every time where a new OTP word is retrieved from the OTP memory.This field is invalid when the OTPC_USED_RR is equal to 1.
0x0: No error
0x1: A single bit error has been detected.
0x2: A double bit error has been detected
0x3: A single bit error has been detected. The corrupted bit is the parity bit.

This field is valid even when OTPC_SECDED_COR_DIS=1.</description>
	<access>read-only</access>
	<bitRange>[25:24]</bitRange>
	
</field><field>
	<name>OTPC_SECDED_RAW_ECC</name>
	<description>This is the raw value of the SECDED ECC as has been retrieved from the OTP memory. It is updated every time where a new OTP word is retrieved from the OTP memory.This field is invalid when the OTPC_USED_RR is equal to 1.</description>
	<access>read-only</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>OTPC_SECDED_COR_DIS</name>
	<description>This bit is for test purposes and controls the correction that is applied by the SECDED during the normal read of the OTP memory.
0: The SECDED correction is applied in the word that is retrieved from the OTP memory. The OTPC_STAT_RERROR is updated after each read from the OTP memory. The generation of an AHB ERROR is controlled by the OTPC_MODE_ERR_RESP_DIS.
1: The SECDED correction is not applied. The data that are returned by the OTP controller is the raw data that is contained in the OTP memory. The OTPC_STAT_RERROR is not updated and there is no generation of an AHB ERROR response in a case of a double error.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_TIM1_REG</name>
	<description>Various timing parameters of the OTP cell.</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x1a104f20</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_TIM1_CC_T_25NS</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval at least higher than 25 ns.</description>
	<access>read-write</access>
	<bitRange>[31:31]</bitRange>
	
</field><field>
	<name>OTPC_TIM1_CC_T_200NS</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval at least higher than 200 ns.</description>
	<access>read-write</access>
	<bitRange>[30:27]</bitRange>
	
</field><field>
	<name>OTPC_TIM1_CC_T_500NS</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval at least higher than 500 ns</description>
	<access>read-write</access>
	<bitRange>[26:22]</bitRange>
	
</field><field>
	<name>OTPC_TIM1_CC_T_1US</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval at least higher than 1 us.</description>
	<access>read-write</access>
	<bitRange>[21:16]</bitRange>
	
</field><field>
	<name>OTPC_TIM1_CC_T_PW</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval that is
- at least higher than 4.8 us
- and lower than 5.2 us
It is preferred the programmed value to give a time interval equal to 5 us.
It defines the duration of the programming pulse for every bit that written in the OTP cell.</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>OTPC_TIM1_CC_T_CADX</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval at least higher than 2 us. It is used as a wait time each time where the OTP cell is enabled.</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>OTPC_TIM2_REG</name>
	<description>Various timing parameters of the OTP cell.</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00010000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>OTPC_TIM2_RDENL_PROT</name>
	<description>This bit has meaning only when the OTPC_TIM1_CC_T_25NS = 1, otherwise has no functionality. 
0: The minimum number of clock cycles for which the signal read_enable of the OTP memory stays inactive is one clock cycle. This is also applicable if OTPC_TIM1_CC_T_25NS = 0.
1: The minimum number of clock cycles for which the signal read_enable of the OTP memory stays inactive is two clock cycles. The controller adds one extra wait state in the AHB access , if it is required, in order to achieves this constraint. This setting is applicable only if OTPC_TIM1_CC_T_25NS = 1.</description>
	<access>read-write</access>
	<bitRange>[23:23]</bitRange>
	
</field><field>
	<name>OTPC_TIM2_CC_T_BCHK</name>
	<description>The number of hclk_c clock periods (minus one) that give a time interval between 100 ns and 200 ns. This time interval is used for the reading of the contents of the OTP cell during the TBLANK mode.</description>
	<access>read-write</access>
	<bitRange>[22:16]</bitRange>
	
</field><field>
	<name>OTPC_TIM2_CC_STBY_THR</name>
	<description>This register controls a power saving feature, which is applicable only in MREAD mode. The controller monitors the accesses in the OTP cell. If there is no access for more than OTPC_TIM2_CC_STBY_THR hclk_c clock cycles, the OTP cell goes to the standby while the controller itself remains in the MREAD mode. The OTP cell will be enabled again when will be applied a new read request. The enabling of the OTP cell has a cost of 2 us (OTPC_TIM1_CC_T_CADX hclk_c clock cycles).
When OTPC_TIM2_CC_STBY_THR = 0 the power saving feature is disabled and the OTP cell remains active while the controller is in MREAD mode.</description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>PATCH</name>
	<version>1.0</version>
	<description>PATCH registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x40050000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>PATCH_ADDR0_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR10_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR11_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR12_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR13_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR14_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR15_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR16_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR17_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR18_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR19_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000b8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR1_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR20_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<access>read-write</access>
	<bitRange>[16:2]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR21_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<access>read-write</access>
	<bitRange>[16:2]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR22_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<access>read-write</access>
	<bitRange>[16:2]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR23_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<access>read-write</access>
	<bitRange>[16:2]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR24_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<access>read-write</access>
	<bitRange>[16:2]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR25_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<access>read-write</access>
	<bitRange>[16:2]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR26_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<access>read-write</access>
	<bitRange>[16:2]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR27_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_D</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs, the reading data bus willl be replaced by the value of the corresponding PATCH_DATAx_REG.</description>
	<access>read-write</access>
	<bitRange>[16:2]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR2_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR3_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR4_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR5_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR6_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR7_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR8_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_ADDR9_REG</name>
	<description>Patch Address field</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x07f00000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_ADDR_19</name>
	<description>Address bit 19 (refer to the remaining register bitfields).</description>
	<access>read-write</access>
	<bitRange>[19:19]</bitRange>
	
</field><field>
	<name>PATCH_ADDR_C</name>
	<description>The value which will be compared with the address on the AHB. If a match occurs then it is considered as the base address of a function.</description>
	<access>read-write</access>
	<bitRange>[16:1]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_DATA20_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_DATA21_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_DATA22_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_DATA23_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_DATA24_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_DATA25_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_DATA26_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_DATA27_REG</name>
	<description>Patch Data field</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_DATA</name>
	<description>This is the value which will be injected into the data bus if there is a match on the comparison of the address with the respective PATCH_ADDRx_REG </description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_VALID_REG</name>
	<description>Validity Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_VALID</name>
	<description>Indicates which patch entry is valid. For example, when bit x is high it indicates that entry x is valid, i.e. the values of PATCH_ADDRx_REG / PATCH_DATAx_REG, are effective. </description>
	<access>read-write</access>
	<bitRange>[27:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_VALID_RESET_REG</name>
	<description>Validity Reset Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_VALID</name>
	<description>Writing to this register, it will clear to "0" the bits of PATCH_VALID_REG that correspond to the bits with "1" of the PATCH_VALID_RESET_REG write value.</description>
	<access>write-only</access>
	<bitRange>[27:0]</bitRange>
	
</field></fields>
</register><register>
	<name>PATCH_VALID_SET_REG</name>
	<description>Validity Set Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>PATCH_VALID</name>
	<description>Writing to this register, it will set to "1" the bits of PATCH_VALID_REG that correspond to the bits with "1" of the PATCH_VALID_SET_REG write value.</description>
	<access>write-only</access>
	<bitRange>[27:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>PLLDIG</name>
	<version>1.0</version>
	<description>PLLDIG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50002d00</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>114</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>RF_BMCW_REG</name>
	
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>HSI_SEL</name>
	<description>Select between:
1 = use HSI_WR as HSI
0 = use HSI from the MAC attributes (normal function). </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>CN_SEL</name>
	<description>Select between:
1 = use CN_WR as channel number
0 = use BLE/FTDF Frequency word (normal function). </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>HSI_WR</name>
	<description>HSI functionality. When set, the LO frequency is 1 MHz below the channel frequency
</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>CN_WR</name>
	<description>[5:0] = Channel Number </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CALCAP1_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000502a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>VCO_CALCAP_LOW</name>
	<description>Lowest 16 bits of vco_calcap </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CALCAP2_REG</name>
	
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>VCO_CALCAP_HIGH</name>
	<description>Highest 2 bits of vco_calcap. </description>
	<access>read-only</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CALTRIM_STEP1_REG</name>
	
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MDSTATE_RD</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CALTRIM_STEP2_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MDSTATE_RD</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CALTRIM_STEP3_REG</name>
	
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MDSTATE_RD</name>
	
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CALTRIM_STEP4_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MDSTATE_RD</name>
	<description>Content of the calibration counter </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_FTDF_PHYATTR_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>FTDF_PHYATTR</name>
	<description>Read out the phyattr bus from the FTDF</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_KMOD_ALPHA_BLE_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000028c</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>KMOD_ALPHA_TXDAC</name>
	<description>BLE Kmod channel dependent trimming constant (when TX-DAC is used).
0: No trimming is activated
&gt;0: The modulation gain in the direct path is modified with a factor: 1-SGNx(KMOD_ALPHA)x(CN-CN_CAL_RD)/2048</description>
	<access>read-write</access>
	<bitRange>[11:6]</bitRange>
	
</field><field>
	<name>KMOD_ALPHA_GAUSSDAC</name>
	<description>BLE Kmod channel dependent trimming constant (when GAUSS DAC is used).
0: No trimming is activated
&gt;0: The modulation gain in the direct path is modified with a factor: 1-SGNx(KMOD_ALPHA)x(CN-CN_CAL_RD)/2048</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_KMOD_ALPHA_FTDF_REG</name>
	
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>KMOD_ALPHA_FTDF</name>
	<description>FTDF Kmod channel dependent trimming constant.
0: No trimming is activated
&gt;0: The modulation gain in the direct path is modified with a factor: 1-SGNx(KMOD_ALPHA)x(CN-CN_CAL_RD)/2048</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_COMP_VAL0_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>MGAIN_COMP_VAL</name>
	<description>Intermediate main_cmp_count value</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_COMP_VAL1_REG</name>
	
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>MGAIN_COMP_VAL</name>
	<description>Intermediate main_cmp_count value</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_COMP_VAL2_REG</name>
	
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>MGAIN_COMP_VAL</name>
	<description>Intermediate main_cmp_count value</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_COMP_VAL3_REG</name>
	
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>MGAIN_COMP_VAL</name>
	<description>Intermediate main_cmp_count value</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_COMP_VAL4_REG</name>
	
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>MGAIN_COMP_VAL</name>
	<description>Intermediate main_cmp_count value</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_COMP_VAL5_REG</name>
	
	<addressOffset>0x0000005a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>MGAIN_COMP_VAL</name>
	<description>Intermediate main_cmp_count value</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_COMP_VAL6_REG</name>
	
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>MGAIN_COMP_VAL</name>
	<description>Intermediate main_cmp_count value</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_COMP_VAL7_REG</name>
	
	<addressOffset>0x0000005e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>MGAIN_COMP_VAL</name>
	<description>Intermediate main_cmp_count value</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_CTRL2_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000090</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>MSK_GAINCAL_LONG</name>
	<description>Run MSK gain calibration for 7 steps instead of 6 steps.
0: 5 (MGAIN_MODE_SEL = 0) or 6 (MGAIN_MODE_SEL = 1) steps
1: 6 (MGAIN_MODE_SEL = 0) or 7 (MGAIN_MODE_SEL = 1) steps</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>MGAIN_MODE_SEL</name>
	<description>0) Use DA14680AA/AC method for binary search of MGAIN calibration. Only odd values for Mgain are found
1) Use new mode, where the comparator results are evaluated. Take the noisiest values. 

</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>MGAIN_TRANSMIT_LENGTH</name>
	<description>Number of symbols for transmit0 and transmit1 length during mgain calibration. </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_CTRL3_REG</name>
	
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000070</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>GFSK_GAIN_OFFSET</name>
	<description>Unsigned number, to be added to GAUSS_GAIN before supplying to the multiplier.
This value is used when the TXDAC is used in BLE mode.
</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_CTRL_BLE_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001403</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields>
	<field>
	<name>MGAIN_AVER</name>
	<description>Average over a number of comparator output values
0: 1 value
1: 3 values
2: 5 values
3: 7 values </description>
	<access>read-write</access>
	<bitRange>[12:11]</bitRange>
	
</field><field>
	<name>MGAIN_CMP_INV</name>
	<description>Invert the output of the modulation gain comparator before usage. </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>BLE_TESTPAT_GEN</name>
	<description>Enable the BLE testpattern generator.
Bitstream can be controlled using RF_MSKMOD_CHIPL/H_REG</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>GAUSS_GAIN_SEL</name>
	<description>0: Normal operation
1: Use GAUSS_GAIN_WR for the modulation gain </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>GAUSS_GAIN_WR</name>
	<description>Externally provided modulation gain value </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGAIN_CTRL_FTDF_REG</name>
	
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00007000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MSK_GAIN_OFFSET</name>
	<description>Unsigned number, to be added to MSK_GAIN before supplying to the multiplier
</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>MSK_GAIN_SEL</name>
	<description>0: Normal operation
1: Use MSK_GAIN_WR for the modulation gain </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>MSK_GAIN_WR</name>
	<description>Externally provided modulation gain value </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MSKMOD_CHIPH_REG</name>
	<description>MSK modulator CHIP control upper 16 bit</description>
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000744a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MSK_CHIPH</name>
	
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MSKMOD_CHIPL_REG</name>
	<description>MSK modulator CHIP control lower 16 bit</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000c39b</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MSK_CHIPL</name>
	
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MSKMOD_CTRL1_REG</name>
	<description>MSK modulator control register</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>MSK_BYPASS_PHASE</name>
	<description>Bypass the phase calculation.
When set to '1', the CHIP codes are used directly for modulation</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>TX_MOD_FROM_GPIO</name>
	<description>Bypass the DAC modulation generation, and take data from GPIO pins TBD</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>MSK_ALW_EN</name>
	<description>Always enable the clock to the MSK modulator.
'0' = enable equals (ftdf_mode and synth_enable)</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>MSK_TX_SEL</name>
	<description>Select TX_DATA/TX_VALID
0: TX_DATA/TX_VALID from FTDF mac
1: TX_DATA/TX_VALID from RF_MSKMOD_CTRL2_REG</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>TX_VALID</name>
	<description>Test value for TX_VALID</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>TX_DATA</name>
	<description>Test value for TX_DATA</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_NMD_OFFSET_REG</name>
	<description>Offset values for phase alignment after VCO calibration.</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>NMD_OFFSET_PLL96M</name>
	<description>Signed 8-bit offset value to be added to plldig nmd output when 96MHz pll clock is selected for the digital, so that the initial phase difference between MD_clk and pll_fref_clk is compensated.</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>NMD_OFFSET_XTAL16M</name>
	<description>Signed 8-bit offset value to be added to plldig nmd output when 16MHz xtal clock is selected for the digital, so that the initial phase difference between MD_clk and pll_fref_clk is compensated.</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PULSE_CTRL_REG</name>
	
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000099</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>FTDF_PULSE_GAIN</name>
	<description>Scaling factor = 16 + FTDF_PULSE_GAIN</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>FTDF_LOWPASS_EN</name>
	<description>Enabling of the lowpass filter in the digital modulation path.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>FTDF_PULSE_GATE</name>
	<description>Number of initial output samples that are gated.</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>FTDF_PULSE_SEL</name>
	<description>0: MSK modulation
1: CPM modulation</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PULSE_TBL_0_REG</name>
	
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000012</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>FTDF_PULSE_VAL</name>
	<description>Modulation frequency = FTDF_PULSE_VAL/16384 * 16 MHz.
Range (Hz): -1.0e6:+976.5625:+1.0e6-976.5625.</description>
	<access>read-write</access>
	<bitRange>[10:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PULSE_TBL_1_REG</name>
	
	<addressOffset>0x00000062</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000272</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>FTDF_PULSE_VAL</name>
	<description>Modulation frequency = FTDF_PULSE_VAL/16384 * 16 MHz.
Range (Hz): -1.0e6:+976.5625:+1.0e6-976.5625.</description>
	<access>read-write</access>
	<bitRange>[10:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PULSE_TBL_2_REG</name>
	
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000027c</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>FTDF_PULSE_VAL</name>
	<description>Modulation frequency = FTDF_PULSE_VAL/16384 * 16 MHz.
Range (Hz): -1.0e6:+976.5625:+1.0e6-976.5625.</description>
	<access>read-write</access>
	<bitRange>[10:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PULSE_TBL_3_REG</name>
	
	<addressOffset>0x00000066</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000020e</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>FTDF_PULSE_VAL</name>
	<description>Modulation frequency = FTDF_PULSE_VAL/16384 * 16 MHz.
Range (Hz): -1.0e6:+976.5625:+1.0e6-976.5625.</description>
	<access>read-write</access>
	<bitRange>[10:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PULSE_TBL_4_REG</name>
	
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001ed</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>FTDF_PULSE_VAL</name>
	<description>Modulation frequency = FTDF_PULSE_VAL/16384 * 16 MHz.
Range (Hz): -1.0e6:+976.5625:+1.0e6-976.5625.</description>
	<access>read-write</access>
	<bitRange>[10:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PULSE_TBL_5_REG</name>
	
	<addressOffset>0x0000006a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001f8</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>FTDF_PULSE_VAL</name>
	<description>Modulation frequency = FTDF_PULSE_VAL/16384 * 16 MHz.
Range (Hz): -1.0e6:+976.5625:+1.0e6-976.5625.</description>
	<access>read-write</access>
	<bitRange>[10:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PULSE_TBL_6_REG</name>
	
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000201</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>FTDF_PULSE_VAL</name>
	<description>Modulation frequency = FTDF_PULSE_VAL/16384 * 16 MHz.
Range (Hz): -1.0e6:+976.5625:+1.0e6-976.5625.</description>
	<access>read-write</access>
	<bitRange>[10:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PULSE_TBL_7_REG</name>
	
	<addressOffset>0x0000006e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>FTDF_PULSE_VAL</name>
	<description>Modulation frequency = FTDF_PULSE_VAL/16384 * 16 MHz.
Range (Hz): -1.0e6:+976.5625:+1.0e6-976.5625.</description>
	<access>read-write</access>
	<bitRange>[10:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_CTRL1_BLE_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00002962</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>PLL_HSI_POL</name>
	<description>High Side Injection polarity
0: LO frequency is lower than the wanted RF frequency
1: LO frequency is higher than the wanted RF frequency </description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>CS</name>
	<description>Channel Spacing
0: 1MHz
1: 2MHz </description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>SGN</name>
	<description>Sign bit for the channel step
0: positive
1: negative </description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>CHANNEL_ZERO</name>
	<description>Channel 0 frequency in MHz </description>
	<access>read-write</access>
	<bitRange>[11:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_CTRL1_FTDF_REG</name>
	
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000965</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>PLL_HSI_POL</name>
	<description>High Side Injection polarity
0: LO frequency is lower than the wanted RF frequency
1: LO frequency is higher than the wanted RF frequency </description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>CS</name>
	<description>Channel Spacing
0: 2.5MHz
1: 5MHz </description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>SGN</name>
	<description>Sign bit for the channel step
0: positive
1: negative </description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>CHANNEL_ZERO</name>
	<description>Channel 0 frequency in MHz </description>
	<access>read-write</access>
	<bitRange>[11:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_CTRL2_BLE_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000108b</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>BLE_DAC_SEL</name>
	<description>Bit to select if the Gauss-DAC or TX-DAC is used for the BLE mode
'0' - Use Gauss-DAC
'1' - Use TX-DAC
</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>BT_SEL</name>
	<description>0: BT = 0.5; 1: BT = 0.6 </description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>EO_PACKET_DIS</name>
	<description>Disable the end of packet detection

0: End of packet detection enabled
1: End of pakcet detection disabled </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TXDATA_INV</name>
	<description>Select polarity of the modulation prior to the pulse shaping
0: Normal operation
1: Invert the modulation signal </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>GAUSS_86</name>
	<description>Select the output resolution in the analog signal path
0: 8 bit resolution for the shaping signal
1: 6 bit resolution for the shaping signal </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>GAUSS_INV</name>
	<description>Select polarity of the analog modulation path
0: Normal operation
1: Invert the signal in the analog signal path </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>GAUSS_DELAY</name>
	<description>Additional delay in analog signal path in RCLK cycles

When using Gauss-DAC 

0x0 - no delay
0x1 - 1 cycle delay
0x2 - 2 cycles delay
0x3 - 3 cycles delay

When using TX-DAC.

0x0 - 1 cycle delay
0x1 - 2 cycles delay

</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>MODINDEX</name>
	<description>Modulation Index selection
0:h = 1/2 (&#206;&#148;f = 250 kHz)
1: Modulation to SDM disabled.
2: h = 17/32 (&#206;&#148;f = 266 kHz)
3: h = 35/64 (&#206;&#148;f = 273 kHz) </description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>SD_ORDER_TX</name>
	<description>Order of the sigma-delta modulator in TX mode </description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>SD_ORDER_RX</name>
	<description>Order of the sigma-delta modulator in RX mode </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_CTRL2_FTDF_REG</name>
	
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000b</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>TXDATA_INV</name>
	<description>Select polarity of the modulation prior to the pulse shaping
0: Normal operation
1: Invert the modulation signal </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>GAUSS_INV</name>
	
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>TXDAC_DELAY</name>
	<description>Additional delay in analog signal path in RCLK cycles when in FTDF mode

0x0 - 1 clock cycle delay
0x1 - 2 clock cycles delay </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>MODINDEX</name>
	<description>
0x1 - Modulation to the SDM disabled, other modindex from pulse shaper.

</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>SD_ORDER_TX</name>
	<description>Order of the sigma-delta modulator in TX mode </description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>SD_ORDER_RX</name>
	<description>Order of the sigma-delta modulator in RX mode </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_CTRL3_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ZIF_MODE_EN</name>
	<description>Zero-IF testmode</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>MODVAL_SEL</name>
	<description>0: Normal operation
1: Use the externally provided value for the modulation </description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>MODVAL_WR</name>
	<description>Externally provided modulation value in 2s complement
&#206;&#148;f = 16 MHz x MODVAL_WR/16348 </description>
	<access>read-write</access>
	<bitRange>[13:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_RESULT2_BLE_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001480</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CN_CAL_RD</name>
	<description>Result of the modulation gain calibration (Retained) </description>
	<access>read-only</access>
	<bitRange>[13:8]</bitRange>
	
</field><field>
	<name>GAUSS_GAIN_RD</name>
	<description>Modulation gain after KMOD_ALPHA trimming (Not Retained) </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_RESULT2_FTDF_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000080</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MSK_GAIN_RD</name>
	<description>Modulation gain after KMOD_ALPHA trimming and adding the offset</description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_RESULT3_FTDF_REG</name>
	
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>CN_CAL_FTDF_RD</name>
	<description>Result of the modulation gain calibration (Retained) </description>
	<access>read-only</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_RESULT_BLE_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000820</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>VCO_FREQTRIM_RD</name>
	<description>Result of the VCO calibration (Not Retained) </description>
	<access>read-only</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>GAUSS_GAIN_CAL_RD</name>
	<description>Result of the modulation gain calibration (Retained) </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_RESULT_FTDF_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x0000f07f</resetMask>
	<fields>
	<field>
	<name>MSK_GAIN_CAL_RD</name>
	<description>Result of the modulation gain calibration (Retained) </description>
	<access>read-only</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SYNTH_SPARE_REG</name>
	<description>MSK modulator control register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>SPARE</name>
	<description>spare registers for future use. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TXDAC_TEST_REG</name>
	<description>Register to provide value to TXDAC</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>RF_TXDAC_TEST_SEL</name>
	<description>When RF_TXDAC_TEST_SEL = 0, use normal provided value
When RF_TXDAC_TEST_SEL = 1, use the value provided by RF_TXDAC_TEST_WR
</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>RF_TXDAC_TEST_WR</name>
	<description>Register to manually provide a value to the TX-DAC.


</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_VCOCAL_CTRL_REG</name>
	
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000c3</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>VCOCAL_MD_STATE_DLY_SEL</name>
	<description>Extend the MD counter enable for 1 or 2 clock cycles.
0 (default): Extend by 2 clock cyles
1: Extend 1 clock cycles </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>VCOCAL_PERIOD</name>
	<description>Length of a VCO calibration step
0: 1 us
1: 2 us
2: 3 us
3: 4 us </description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>VCO_FREQTRIM_SEL</name>
	<description>0b00: use calibrated value
0b01: use calibrated value, offsetted with -1
0b10: use VCO_FREQTRIM_WR
0b11: use calcap from LUT/phyattr</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>VCO_FREQTRIM_WR</name>
	<description>Externally provided VCO calibration value </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_VCO_CALCAP_BIT14_REG</name>
	
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000d59d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>VCO_CALCAP_BIT14</name>
	<description>LUT entry for bit 14 of the VCO calibration capacitance </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_VCO_CALCAP_BIT15_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>VCO_CALCAP_BIT15</name>
	<description>LUT entry for bit 15 of the VCO calibration capacitance </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_VCO_FREQ_EST_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000700</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>VCO_FREQ_EST_UPPER_RD</name>
	<description>MDSTATE_RD[18:16]
(MDSTATE_RD[15:0] shall be read from the RF_CALTRIM_STEP4_REG).</description>
	<access>read-only</access>
	<bitRange>[10:8]</bitRange>
	
</field><field>
	<name>VCO_FREQ_EST_LEN</name>
	<description>Set the length of enabling of the calibration counter (MD counter) in terms of 8us.
Eg: If it is set to 12, then the calibration caounter will be enabled for 12x8us = 96us</description>
	<access>read-write</access>
	<bitRange>[7:1]</bitRange>
	
</field><field>
	<name>VCO_FREQ_EST_EN</name>
	<description>Enable the usage of calibration counter for frequency estimation.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>QSPIC</name>
	<version>1.0</version>
	<description>QSPIC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x0c000000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>68</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>QSPIC_BURSTBRK_REG</name>
	<description>Read break sequence in Auto mode</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_SEC_HF_DS</name>
	<description>Disable output during the transmission of the second half (QSPIC_BRK_WRD[3:0]). Setting this bit is only useful if QSPIC_BRK_EN =1 and QSPIC_BRK_SZ= 1.
0 - The controller drives the QSPI bus during the transmission of the QSPIC_BRK_WRD[3:0].
1 - The controller leaves the QSPI bus in Hi-Z during the transmission of the QSPIC_BRK_WORD[3:0].</description>
	<access>read-write</access>
	<bitRange>[20:20]</bitRange>
	
</field><field>
	<name>QSPIC_BRK_TX_MD</name>
	<description>The mode of the QSPI Bus during the transmission of the burst break sequence.
00 - Single
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[19:18]</bitRange>
	
</field><field>
	<name>QSPIC_BRK_SZ</name>
	<description>The size of Burst Break Sequence
0 - One byte (Send QSPIC_BRK_WRD[15:8])
1 - Two bytes (Send QSPIC_BRK_WRD[15:0])</description>
	<access>read-write</access>
	<bitRange>[17:17]</bitRange>
	
</field><field>
	<name>QSPIC_BRK_EN</name>
	<description>Controls the application of a special command (read burst break sequence) that is used in order to force the device to abandon the continuous read mode.
0 - The special command is not applied
1 - The special command is applied

This special command is applied by the controller to the external device under the following conditions:
- the controller is in Auto mode
- the QSPIC_INST_MD = 1
- the previous command that has been applied in the external device was read
- the controller want to apply to the external device a command different than the read.</description>
	<access>read-write</access>
	<bitRange>[16:16]</bitRange>
	
</field><field>
	<name>QSPIC_BRK_WRD</name>
	<description>This is the value of a special command (read burst break sequence) that is applied by the controller to the external memory device, in order to force the memory device to abandon the continuous read mode.</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_BURSTCMDA_REG</name>
	<description>The way of reading in Auto mode (command register A)</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_DMY_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Dummy bytes phase.
00 - Single SPI
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[31:30]</bitRange>
	
</field><field>
	<name>QSPIC_EXT_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Extra Byte phase.
00 - Single SPI
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[29:28]</bitRange>
	
</field><field>
	<name>QSPIC_ADR_TX_MD</name>
	<description>It describes the mode of the SPI bus during the address phase.
00 - Single SPI
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[27:26]</bitRange>
	
</field><field>
	<name>QSPIC_INST_TX_MD</name>
	<description>It describes the mode of the SPI bus during the instruction phase.
00 - Single SPI
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[25:24]</bitRange>
	
</field><field>
	<name>QSPIC_EXT_BYTE</name>
	<description>The value of an extra byte which will be transferred after address (only if QSPIC_EXT_BYTE_EN= 1). Usually this is the Mode Bits in Dual/Quad SPI I/O instructions.</description>
	<access>read-write</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>QSPIC_INST_WB</name>
	<description>IInstruction Value for Wrapping Burst. This value is the selected instruction when QSPIC_WRAP_MD is equal to 1 and the access is a wrapping burst of length and size described by the bit fields QSPIC_WRAP_LEN and QSPIC_WRAP_SIZE respectively.</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>QSPIC_INST</name>
	<description>Instruction Value for Incremental Burst or Single read access. This value is the selected instruction at the cases of incremental burst or single read access. Also this value is used when a wrapping burst is not supported (QSPIC_WRAP_MD)</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_BURSTCMDB_REG</name>
	<description>The way of reading in Auto mode (command register B)</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_DMY_FORCE</name>
	<description>By setting this bit, the number of dummy bytes is forced to be equal to 3. In this case the QSPIC_DMY_NUM field is overruled and has no function.
0 - The number of dummy bytes is controlled by the QSPIC_DMY_NUM field
1 - Three dummy bytes are used. The QSPIC_DMY_NUM is overruled.</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>QSPIC_CS_HIGH_MIN</name>
	<description>Between the transmissions of two different instructions to the flash memory, the SPI bus stays in idle state (QSPI_CS high) for at least this number of QSPI_SCK clock cycles. See the QSPIC_ERS_CS_HI register for some exceptions.</description>
	<access>read-write</access>
	<bitRange>[14:12]</bitRange>
	
</field><field>
	<name>QSPIC_WRAP_SIZE</name>
	<description>It describes the selected data size of a wrapping burst (QSPIC_WRAP_MD).
00 - byte access (8-bits)
01 - half word access (16 bits)
10 - word access (32-bits)
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[11:10]</bitRange>
	
</field><field>
	<name>QSPIC_WRAP_LEN</name>
	<description>It describes the selected length of a wrapping burst (QSPIC_WRAP_MD).
00 - 4 beat wrapping burst
01 - 8 beat wrapping burst
10 - 16 beat wrapping burst
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>QSPIC_WRAP_MD</name>
	<description>Wrap mode
0 - The QSPIC_INST is the selected instruction at any access.
1 - The QSPIC_INST_WB is the selected instruction at any wrapping burst access of length and size described by the registers QSPIC_WRAP_LEN and QSPIC_WRAP_SIZE respectively. In all other cases the QSPIC_INST is the selected instruction. Use this feature only when the serial FLASH memory supports a special instruction for wrapping burst access.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>QSPIC_INST_MD</name>
	<description>Instruction mode
0 - Transmit instruction at any burst access.
1 - Transmit instruction only in the first access after the selection of Auto Mode.</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>QSPIC_DMY_NUM</name>
	<description>Number of Dummy Bytes

00 - Zero Dummy Bytes (Don't Send Dummy Bytes)
01 - Send 1 Dummy Byte
10 - Send 2 Dummy Bytes
11 - Send 4 Dummy Bytes

When QSPIC_DMY_FORCE is enabled, the QSPIC_DMY_NUM is overruled. In this case the number of dummy bytes is defined by the QSPIC_DMY_FORCE and is equal to 3, independent of the value of the QSPIC_DMY_NUM.</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>QSPIC_EXT_HF_DS</name>
	<description>Extra Half Disable Output
0 - if QSPIC_EXT_BYTE_EN=1, is transmitted the complete QSPIC_EXT_BYTE
1 - if QSPIC_EXT_BYTE_EN=1, the output is disabled (hi-z) during the transmission of bits [3:0] of QSPIC_EXT_BYTE</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>QSPIC_EXT_BYTE_EN</name>
	<description>Extra Byte Enable
0 - Don't Send QSPIC_EXT_BYTE
1 - Send QSPIC_EXT_BYTE</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>QSPIC_DAT_RX_MD</name>
	<description>It describes the mode of the SPI bus during the data phase.
00 - Single SPI
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_CHCKERASE_REG</name>
	<description>Check erase progress in Auto mode</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_CHCKERASE</name>
	<description>Writing any value to this register during erasing, forces the controller to read the flash memory status register. Depending on the value of the Busy bit, it updates the QSPIC_ERASE_EN.</description>
	<access>write-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_CTRLBUS_REG</name>
	<description>SPI Bus control register for the Manual mode</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_DIS_CS</name>
	<description>Write 1 to disable the chip select (active low) when the controller is in Manual mode.</description>
	<access>write-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>QSPIC_EN_CS</name>
	<description>Write 1 to enable the chip select (active low) when the controller is in Manual mode. </description>
	<access>write-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>QSPIC_SET_QUAD</name>
	<description>Write 1 to set the bus mode in Quad mode when the controller is in Manual mode.</description>
	<access>write-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>QSPIC_SET_DUAL</name>
	<description>Write 1 to set the bus mode in Dual mode when the controller is in Manual mode.</description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>QSPIC_SET_SINGLE</name>
	<description>Write 1 to set the bus mode in Single SPI mode when the controller is in Manual mode.</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_CTRLMODE_REG</name>
	<description>Mode Control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_USE_32BA</name>
	<description>Controls the length of the address that the external memory device uses.
0 - The external memory device uses 24 bits address.
1 - The external memory device uses 32 bits address.
The controller uses this bit in order to decide the number of the address bytes that has to transfer to the external device during Auto mode.</description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>QSPIC_FORCENSEQ_EN</name>
	<description>Controls the way with which is addressed by the QSPI controller a burst request from the AMBA bus.

0: The controller translates a burst access on the AMBA bus as a burst access on the QSPI bus. That results to the minimum number of command/address phases.
1: The controller will split a burst access on the AMBA bus into a number of single accesses on the QSPI bus. That results to a separate command for each beat of the burst. E.g a 4-beat word incremental AMBA read access will be split into 4 different sequences on the QSPI bus: command/address/extra clock/read data. The QSPI_CS will be low only for the time that is needed for each of these single accesses.

This configuration bit is usefull when the clock frequency of the QSPI bus is much higher than the clock of the AMBA bus. In this case the interval for which the CS remains low is minimized, achieving lower power dissipation with respect of the case where the QSPIC_FORCENSEQ_EN=0, at cost of performance.</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>QSPIC_PCLK_MD</name>
	<description>Read pipe clock delay relative to the falling edge of QSPI_SCK.
Refer to QSPI Timing for timing parameters and recommended values: 0 to 7</description>
	<access>read-write</access>
	<bitRange>[11:9]</bitRange>
	
</field><field>
	<name>QSPIC_RPIPE_EN</name>
	<description>Controls the use of the data read pipe.
0 = The read pipe is disabled; the sampling clock is defined according to the QSPIC_RXD_NEG setting.
1 = The read pipe is enabled. The delay of the sampling clock is defined according to the QSPI_PCLK_MD setting. (Recommended)</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>QSPIC_RXD_NEG</name>
	<description>Defines the clock edge that is used for the capturing of the received data, when the read pipe is not active (QSPIC_RPIPE_EN = 0).

0: Sampling of the received data with the positive edge of the QSPI_SCK
1: Sampling of the received data with the negative edge of the QSPI_SCK

The internal QSPI_SCK clock that is used by the controller for the capturing of the received data has a skew in respect of the QSPI_SCK that is received by the external memory device. In order to be improved the timing requirements of the read path, the controller supports a read pipe register with programmable clock delay. See also the QSPIC_RPIPE_EN register.</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>QSPIC_HRDY_MD</name>
	<description>This configuration bit is useful when the frequency of the QSPI clock is much lower than the clock of the AMBA bus, in order to not locks the AMBA bus for a long time.

0: Adds wait states via hready signal when an access is performed on the QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers. It is not needed to checked the QSPIC_BUSY of the QSPIC_STATUS_REG.
1: The controller don't adds wait states via the hready signal, when is performed access on the QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers. The QSPIC_BUSY bit of the QSPIC_STATUS_REG must be checked in order to be detected the completion of the requested access.

It is applicable only when the controller is in Manual mode. In the case of the Auto mode, the controller always adds wait states via the hready signal.</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>QSPIC_IO3_DAT</name>
	<description>The value of QSPI_IO3 pad if QSPI_IO3_OEN is 1</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>QSPIC_IO2_DAT</name>
	<description>The value of QSPI_IO2 pad if QSPI_IO2_OEN is 1</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>QSPIC_IO3_OEN</name>
	<description>QSPI_IO3 output enable. Use this only in SPI or Dual SPI mode to control /HOLD signal. When the Auto Mode is selected (QSPIC_AUTO_MD = 1) and the QUAD SPI is used, set this bit to zero.
0: The QSPI_IO3 pad is input.
1: The QSPI_IO3 pad is output.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>QSPIC_IO2_OEN</name>
	<description>QSPI_IO2 output enable. Use this only in SPI or Dual SPI mode to control /WP signal. When the Auto Mode is selected (QSPIC_AUTO_MD = 1) and the QUAD SPI is used, set this bit to zero.
0: The QSPI_IO2 pad is input.
1: The QSPI_IO2 pad is output.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>QSPIC_CLK_MD</name>
	<description>Mode of the generated QSPI_SCK clock
0: Use Mode 0 for the QSPI_CLK. The QSPI_SCK is low when QSPI_CS is high.
1: Use Mode 3 for the QSPI_CLK. The QSPI_SCK is high when QSPI_CS is high.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>QSPIC_AUTO_MD</name>
	<description>Mode of operation
0: The Manual Mode is selected.
1: The Auto Mode is selected.
During an erasing the QSPIC_AUTO_MD goes in read only mode (see QSPIC_ERASE_EN)</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_DUMMYDATA_REG</name>
	<description>Send dummy clocks to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_DUMMYDATA</name>
	<description>Writing to this register generates a number of clock pulses to the SPI bus. During the last clock of this activity in the SPI bus, the QSPI_IOx data pads are in hi-z state. The data size of the access to this register can be 32-bits / 16-bits/ 8-bits. The number of generated pulses is equal to: (size of AHB bus access) / (size of SPI bus). The size of SPI bus is equal to 1, 2 or 4 for Single, Dual or Quad SPI mode respectively.
This register has meaning only when the controller is in Manual mode.</description>
	<access>write-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_ERASECMDA_REG</name>
	<description>The way of erasing in Auto mode (command register A)</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_RES_INST</name>
	<description>The code value of the erase resume instruction</description>
	<access>read-write</access>
	<bitRange>[31:24]</bitRange>
	
</field><field>
	<name>QSPIC_SUS_INST</name>
	<description>The code value of the erase suspend instruction.</description>
	<access>read-write</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>QSPIC_WEN_INST</name>
	<description>The code value of the write enable instruction.</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>QSPIC_ERS_INST</name>
	<description>The code value of the erase instruction.</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_ERASECMDB_REG</name>
	<description>The way of erasing in Auto mode (command register B)</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_RESSUS_DLY</name>
	<description>Defines a timer that counts the minimum allowed delay between an erase suspend command and the previous erase resume command (or the initial erase command).
0 = Dont wait. The controller starts immediately to suspend the erase procedure.
1..63 = The controller waits for at least this number of 222kHz clock cycles before the suspension of erasing. Time starts counting after the end of the previous erase resume command (or the initial erase command)</description>
	<access>read-write</access>
	<bitRange>[29:24]</bitRange>
	
</field><field>
	<name>QSPIC_ERSRES_HLD</name>
	<description>The controller must stay without flash memory reading requests for this number of AMBA hclk clock cycles, before to perform the command of erase or erase resume
15 - 0</description>
	<access>read-write</access>
	<bitRange>[19:16]</bitRange>
	
</field><field>
	<name>QSPIC_ERS_CS_HI</name>
	<description>After the execution of instructions: write enable, erase, erase suspend and erase resume, the QSPI_CS remains high for at least this number of qspi bus clock cycles.</description>
	<access>read-write</access>
	<bitRange>[14:10]</bitRange>
	
</field><field>
	<name>QSPIC_EAD_TX_MD</name>
	<description>The mode of the QSPI Bus during the address phase of the erase instruction
00 - Single
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>QSPIC_RES_TX_MD</name>
	<description>The mode of the QSPI Bus during the transmission of the resume instruction
00 - Single
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>QSPIC_SUS_TX_MD</name>
	<description>The mode of the QSPI Bus during the transmission of the suspend instruction.
00 - Single
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>QSPIC_WEN_TX_MD</name>
	<description>The mode of the QSPI Bus during the transmission of the write enable instruction.
00 - Single
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>QSPIC_ERS_TX_MD</name>
	<description>The mode of the QSPI Bus during the instruction phase of the erase instruction
00 - Single
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_ERASECTRL_REG</name>
	<description>QSPI Erase control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_ERS_STATE</name>
	<description>It shows the progress of sector/block erasing (read only).
000 = No Erase.
001 = Pending erase request
010 = Erase procedure is running
011 = Suspended Erase procedure
100 = Finishing the Erase procedure
101..111 = Reserved</description>
	<access>read-only</access>
	<bitRange>[27:25]</bitRange>
	
</field><field>
	<name>QSPIC_ERASE_EN</name>
	<description>During Manual mode (QSPIC_AUTO_MD = 0). This bit is in read only mode.
During Auto mode (QSPIC_AUTO_MD = 1). To request the erasing of the block/sector (QSPIC_ERS_ADDR, 12'b0) write 1 to this bit. This bit is cleared automatically with the end of the erasing. Until the end of erasing the QSPIC_ERASE_EN remains in read only mode. During the same period of time the controller remains in Auto Mode (QSPIC_AUTO_MD goes in read only mode).</description>
	<access>read-write</access>
	<bitRange>[24:24]</bitRange>
	
</field><field>
	<name>QSPIC_ERS_ADDR</name>
	<description>Defines the address of the block/sector that is requested to be erased.
If QSPIC_USE_32BA = 0 (24 bits addressing), bits QSPIC_ERASECTRL_REG[23-12] determine the block/ sector address bits [23-12].
QSPIC_ERASECTRL_REG[11-4] are ignored by the controller.
If QSPIC_USE_32BA = 1 (32 bits addressing) bits QSPIC_ERASECTRL_REG[23-4] determine the block / sectors address bits [31:12]</description>
	<access>read-write</access>
	<bitRange>[23:4]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_GP_REG</name>
	<description>QSPI General Purpose control register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>QSPIC_PADS_SLEW</name>
	<description>QSPI pads slew rate control. Indicative values under certain conditions:
0: Rise=1.7 V/ns, Fall=1.9 V/ns (weak)
1: Rise=2.0 V/ns, Fall=2.3 V/ns
2: Rise=2.3 V/ns, Fall=2.6 V/ns
3: Rise=2.4 V/ns, Fall=2.7 V/ns (strong)
Conditions: FLASH pin capacitance 6 pF, Vcc=1.8V, T=25C and Idrive=16mA.</description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>QSPIC_PADS_DRV</name>
	<description>QSPI pads drive current
0: 4 mA
1: 8 mA
2: 12 mA
3: 16 mA</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_READDATA_REG</name>
	<description>Read data from SPI Bus for the Manual mode</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_READDATA</name>
	<description>A read access at this register generates a data transfer from the external memory device to the QSPIC controller. The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). The data size of the access to this register can be 32-bits / 16-bits / 8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_RECVDATA_REG</name>
	<description>Received data for the Manual mode</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_RECVDATA</name>
	<description>This register contains the received data when the QSPIC_READDATA_REG register is used in Manual mode, in order to be retrieved data from the external memory device and QSPIC_HRDY_MD=1 &amp;&amp; QSPIC_BUSY=0.</description>
	<access>read-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_STATUSCMD_REG</name>
	<description>The way of reading the status of external device in Auto mode</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_STSDLY_SEL</name>
	<description>Defines the timer which is used to count the delay that it has to wait before to read the FLASH Status Register, after an erase or an erase resume command.
0 - The delay is controlled by the QSPIC_RESSTS_DLY which counts on the qspi clock.
1 - The delay is controlled by the QSPIC_RESSUS_DLY which counts on the 222 kHz clock.</description>
	<access>read-write</access>
	<bitRange>[22:22]</bitRange>
	
</field><field>
	<name>QSPIC_RESSTS_DLY</name>
	<description>Defines a timer that counts the minimum required delay between the reading of the status register and of the previous erase or erase resume instruction.
0 - Dont wait. The controller starts to reading the Flash memory status register immediately.
1..63 - The controller waits for at least this number of QSPI_CLK cycles and afterwards it starts to reading the Flash memory status register. The timer starts to count after the end of the previous erase or erase resume command.

The actual timer that will be used by the controller before the reading of the Flash memory status register is defined by the QSPIC_STSDLY_SEL.</description>
	<access>read-write</access>
	<bitRange>[21:16]</bitRange>
	
</field><field>
	<name>QSPIC_BUSY_VAL</name>
	<description>Defines the value of the Busy bit which means that the flash is busy.
0 - The flash is busy when the Busy bit is equal to 0.
1 - The flash is busy when the Busy bit is equal to 1.</description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>QSPIC_BUSY_POS</name>
	<description>It describes who from the bits of status represents the
Busy bit (7 - 0).</description>
	<access>read-write</access>
	<bitRange>[14:12]</bitRange>
	
</field><field>
	<name>QSPIC_RSTAT_RX_MD</name>
	<description>The mode of the QSPI Bus during the receive status phase of the read status instruction
00 - Single
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[11:10]</bitRange>
	
</field><field>
	<name>QSPIC_RSTAT_TX_MD</name>
	<description>The mode of the QSPI Bus during the instruction phase of the read status instruction.
00 - Single
01 - Dual
10 - Quad
11 - Reserved</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>QSPIC_RSTAT_INST</name>
	<description>The code value of the read status instruction.
It is transmitted during the instruction phase of the read status instruction.</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_STATUS_REG</name>
	<description>The status register of the QSPI controller</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_BUSY</name>
	<description>The status of the SPI Bus.

0 - The SPI Bus is idle
1 - The SPI Bus is active. Read data, write data or dummy data activity is in progress.

Has meaning only in Manual mode and only when QSPIC_HRDY_MD = 1.</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_UCODE_START</name>
	<description>QSPIC uCode memory</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_UCODE_X</name>
	<description>The first position of the memory (16 words x 32 bits) where a microcode should be placed ( X = 0 to 15). This microcode describes the initialization process of the external flash device.</description>
	<access>read-write</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QSPIC_WRITEDATA_REG</name>
	<description>Write data to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>QSPIC_WRITEDATA</name>
	<description>Writing to this register is generating a data transfer from the controller to the external memory device. The data written in this register, is then transferred to the memory using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). The data size of the access to this register can be 32-bits / 16-bits/ 8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<access>write-only</access>
	<bitRange>[31:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>QUAD</name>
	<version>1.0</version>
	<description>QUAD registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001a00</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>10</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>QDEC_CLOCKDIV_REG</name>
	<description>Quad decoder clock divider register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>clock_divider</name>
	<description>Contains the number of the input clock cycles minus one, that are required to generate one logic clock cycle. </description>
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QDEC_CTRL_REG</name>
	<description>Quad decoder control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CHZ_PORT_EN</name>
	<description>'1' : Enable channel</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>CHY_PORT_EN</name>
	<description>'1' : Enable channel</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>CHX_PORT_EN</name>
	<description>'1' : Enable channel</description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>QD_IRQ_THRES</name>
	<description>The number of events on either counter (X or Y or Z) that need to be reached before an interrupt is generated. If 0 is written, then threshold is considered to be 1. </description>
	<access>read-write</access>
	<bitRange>[9:3]</bitRange>
	
</field><field>
	<name>QD_IRQ_STATUS</name>
	<description>Interrupt Status. If 1 an interrupt has occured. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>QD_IRQ_CLR</name>
	<description>Writing 1 to this bit clears the interrupt. This bit is autocleared </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>QD_IRQ_MASK</name>
	<description>0: interrupt is masked
1: interrupt is enabled </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QDEC_XCNT_REG</name>
	<description>Counter value of the X Axis</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>X_counter</name>
	<description>Contains a signed value of the events. Zero when channel is disabled </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QDEC_YCNT_REG</name>
	<description>Counter value of the Y Axis</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>Y_counter</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>QDEC_ZCNT_REG</name>
	<description>Counter value of the Z Axis</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>Z_counter</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFCU</name>
	<version>1.0</version>
	<description>RFCU registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50002000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>240</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>RF_ADCI_DC_OFFSET_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00008080</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ADC_OFFN_I_RD</name>
	<description>DC offset compensation in the I path (inverting input) in sign-magnitude notarion (i.e. -31 : 1 : 31 mV) </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ADC_OFFP_I_RD</name>
	<description>DC offset compensation in the I path (non-inverting input) in sign-magnitude notarion (i.e. -31 : 1 : 31 mV) </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ADCQ_DC_OFFSET_REG</name>
	<description>Must be Retained</description>
	<addressOffset>0x0000005a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00008080</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ADC_OFFN_Q_RD</name>
	<description>DC offset compensation in the Q path (inverting input) in sign-magnitude notarion (i.e. -31 : 1 : 31 mV) </description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ADC_OFFP_Q_RD</name>
	<description>DC offset compensation in the Q path (non-inverting input) in sign-magnitude notarion (i.e. -31 : 1 : 31 mV) </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ADC_CTRL1_REG</name>
	
	<addressOffset>0x0000008a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00006001</resetMask>
	<fields>
	<field>
	<name>ADC_SIGN</name>
	<description>Change polarity of ADC input. </description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>ADC_MUTE</name>
	<description>0: Normal operation
1: Short the inputs of the ADC (used for DC offset cal) </description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>ADC_DC_OFFSET_SEL</name>
	<description>0: Normal operation (i.e. Use automatically calibrated value)
1: Use ADC_OFFx_y_WR to set the DC offset compensation values in the ADC (x = N or P, y = I or Q </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ADC_CTRL2_REG</name>
	
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ADC_OFFN_I_WR</name>
	<description>External value for the DC offset compensation in the I path negative side. With common mode input voltage at Vpwrp/2, this value is 512-ADC_OFFP_Q_WR. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ADC_OFFP_I_WR</name>
	<description>External value for the DC offset compensation in the I path positive side. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ADC_CTRL3_REG</name>
	
	<addressOffset>0x0000008e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ADC_OFFN_Q_WR</name>
	<description>External value for the DC offset compensation in the Q path negative side. With common mode input voltage at Vpwrp/2, this value is 512-ADC_OFFP_Q_WR. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>ADC_OFFP_Q_WR</name>
	<description>External value for the DC offset compensation in the Q path positive side. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_AGC_EXT1_LUT_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>AGC_EXT_LUT</name>
	
	<access>read-write</access>
	<bitRange>[9:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_BIAS_CTRL1_BLE_REG</name>
	
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00006888</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IFF_BIAS_BLE_SET</name>
	<description>Tuning of the IF filter bias current when mode='BLE'</description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>VCO_BIAS_BLE_SET</name>
	<description>Tuning of the VCO bias current when mode='BLE'</description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>CP_BIAS_BLE_SET</name>
	<description>Tuning of the charge pump bias current when mode = 'BLE'</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>MIX_BIAS_BLE_SET</name>
	<description>Tuning of the mixer bias current when mode='BLE' </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_BIAS_CTRL1_FTDF_REG</name>
	
	<addressOffset>0x00000086</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000c888</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IFF_BIAS_FTDF_SET</name>
	<description>Tuning of the IF filter bias current when mode='FTDF'</description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>VCO_BIAS_FTDF_SET</name>
	<description>Tuning of the VCO bias current when mode='FTDF'</description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>CP_BIAS_FTDF_SET</name>
	<description>Tuning of the charge pump bias current when mode = 'FTDF'</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>MIX_BIAS_FTDF_SET</name>
	<description>Tuning of the mixer bias current when mode='FTDF' </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CALSTATE_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CALSTATE</name>
	<description>Value of the calstate state machine </description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CAL_CTRL_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>VCO_CAL_DIS</name>
	<description>Do not calibrate the VCO during Cal cycle </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>DC_OFFSET_CAL_DIS</name>
	<description>Do not calibrate the VGA2 Offset during Cal cycle </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>IFF_CAL_DIS</name>
	<description>Do not calibrate the IFF center frequency during Cal cycle </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>MGAIN_CAL_DIS</name>
	<description>Do not calibrate the VCO and Modulation Gain during Cal cycle </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>EO_CAL</name>
	<description>End of calibration trigger.
Reading returns the eo_cal status signal which can be cleared by writing to RF_IRQ_CTRL_REG.EO_CAL_CLEAR </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SO_CAL</name>
	<description>Start of calibration trigger.Writing a 1 starts calibration.1Reading returns the calibration status (1 = busy calibrating). </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CP_CTRL_BLE_REG</name>
	
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00007f7f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CP_CUR_BLE_TX</name>
	<description>CP current setting during PLL - Lock in TX mode
1111: 45 &#181;A (fastest, setting 0)
0111: 15 &#181;A (setting 1)
0011: 7.5 &#181;A (setting 2)
0001: 3.75 &#181;A (slowest, setting 3)
Intermediate values are possible (but not recommended). Calculate the effective value with:
bit 0: 3.75 &#181;A
bit 1: 3.75 &#181;A
bit 2: 7.5 &#181;A
bit 3: 30 &#181;A </description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>CP_CUR_BLE_RX</name>
	<description>CP current setting during PLL - lock in RX mode
same coding as for CP_CUR_TX </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>CP_CUR_SET_BLE_TX</name>
	<description>Chargepump current setting during PLL settling in TX mode
same coding as for CP_CUR_TX </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>CP_CUR_SET_BLE_RX</name>
	<description>Chargepump current setting during PLL settling in RX mode.
same coding as for CP_CUR_TX</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CP_CTRL_FTDF_REG</name>
	
	<addressOffset>0x0000009a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00007f7f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CP_CUR_FTDF_TX</name>
	<description>CP current setting during PLL - Lock in TX mode
1111: 45 &#181;A (fastest, setting 0)
0111: 15 &#181;A (setting 1)
0011: 7.5 &#181;A (setting 2)
0001: 3.75 &#181;A (slowest, setting 3)
Intermediate values are possible (but not recommended). Calculate the effective value with:
bit 0: 3.75 &#181;A
bit 1: 3.75 &#181;A
bit 2: 7.5 &#181;A
bit 3: 30 &#181;A </description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>CP_CUR_FTDF_RX</name>
	<description>CP current setting during PLL - lock in RX mode
same coding as for CP_CUR_TX </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>CP_CUR_SET_FTDF_TX</name>
	<description>Chargepump current setting during PLL settling in TX mode
same coding as for CP_CUR_TX </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>CP_CUR_SET_FTDF_RX</name>
	<description>Chargepump current setting during PLL settling in RX mode.
same coding as for CP_CUR_TX</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DIAGIRQ01_REG</name>
	<description>BLE/RF Diagnostic IRQ Control Register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007f7f</resetMask>
	<fields>
	<field>
	<name>DIAGIRQ_EDGE_1</name>
	<description>Same as DIAGIRQ_EDGE_0.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>DIAGIRQ_BSEL_1</name>
	<description>Same as DIAGIRQ_BSEL_0.</description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>DIAGIRQ_WSEL_1</name>
	<description>Same as DIAGIRQ_WSEL_0.</description>
	<access>read-write</access>
	<bitRange>[10:9]</bitRange>
	
</field><field>
	<name>DIAGIRQ_MASK_1</name>
	<description>Same as DIAGIRQ_MASK_0.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DIAGIRQ_EDGE_0</name>
	<description>Diagnostic IRQ Edge 0
Selects the edge of the selected bit (refer to DIAGIRQ_BSEL_0) that will trigger the assertion of DIAGIRQ_STAT_0.
If '0' then the positive edge is selected, when "1" the negative edge is selected.</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DIAGIRQ_BSEL_0</name>
	<description>Diagnostic IRQ Bit Select 0
Selects the bit of the 8-bit bus (as selected by the DIAGIRQ_WSEL_0) that will be used for the IRQ generation.</description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>DIAGIRQ_WSEL_0</name>
	<description>Diagnostic IRQ Word Select 0
Selects the 8-bit diagnostic bus that will be used for the IRQ generation.
00: Selects the BLE_DIAG0
01: Selects the BLE_DIAG1
10: Selects the RADIO_DIAG0
11: Selects the RADIO_DIAG1</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DIAGIRQ_MASK_0</name>
	<description>Diagnostic IRQ Mask 0
When set to "1" a BLE_RF_DIAG_IRQ will be generated on each rise of the DIAGIRQ_STAT_0 bit.
When cleared to "0" no IRQ will be generated.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DIAGIRQ23_REG</name>
	<description>BLE/RF Diagnostic IRQ Control Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00007f7f</resetMask>
	<fields>
	<field>
	<name>DIAGIRQ_EDGE_3</name>
	<description>Same as DIAGIRQ_EDGE_0.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>DIAGIRQ_BSEL_3</name>
	<description>Same as DIAGIRQ_BSEL_0.</description>
	<access>read-write</access>
	<bitRange>[13:11]</bitRange>
	
</field><field>
	<name>DIAGIRQ_WSEL_3</name>
	<description>Same as DIAGIRQ_WSEL_0.</description>
	<access>read-write</access>
	<bitRange>[10:9]</bitRange>
	
</field><field>
	<name>DIAGIRQ_MASK_3</name>
	<description>Same as DIAGIRQ_MASK_0.</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DIAGIRQ_EDGE_2</name>
	<description>Same as DIAGIRQ_EDGE_0.</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>DIAGIRQ_BSEL_2</name>
	<description>Same as DIAGIRQ_BSEL_0.</description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>DIAGIRQ_WSEL_2</name>
	<description>Same as DIAGIRQ_WSEL_0.</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>DIAGIRQ_MASK_2</name>
	<description>Same as DIAGIRQ_MASK_0.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DIAGIRQ_STAT_REG</name>
	<description>BLE/RF Diagnostic IRQ Status Register</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>DIAGIRQ_STAT_3</name>
	<description>Same as DIAGIRQ_STAT_0.</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>DIAGIRQ_STAT_2</name>
	<description>Same as DIAGIRQ_STAT_0.</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>DIAGIRQ_STAT_1</name>
	<description>Same as DIAGIRQ_STAT_0.</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>DIAGIRQ_STAT_0</name>
	<description>Diagnostic IRQ Status 0
This bit is read only. It is automatically cleared to "0" on each read of the BLE_RF_DIAGIRQ_REG register. It is automatically asserted to "1" on each detection of the selected edge, of the selected bit, of the selected word.</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DIV_IQ_RX_REG</name>
	<description>Bias trimming of IQ divider</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>DIV2_IQ_TRIM_RX_SPARE</name>
	<description>Function not defined yet</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DIV2_OFFP_TRIM_RX</name>
	<description>Trim value for 2 divider P-Most bias in RX mode</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>DIV2_OFFN_TRIM_RX</name>
	<description>Trim value for 2 divider N-Most bias in RX mode</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_DIV_IQ_TX_REG</name>
	<description>Bias trimming of IQ divider</description>
	<addressOffset>0x000000d6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields>
	<field>
	<name>DIV2_IQ_TRIM_TX_SPARE</name>
	<description>Function not defined yet</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>DIV2_OFFP_TRIM_TX</name>
	<description>Trim value for 2 divider P-Most bias in TX mode</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>DIV2_OFFN_TRIM_TX</name>
	<description>Trim value for 2 divider N-Most bias in TX mode</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_IFF_CAL_CAP_STAT_REG</name>
	<description>Current CAL_CAP value applied to IF</description>
	<addressOffset>0x000000ea</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>IF_CAL_CAP_RD</name>
	<description>Reset value is equal to the reset value of RF_IFF_RESULT_REG[IF_CAL_CAP_RD]</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_IFF_CC_BLE_SET1_REG</name>
	<description>Must be retained</description>
	<addressOffset>0x000000e2</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>IF_CAL_CAP_WR</name>
	<description>Retained WRITE value.
The result of the IF_CAL_CAP calibration should be copied from RF_IFF_RESULT_REG to this register
</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_IFF_CC_BLE_SET2_REG</name>
	<description>Must be retained</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>IF_CAL_CAP_WR</name>
	<description>Retained WRITE value.
The result of the IF_CAL_CAP calibration should be copied from RF_IFF_RESULT_REG to this register
</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_IFF_CC_FTDF_SET1_REG</name>
	<description>Must be retained</description>
	<addressOffset>0x000000e6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>IF_CAL_CAP_WR</name>
	<description>Retained WRITE value.
The result of the IF_CAL_CAP calibration should be copied from RF_IFF_RESULT_REG to this register
</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_IFF_CC_FTDF_SET2_REG</name>
	<description>Must be retained</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>IF_CAL_CAP_WR</name>
	<description>Retained WRITE value.
The result of the IF_CAL_CAP calibration should be copied from RF_IFF_RESULT_REG to this register
</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_IFF_CTRL1_REG</name>
	
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000f10</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields>
	<field>
	<name>IFF_COMPLEX_DIS</name>
	<description>Put IF-filter in lowpass configuration </description>
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>IF_SELECT_FSM</name>
	<description>'0': use one of the IFF_CC_BLE/FTDF_SET1/2, depending on FTDF_MODE and IF_SELSET_GT
'1': use the value from the calibration FSM</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>IF_SEL_SET2_GT</name>
	<description>Setting to control when IF_CAL_CAP_BLE/FTDF_SET2 is used.

If AGC &gt; IF_SEL_SET2_GT, SET2 is used.Else, SET1 is used.</description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>RO_TO_PINS</name>
	<description>'0': normal operation;
'1': Enable reference oscillator. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>IFF_DCOC_DAC_DIS</name>
	<description>Disable the DC offset current DAC </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>IF_MUTE</name>
	<description>'0': normal operation;
'1': Mute IFF by short circuit of VGA1 input.
Note: set TGATE_MIXER_IF to '0' for isolation from the IRM </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>IF_CAL_CAP</name>
	<description>Current value applied to IF_CAL_CAP</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_IFF_RESULT_REG</name>
	<description>Not retained</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000fc1f</resetMask>
	<fields>
	<field>
	<name>IF_CAL_CAP_RD</name>
	<description>IF calibration result capacitance.</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_IO_CTRL1_REG</name>
	
	<addressOffset>0x000000aa</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>RFIO_TRIM1_CAP</name>
	<description>Trim the RFIO input capacitance
00: Minimum capacitance
10: Nominal capacitance
1F: Maximal capacitance </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_IRQ_CTRL_REG</name>
	
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>EO_CAL_CLEAR</name>
	<description>Writing any value to this bit clears eo_cal interrupt. </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_LF_CAL_CAP_STAT_REG</name>
	<description>Current CAL_CAP value applied to IF</description>
	<addressOffset>0x000000ee</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000030</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>LF_SHORT_R4_RD</name>
	<description>The reset value should be equal to RF_LF_CTRL_REG[LF_SHORT_R4_BLE].</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>LF_CAL_CAP_RD</name>
	<description>The reset value should be equal to the reset value of RF_IFF_CC_BLE_SET1_REG.</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_LF_CTRL_REG</name>
	
	<addressOffset>0x000000a6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000c0</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields>
	<field>
	<name>LF_CAL_CAP_WR_FTDF</name>
	<description>External value for loop filter calibration capacitance for FTDF mode.</description>
	<access>read-write</access>
	<bitRange>[12:8]</bitRange>
	
</field><field>
	<name>LF_SHORT_R4_FTDF</name>
	<description>'0': R4 in place, '1': R4 shorted, C2 and C4 in parallel. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>LF_SHORT_R4_BLE</name>
	<description>'0': R4 in place, '1': R4 shorted, C2 and C4 in parallel. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>LF_CAL_CAP_SEL</name>
	<description>0: use IF_CAL_CAP_BLE/FTDF_SET1, depending on mode. LF_CAL_CAP_WR is added as offset.
1: use LF_CAL_CAP_WR directly</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>LF_CAL_CAP_WR_BLE</name>
	<description>External value for loop filter calibration capacitance for BLE mode.</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_LF_RES_CTRL_BLE_REG</name>
	<description>LF resistor setting in BLE mode</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00007f7f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LF_RES_BLE_TX</name>
	<description>Loopfilter resistor setting during PLL - Lock in TX mode
1xxx: 72 k (fastest, setting 0)
01xx: 120 k (setting 1)
001x: 168 k (setting2)
000x: 240 k (slowest, setting 3) </description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>LF_RES_BLE_RX</name>
	<description>Loopfilter resistor setting during PLL - Lock in RX mode
same coding as for LF_RES_TX </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>LF_RES_SET_BLE_TX</name>
	<description>Loopfilter resistor setting during PLL settling in TX mode

same coding as for LF_RES_TX </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>LF_RES_SET_BLE_RX</name>
	<description>Loopfilter resistor setting during PLL settling in RX mode
same coding as for LF_RES_TX </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_LF_RES_CTRL_FTDF_REG</name>
	<description>LF resistor setting in FTDF mode</description>
	<addressOffset>0x0000009e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00007f7f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LF_RES_FTDF_TX</name>
	<description>Loopfilter resistor setting during PLL - Lock in TX mode
1xxx: 72 k (fastest, setting 0)
01xx: 120 k (setting 1)
001x: 168 k (setting2)
000x: 240 k (slowest, setting 3) </description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>LF_RES_FTDF_RX</name>
	<description>Loopfilter resistor setting during PLL - Lock in RX mode
same coding as for LF_RES_TX </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>LF_RES_SET_FTDF_TX</name>
	<description>Loopfilter resistor setting during PLL settling in TX mode

same coding as for LF_RES_TX </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>LF_RES_SET_FTDF_RX</name>
	<description>Loopfilter resistor setting during PLL settling in RX mode
same coding as for LF_RES_TX </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_LNA_CTRL1_REG</name>
	
	<addressOffset>0x000000ac</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000024e</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>LNA_TRIM_CD_HF</name>
	<description>Trim the LNA output capacitance for CN &gt; 19
00: Minimum capacitance
10: Nominal capacitance
1F: Maximal capacitance </description>
	<access>read-write</access>
	<bitRange>[11:6]</bitRange>
	
</field><field>
	<name>LNA_TRIM_CD_LF</name>
	<description>Trim the LNA output capacitance for CN 00: Minimum capacitance
10: Nominal capacitance
1F: Maximal capacitance </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_LNA_CTRL2_REG</name>
	
	<addressOffset>0x000000ae</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000226</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>LNA_TRIM_GM_LO</name>
	<description>Trim the LNA bias resistor for optimum transcunductance (gain) in AGC settings 2 and 3
00: Minimum transconductance
10: Nominal transconductance
1F: Maximal transconductance </description>
	<access>read-write</access>
	<bitRange>[11:6]</bitRange>
	
</field><field>
	<name>LNA_TRIM_GM_HI</name>
	<description>Trim the LNA bias resistor for optimum transcunductance (gain) in AGC settings 0 and 1
00: Minimum transconductance
10: Nominal transconductance
1F: Maximal transconductance </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_LNA_CTRL3_REG</name>
	
	<addressOffset>0x000000b0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000007</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>LNA_TRIM_CGS</name>
	<description>Trim the LNA gate-source capacitance
00: Minimum capacitance
10: Nominal capacitance
1F: Maximal capacitance </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_LO_IQ_TRIM_REG</name>
	<description>Trim settings for IQ LO path</description>
	<addressOffset>0x000000d8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RF_LO_IQ_TRIM</name>
	<description>Trim settings for RX-IQ LO path</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MGC_CTRL_REG</name>
	
	<addressOffset>0x00000092</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>GAUSS_DAC_CTRL</name>
	<description>value 1X , Set the Gauss DAC output to high 'Z </description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>MGC_POLE_SW</name>
	<description>Switch in an aditional pole on the mgc amplifer to have extra filtering of the loopfilter voltage.
'0': no pole (bandwidth limited by the opamp)
'1': switch in pole to reduce amplifier bandwidth</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>MGC_GAIN_SET</name>
	<description>Set the desired gain for the mgc calibration amplifier.
'0': gain= 15x
'1': gain= 10x </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MIXER_CTRL1_BLE_REG</name>
	
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000035</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MIX_SPARE_BLE</name>
	<description>Spare registers for mixer control </description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>MIX_TRIM_VCM_BLE</name>
	<description>Trim the common mode voltage at the input of the TIA
0: Minimum voltage
8: Nominal voltage
F: Maximal voltage </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>MIX_TRIM_IBIAS_BLE</name>
	<description>Trim the bias current of the TIA
0: Minimum bias current
8: Nominal bias current
F: Maximal bias current </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>MIX_TRIM_GMBIAS_BLE</name>
	<description>Trim the Mixer bias resistor for optimum transcunductance
0: Minimum transconductance
8: Nominal transconductance
F: Maximal transconductance </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MIXER_CTRL1_FTDF_REG</name>
	
	<addressOffset>0x000000a2</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000035</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MIX_SPARE</name>
	<description>Spare registers for mixer control </description>
	<access>read-write</access>
	<bitRange>[15:12]</bitRange>
	
</field><field>
	<name>MIX_TRIM_VCM_FTDF</name>
	<description>Trim the common mode voltage at the input of the TIA
0: Minimum voltage
8: Nominal voltage
F: Maximal voltage </description>
	<access>read-write</access>
	<bitRange>[11:8]</bitRange>
	
</field><field>
	<name>MIX_TRIM_IBIAS_FTDF</name>
	<description>Trim the bias current of the TIA
0: Minimum bias current
8: Nominal bias current
F: Maximal bias current </description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>MIX_TRIM_GMBIAS_FTDF</name>
	<description>Trim the Mixer bias resistor for optimum transcunductance
0: Minimum transconductance
8: Nominal transconductance
F: Maximal transconductance </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MIXER_CTRL2_REG</name>
	
	<addressOffset>0x000000a4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields>
	<field>
	<name>MIX_CAL_CAP_WR_FTDF</name>
	<description>External value for calibration of mixer pole capacitance for FTDF mode.</description>
	<access>read-write</access>
	<bitRange>[10:6]</bitRange>
	
</field><field>
	<name>MIX_CAL_SELECT</name>
	<description>0: use IF_CAL_CAP_BLE/FTDF_SET1, depending on mode. MIX_CAL_CAP_WR is added as offset.
1: use MIX_CAL_CAP_WR directly</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>MIX_CAL_CAP_WR_BLE</name>
	<description>External value for calibration of mixer pole capacitance for BLE mode.</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_MIX_CAL_CAP_STAT_REG</name>
	<description>Current CAL_CAP value applied to IF</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>MIX_CAL_CAP_RD</name>
	<description>The reset value should be equal to the reset value of RF_IFF_CC_BLE_SET1_REG.</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_OVERRULE_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00004000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CN_FTDF_TIMES2</name>
	<description>If set, the CN applied to the dphy from the FTDF MAC is multiplied by 2.</description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>GAUSS_DAC_SEL</name>
	<description>Overrule GAUSS_DAC_SEL
0b01 = disabled.
0b1x = enabled.
0b00 = normal function</description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>TXDAC_SEL</name>
	<description>Overrule TXDAC_SEL
0b01 = disabled.
0b1x = enabled.
0b00 = normal function</description>
	<access>read-write</access>
	<bitRange>[11:10]</bitRange>
	
</field><field>
	<name>MIX_FTDF_OVR</name>
	<description>Overrule MIX_FTDF_EN
0b01 = disabled.
0b1x = enabled.
0b00 = normal function</description>
	<access>read-write</access>
	<bitRange>[9:8]</bitRange>
	
</field><field>
	<name>IFF_FTDF_OVR</name>
	<description>Overrule IFF_FTDF_EN
0b01 = disabled.
0b1x = enabled.
0b00 = normal function</description>
	<access>read-write</access>
	<bitRange>[7:6]</bitRange>
	
</field><field>
	<name>RF_MODE_OVR</name>
	<description>Overrule RF_MODE
0b01 = BLE mode.
0b1x = FTDF mode
0b00 = normal function</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>RX_EN_OVR</name>
	<description>Overrule RX_EN:
0b01 = disabled.
0b1x = enabled.
0b00 = normal function</description>
	<access>read-write</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>TX_EN_OVR</name>
	<description>Overrule TX_EN:
0b01 = disabled.
0b1x = enabled.
0b00 = normal function</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PA_CTRL_REG</name>
	<description>Removed obsolete values of bits 10:7, pa_pw back to 4</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00007a60</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields>
	<field>
	<name>LEVEL_LDO_RFPA</name>
	<description>Control for PA supply voltage (output power) </description>
	<access>read-write</access>
	<bitRange>[14:11]</bitRange>
	
</field><field>
	<name>PA_FAST_DISCHARGE_EN</name>
	<description>0 = fast discharge current source disabled
1 = fast discharge current source enabled</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>PA_RAMPSPEED_UP</name>
	<description>PA up ramping speed</description>
	<access>read-write</access>
	<bitRange>[8:7]</bitRange>
	
</field><field>
	<name>PA_RAMPSPEED_DOWN</name>
	<description>PA down Ramping speed setting of the driver stage:
'0x0': slowest (1.25 uA)
'0x1': 2x faster (2.5 uA)
'0x2': default ramping speed
'0x3': fastest </description>
	<access>read-write</access>
	<bitRange>[6:5]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PFD_CTRL_REG</name>
	
	<addressOffset>0x00000096</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PFD_POLARITY</name>
	<description>'0': Normal operation (UP: implies RCLK leads NCLK)
'1': Inverted operation (UP: implies NCLK leads RCLK) </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>FIXED_CUR_EN</name>
	<description>Enable manual override of PFD output
'0': Normal operation
'1': PFD ouput given by FIXED_CUR_SET </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>FIXED_CUR_SET</name>
	<description>Set the PFD output in a fixed position such that the CP output current is constant'0': UP = 0, DN = 0
'1': UP = 0, DN = 1
'2': UP = 1, DN = 0
'3': UP = 1, DN = 1 </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_REF_OSC_BLE_REG</name>
	
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000302c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CNT_CLK</name>
	<description>number of clock pulses corresponding to the value of CNT_RO </description>
	<access>read-write</access>
	<bitRange>[14:6]</bitRange>
	
</field><field>
	<name>CNT_RO</name>
	<description>number of reference oscillator periods that need to be counted </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_REF_OSC_FTDF_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000302c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CNT_CLK</name>
	<description>number of clock pulses corresponding to the value of CNT_RO </description>
	<access>read-write</access>
	<bitRange>[14:6]</bitRange>
	
</field><field>
	<name>CNT_RO</name>
	<description>number of reference oscillator periods that need to be counted </description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SCAN_FEEDBACK_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CP_CUR</name>
	<description>Cp_cur value during scan. </description>
	<access>read-only</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>LF_RES</name>
	<description>Lf_res value during scan. </description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SPARE1_BLE_REG</name>
	
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RF_SPARE_REG</name>
	<description>Unused spare bits for BLE mode.</description>
	<access>read-write</access>
	<bitRange>[15:6]</bitRange>
	
</field><field>
	<name>RF_GDAC_CUR_SET</name>
	<description>Set the GaussDAC reference current
</description>
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>RF_TXDAC_CLK_POL_SEL</name>
	<description>Select the polarity of the clock for the TXDAC

0x0 - Use negative edge
0x1 - Use the positive edge

</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RF_VTUNE_TO_ADC_TEST_EN</name>
	<description>Enable the connection of Vtune to the GPADC in BLE mode.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RF_XTAL_PLL_DXTAL16_TEST</name>
	<description>Connect the PLL output of the xtal oscillator to the digital driver of P17 in BLE mode.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RF_XTAL_RFCLK_TEST</name>
	<description>Connect the RFCLK output of the xtal oscillator to the digital driver of P14 in BLE mode.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_SPARE1_FTDF_REG</name>
	
	<addressOffset>0x00000082</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RF_SPARE_REG</name>
	<description>Unused spare bits for FTDF mode.</description>
	<access>read-write</access>
	<bitRange>[15:6]</bitRange>
	
</field><field>
	<name>RF_GDAC_CUR_SET</name>
	
	<access>read-write</access>
	<bitRange>[5:4]</bitRange>
	
</field><field>
	<name>RF_TXDAC_CLK_POL_SEL</name>
	
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RF_VTUNE_TO_ADC_TEST_EN</name>
	<description>Enable the connection of Vtune to the GPADC in FTDF mode.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RF_XTAL_PLL_DXTAL16_TEST</name>
	<description>Connect the PLL output of the xtal oscillator to the digital driver of P17 in FTDF mode.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RF_XTAL_RFCLK_TEST</name>
	<description>Connect the RFCLK output of the xtal oscillator to the digital driver of P14 in FTDF mode.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TDC_CTRL_REG</name>
	<description>TDC settings</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>TDC_CONNECT</name>
	<description>'0': Normal Operation (no measurement possible)
'1': Connect the PFD inputs also to the TDC inputs
</description>
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>REF_CTRL</name>
	<description>Select how calibration is performed.
Phase 1:
'0': Count during 1 RCLK period (expect 60-70 as result)
'1': Count during 2 RCLK period (expect 120-140 as result)
'2': Count during 3 RCLK period (expect 180 -210 as result)
'3': not allowed
Phase 2, base the resolution measurement on:
'0': 1 overlap of fast and slow oscillators (NF=NS+1)
'1': 2 overlaps of fast and slow oscillators (NF=NS+2)
'2': 1 overlap of fast and slow oscillators (NF=NS+1)
'3': Not allowed
</description>
	<access>read-write</access>
	<bitRange>[11:10]</bitRange>
	
</field><field>
	<name>CAL_PH_2</name>
	<description>Select calibration option 2
'0': normal operation (pfd measurement mode or cal mode 1)
'1': measure the slow - fast oscillator period (calibration phase 2)
------- Note CAL_PH_1 must be 0 in this setting
</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>CAL_PH_1</name>
	<description>Select calibration option 1
'0': normal operation (pfd measurement or cal mode 2)
'1': measure the fast oscillator period (calibration phase 1)
------- Note: CAL_PH_2 must be 0 in this setting
</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>CTRL_SLOW</name>
	<description>Trim the slow oscillator
'0': Minimum frequency (default)
'F': Maximum frequency
</description>
	<access>read-write</access>
	<bitRange>[7:4]</bitRange>
	
</field><field>
	<name>CTRL_FAST</name>
	<description>Trim the fast oscillator
'0': mimimum frequency
'F': maximum frequency

</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TXDAC_CAL_CAP_STAT_REG</name>
	<description>Current CAL CAP value for TXDAC</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000030</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>TXDAC_FIXED_CAP_ON_RD</name>
	<description>Read back TXDAC_FIXED_CAP_ON value.
Reset value is, RF_TXDAC_CAL_CAP_STAT_REG[5] = RF_TXDAC_CTRL_REG[6].</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>TXDAC_CAL_CAP_RD</name>
	<description>Reset value is:RF_TXDAC_CAL_CAP_STAT_REG[4:0] = RF_IFF_CC_BLE_SET1_REG (since during reset, ftdf_mode is 0.)</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TXDAC_CTRL_REG</name>
	<description>Control settings for the TXDAC</description>
	<addressOffset>0x000000da</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>TXDAC_CAL_CAP_WR_FTDF</name>
	<description>External provided capacitor value of TXDAC for FTDF mode.</description>
	<access>read-write</access>
	<bitRange>[11:7]</bitRange>
	
</field><field>
	<name>TXDAC_FIXED_CAP_ON</name>
	<description>Connect the fixed cap in the TXDAC reconstruction filter.
Should be on by default. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>TXDAC_CAL_CAP_SEL</name>
	<description>0: use IF_CAL_CAP_BLE/FTDF_SET1, depending on mode. TXDAC_CAP_WR is added as offset.
1: use TXDAC_CAP_WR directly</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>TXDAC_CAL_CAP_WR_BLE</name>
	<description>External provided capacitor value of TXDAC for BLE mode.</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_BLE_REG</name>
	<description>TX Power setting</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields>
	<field>
	<name>TX_POWER_SET</name>
	<description>(During BLE mode) Use settings from RF_TX_PWR_LUT_x_REG&lt;11:0&gt; , when zero OR in RX mode the LUT functionality is not used. </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_FTDF_REG</name>
	<description>TX Power setting</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields>
	<field>
	<name>TX_POWER_SET</name>
	<description>(During FTDF mode) Use settings from RF_TX_PWR_LUT_x_REG&lt;11:0&gt; , when zero OR in RX mode the LUT functionality is not used. </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_LUT_1_REG</name>
	<description>TX Power setting 1</description>
	<addressOffset>0x000000c2</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000003b</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>TX_PWR_RFIO_TXRX_DCF_DIS</name>
	<description>Bit to overrule the rfio_txrx DCF signal in order to use the -20dBm setting
'0' = normal functionality
'1' = keep rfio_txrx DCF low in tx mode. (-20dBm mode)
</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_LNA_CTRL3_REG</name>
	<description>Value for RF_LNA_CTRL3_REG&lt;4:0&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=1</description>
	<access>read-write</access>
	<bitRange>[10:6]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_PA_CTRL_REG</name>
	<description>Value for RF_PA_CTRL_REG&lt;14:11&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=1</description>
	<access>read-write</access>
	<bitRange>[5:2]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_IO_CTRL1_REG</name>
	<description>Value for RF_IO_CTRL1_REG&lt;1:0&gt; in TX mode when RF_TX_PWR_REG &lt;2:0&gt; = 1</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_LUT_2_REG</name>
	<description>TX Power setting 2</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000037</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>TX_PWR_RFIO_TXRX_DCF_DIS</name>
	<description>Bit to overrule the rfio_txrx DCF signal in order to use the -20dBm setting
'0' = normal functionality
'1' = keep rfio_txrx DCF low in tx mode. (-20dBm mode)
</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_LNA_CTRL3_REG</name>
	<description>Value for RF_LNA_CTRL3_REG&lt;4:0&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=2</description>
	<access>read-write</access>
	<bitRange>[10:6]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_PA_CTRL_REG</name>
	<description>Value for RF_PA_CTRL_REG&lt;14:11&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=2</description>
	<access>read-write</access>
	<bitRange>[5:2]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_IO_CTRL1_REG</name>
	<description>Value for RF_IO_CTRL1_REG&lt;1:0&gt; in TX mode when RF_TX_PWR_REG &lt;2:0&gt; = 2</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_LUT_3_REG</name>
	<description>TX Power setting 3</description>
	<addressOffset>0x000000c6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001f6</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>TX_PWR_RFIO_TXRX_DCF_DIS</name>
	<description>Bit to overrule the rfio_txrx DCF signal in order to use the -20dBm setting
'0' = normal functionality
'1' = keep rfio_txrx DCF low in tx mode. (-20dBm mode)
</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_LNA_CTRL3_REG</name>
	<description>Value for RF_LNA_CTRL3_REG&lt;4:0&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=3</description>
	<access>read-write</access>
	<bitRange>[10:6]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_PA_CTRL_REG</name>
	<description>Value for RF_PA_CTRL_REG&lt;14:11&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=3</description>
	<access>read-write</access>
	<bitRange>[5:2]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_IO_CTRL1_REG</name>
	<description>Value for RF_IO_CTRL1_REG&lt;1:0&gt; in TX mode when RF_TX_PWR_REG &lt;2:0&gt; = 3</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_LUT_4_REG</name>
	<description>TX Power setting 4</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000036</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>TX_PWR_RFIO_TXRX_DCF_DIS</name>
	<description>Bit to overrule the rfio_txrx DCF signal in order to use the -20dBm setting
'0' = normal functionality
'1' = keep rfio_txrx DCF low in tx mode. (-20dBm mode)
</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_LNA_CTRL3_REG</name>
	<description>Value for RF_LNA_CTRL3_REG&lt;4:0&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=4</description>
	<access>read-write</access>
	<bitRange>[10:6]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_PA_CTRL_REG</name>
	<description>Value for RF_PA_CTRL_REG&lt;14:11&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=4</description>
	<access>read-write</access>
	<bitRange>[5:2]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_IO_CTRL1_REG</name>
	<description>Value for RF_IO_CTRL1_REG&lt;1:0&gt; in TX mode when RF_TX_PWR_REG &lt;2:0&gt; = 4</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_LUT_5_REG</name>
	<description>TX Power setting 5</description>
	<addressOffset>0x000000ca</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>TX_PWR_RFIO_TXRX_DCF_DIS</name>
	<description>Bit to overrule the rfio_txrx DCF signal in order to use the -20dBm setting
'0' = normal functionality
'1' = keep rfio_txrx DCF low in tx mode. (-20dBm mode)
</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_LNA_CTRL3_REG</name>
	<description>Value for RF_LNA_CTRL3_REG&lt;4:0&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=5</description>
	<access>read-write</access>
	<bitRange>[10:6]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_PA_CTRL_REG</name>
	<description>Value for RF_PA_CTRL_REG&lt;14:11&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=5</description>
	<access>read-write</access>
	<bitRange>[5:2]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_IO_CTRL1_REG</name>
	<description>Value for RF_IO_CTRL1_REG&lt;1:0&gt; in TX mode when RF_TX_PWR_REG &lt;2:0&gt; = 5</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_LUT_6_REG</name>
	<description>TX Power setting 6</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>TX_PWR_RFIO_TXRX_DCF_DIS</name>
	<description>Bit to overrule the rfio_txrx DCF signal in order to use the -20dBm setting
'0' = normal functionality
'1' = keep rfio_txrx DCF low in tx mode. (-20dBm mode)
</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_LNA_CTRL3_REG</name>
	<description>Value for RF_LNA_CTRL3_REG&lt;4:0&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=6</description>
	<access>read-write</access>
	<bitRange>[10:6]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_PA_CTRL_REG</name>
	<description>Value for RF_PA_CTRL_REG&lt;14:11&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=6</description>
	<access>read-write</access>
	<bitRange>[5:2]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_IO_CTRL1_REG</name>
	<description>Value for RF_IO_CTRL1_REG&lt;1:0&gt; in TX mode when RF_TX_PWR_REG &lt;2:0&gt; = 6</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_LUT_7_REG</name>
	<description>TX Power setting 7</description>
	<addressOffset>0x000000ce</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>TX_PWR_RFIO_TXRX_DCF_DIS</name>
	<description>Bit to overrule the rfio_txrx DCF signal in order to use the -20dBm setting
'0' = normal functionality
'1' = keep rfio_txrx DCF low in tx mode. (-20dBm mode)
</description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_LNA_CTRL3_REG</name>
	<description>Value for RF_LNA_CTRL3_REG&lt;4:0&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=7</description>
	<access>read-write</access>
	<bitRange>[10:6]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_PA_CTRL_REG</name>
	<description>Value for RF_PA_CTRL_REG&lt;14:11&gt; in TX mode when RF_TX_PWR_REG&lt;2:0&gt;=7</description>
	<access>read-write</access>
	<bitRange>[5:2]</bitRange>
	
</field><field>
	<name>TX_PWR_RF_IO_CTRL1_REG</name>
	<description>Value for RF_IO_CTRL1_REG&lt;1:0&gt; in TX mode when RF_TX_PWR_REG &lt;2:0&gt; = 7</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_TX_PWR_LUT_RD_REG</name>
	<description>TX Power read back</description>
	<addressOffset>0x000000d2</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001ff</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields>
	<field>
	<name>RF_TX_PWR_LUT_RD</name>
	<description>Output of mux, controlled by TX_POWER_SET
The reset value is equal to the reset value of {radio_enable_24_overruled, rf_lna_ctrl3_reg, rf_pa_ctrl_reg[14:11], rf_io_ctrl1_reg[1:0]}</description>
	<access>read-only</access>
	<bitRange>[11:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_VCOVAR_CTRL_REG</name>
	
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000a492</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>MOD_VAR_V1</name>
	<description>Bias voltage of the VCO Modulation varactor (high Vmod)
0: low
1: mid
2: nominal
3: high </description>
	<access>read-write</access>
	<bitRange>[15:14]</bitRange>
	
</field><field>
	<name>MOD_VAR_V0</name>
	<description>Bias voltage of the VCO Modulation varactor (low Vmod)
0: low
1: mid
2: nominal
3: high </description>
	<access>read-write</access>
	<bitRange>[13:12]</bitRange>
	
</field><field>
	<name>TUNE_VAR_V3</name>
	<description>Bias voltage of the VCO Tuning varactor (high Vtune)
001: low
010: nominal
100: high
others: not allowed</description>
	<access>read-write</access>
	<bitRange>[11:9]</bitRange>
	
</field><field>
	<name>TUNE_VAR_V2</name>
	<description>Bias voltage of the VCO Tuning varactor (high-mid Vtune)
Coding identical to TUNE_VAR_V3 </description>
	<access>read-write</access>
	<bitRange>[8:6]</bitRange>
	
</field><field>
	<name>TUNE_VAR_V1</name>
	<description>Bias voltage of the VCO Tuning varactor (low-mid Vtune)
Coding identical to TUNE_VAR_V3</description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>TUNE_VAR_V0</name>
	<description>Bias voltage of the VCO Tuning varactor (low Vtune)
Coding identical to TUNE_VAR_V3</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_VCO_AMP_CTRL1_REG</name>
	
	<addressOffset>0x000000b2</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000005c</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>VCO_AMPL_MODE</name>
	<description>V1a: 0x00
V1b: 0x03
V2a: 0x5C
V2b: 0x5F
</description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_VCO_AMP_CTRL2_REG</name>
	
	<addressOffset>0x000000b4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000202</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>VCO_AMPL_SET_RX</name>
	<description>Set the desired amplitude of the VCO in RX mode. The amplitudes values, from lower to higher amplitude, for the 4 modes are:
V1a and V1b modes:
0x01,0x02,0x03,0x04,0x05,0x06,0x07
V2a and V2b modes:
0x10,0x20,0x30,0x40,0x50,0x60,0x01,0x02,0x03,0x04,0x05,0x06,0x07
</description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>VCO_AMPL_SET_TX</name>
	<description>Set the desired amplitude of the VCO in TX mode. The amplitudes values, from lower to higher amplitude, for the 4 modes are:
V1a and V1b modes:
0x01,0x02,0x03,0x04,0x05,0x06,0x07
V2a and V2b modes:
0x10,0x20,0x30,0x40,0x50,0x60,0x01,0x02,0x03,0x04,0x05,0x06,0x07
</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFCU_POWER</name>
	<version>1.0</version>
	<description>RFCU_POWER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50002200</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>398</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>RF_ALWAYS_EN1_REG</name>
	
	<addressOffset>0x00000180</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ALW_EN_PA_EN</name>
	
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>ALW_EN_PA_RAMP_EN</name>
	
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>ALW_EN_LNA_LDO_ZERO</name>
	
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>ALW_EN_CP_BIAS_EN</name>
	
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>ALW_EN_VCO_BIAS_EN</name>
	
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>ALW_EN_CP_SWITCH_EN</name>
	
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>ALW_EN_PA_LDO_EN</name>
	
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>ALW_EN_PFD_LDO_EN</name>
	
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>ALW_EN_MD_LDO_EN</name>
	
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>ALW_EN_VCO_LDO_EN</name>
	
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ALW_EN_IFFADC_LDO_EN</name>
	
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>ALW_EN_IFF_LDO_EN</name>
	
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>ALW_EN_MIX_LDO_EN</name>
	
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>ALW_EN_LNA_CGM_EN</name>
	
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>ALW_EN_LNA_CORE_EN</name>
	
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ALW_EN_LNA_LDO_EN</name>
	
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ALWAYS_EN2_REG</name>
	
	<addressOffset>0x00000182</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ALW_EN_GAUSS_BIAS_SH</name>
	
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>ALW_EN_IFFMIX_BIAS_SH_OPEN</name>
	
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>ALW_EN_VCO_BIAS_SH_OPEN</name>
	
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>ALW_EN_CP_BIAS_SH_OPEN</name>
	
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>ALW_EN_DIV2_EN</name>
	
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>ALW_EN_RXIQ_EN</name>
	
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>ALW_EN_LOBUF_PA_EN</name>
	
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>ALW_EN_RFIO_TXRX</name>
	
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>ALW_EN_GAUSS_EN</name>
	
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>ALW_EN_PDF_EN</name>
	
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ALW_EN_CP_EN</name>
	
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>ALW_EN_LOBUF_MD_EN</name>
	
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>ALW_EN_VCO_EN</name>
	
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>ALW_EN_ADC_EN</name>
	
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>ALW_EN_IFF_EN</name>
	
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ALW_EN_MIX_EN</name>
	
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ALWAYS_EN3_REG</name>
	
	<addressOffset>0x00000184</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>ALW_EN_SPARE3_EN</name>
	
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>ALW_EN_SPARE2_EN</name>
	
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>ALW_EN_TXDAC_EN</name>
	
	<access>read-write</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>ALW_EN_TR_PWRM_OFF_EN</name>
	
	<access>read-write</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>ALW_EN_ADC_CLK_EN</name>
	
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>ALW_EN_LDO_RADIO_EN</name>
	
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>ALW_EN_RFIO_BIAS_SH</name>
	
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>ALW_EN_RFIO_BIAS_EN</name>
	
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>ALW_EN_LDO_RFIO_EN</name>
	
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>ALW_EN_TDC_EN</name>
	
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>ALW_EN_CAL_EN</name>
	
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>ALW_EN_LDO_ZERO_EN</name>
	
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>ALW_EN_DEM_EN</name>
	
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>ALW_EN_PLLCLOSED_EN</name>
	
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>ALW_EN_PLL_DIG_EN</name>
	
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ALW_EN_MIX_BIAS_SH</name>
	
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ALWAYS_EN4_REG</name>
	
	<addressOffset>0x00000186</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields>
	<field>
	<name>ALW_EN_DEM_FTDF_EN</name>
	
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ALW_EN_SPARE4_EN</name>
	
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_10_REG</name>
	
	<addressOffset>0x00000114</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000182e</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_11_REG</name>
	
	<addressOffset>0x00000116</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001830</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_tx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_tx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_12_REG</name>
	
	<addressOffset>0x00000118</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000003c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_13_REG</name>
	
	<addressOffset>0x0000011a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000163c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_14_REG</name>
	
	<addressOffset>0x0000011c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00002044</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_15_REG</name>
	
	<addressOffset>0x0000011e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000183c</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_16_REG</name>
	
	<addressOffset>0x00000120</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00002207</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_17_REG</name>
	
	<addressOffset>0x00000122</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000410</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_18_REG</name>
	
	<addressOffset>0x00000124</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000218</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_19_REG</name>
	
	<addressOffset>0x00000126</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000218</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_1_REG</name>
	
	<addressOffset>0x00000102</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001e00</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/so_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_20_REG</name>
	
	<addressOffset>0x00000128</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000508</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_21_REG</name>
	
	<addressOffset>0x0000012a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000030</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_22_REG</name>
	
	<addressOffset>0x0000012c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000030</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_23_REG</name>
	
	<addressOffset>0x0000012e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000030</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_24_REG</name>
	
	<addressOffset>0x00000130</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_25_REG</name>
	
	<addressOffset>0x00000132</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_26_REG</name>
	
	<addressOffset>0x00000134</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_27_REG</name>
	
	<addressOffset>0x00000136</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_28_REG</name>
	
	<addressOffset>0x00000138</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_29_REG</name>
	
	<addressOffset>0x0000013a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_2_REG</name>
	
	<addressOffset>0x00000104</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001b08</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/so_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_30_REG</name>
	
	<addressOffset>0x0000013c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_31_REG</name>
	
	<addressOffset>0x0000013e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_3_REG</name>
	
	<addressOffset>0x00000106</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001a10</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/so_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_4_REG</name>
	
	<addressOffset>0x00000108</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000022e</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_5_REG</name>
	
	<addressOffset>0x0000010a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001818</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_6_REG</name>
	
	<addressOffset>0x0000010c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000232</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_7_REG</name>
	
	<addressOffset>0x0000010e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00001818</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_tx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_tx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_8_REG</name>
	
	<addressOffset>0x00000110</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000023e</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_CNTRL_TIMER_9_REG</name>
	
	<addressOffset>0x00000112</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000022e</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RESET_OFFSET</name>
	<description>Offset w.r.t. end switch instant eo_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>SET_OFFSET</name>
	<description>Offset w.r.t. start switch instant so_rx/eo_tx. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG0_REG</name>
	
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000009</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>lna_ldo_en_dcf_tx</name>
	<description>DCF timer for lna_ldo_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>lna_ldo_en_dcf_rx</name>
	<description>DCF timer for lna_ldo_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG10_REG</name>
	
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>cp_switch_en_dcf_tx</name>
	<description>DCF timer for cp_switch_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>cp_switch_en_dcf_rx</name>
	<description>DCF timer for cp_switch_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG11_REG</name>
	
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000054</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>vco_bias_en_dcf_tx</name>
	<description>DCF timer for vco_bias_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>vco_bias_en_dcf_rx</name>
	<description>DCF timer for vco_bias_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG12_REG</name>
	
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000071</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>cp_bias_en_dcf_tx</name>
	<description>DCF timer for cp_bias_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>cp_bias_en_dcf_rx</name>
	<description>DCF timer for cp_bias_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG13_REG</name>
	
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>lna_ldo_zero_dcf_tx</name>
	<description>DCF timer for lna_ldo_zero in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>lna_ldo_zero_dcf_rx</name>
	<description>DCF timer for lna_ldo_zero in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG14_REG</name>
	
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000180</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>pa_ramp_en_dcf_tx</name>
	<description>DCF timer for pa_ramp_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>pa_ramp_en_dcf_rx</name>
	<description>DCF timer for pa_ramp_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG15_REG</name>
	
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001e0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>pa_en_dcf_tx</name>
	<description>DCF timer for pa_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>pa_en_dcf_rx</name>
	<description>DCF timer for pa_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG16_REG</name>
	
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>mix_en_dcf_tx</name>
	<description>DCF timer for mix_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>mix_en_dcf_rx</name>
	<description>DCF timer for mix_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG17_REG</name>
	
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>iff_en_dcf_tx</name>
	<description>DCF timer for iff_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>iff_en_dcf_rx</name>
	<description>DCF timer for iff_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG18_REG</name>
	
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>adc_en_dcf_tx</name>
	<description>DCF timer for adc_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>adc_en_dcf_rx</name>
	<description>DCF timer for adc_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG19_REG</name>
	
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000054</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>vco_en_dcf_tx</name>
	<description>DCF timer for adc_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>vco_en_dcf_rx</name>
	<description>DCF timer for adc_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG1_REG</name>
	
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000009</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>lna_core_en_dcf_tx</name>
	<description>DCF timer for lna_core_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>lna_core_en_dcf_rx</name>
	<description>DCF timer for lna_core_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG20_REG</name>
	
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000071</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>lobuf_md_en_dcf_tx</name>
	<description>DCF timer for lobuf_md_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>lobuf_md_en_dcf_rx</name>
	<description>DCF timer for lobuf_md_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG21_REG</name>
	
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000071</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>cp_en_dcf_tx</name>
	<description>DCF timer for cp_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>cp_en_dcf_rx</name>
	<description>DCF timer for cp_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG22_REG</name>
	
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000071</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>pfd_en_dcf_tx</name>
	<description>DCF timer for pfd_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>pfd_en_dcf_rx</name>
	<description>DCF timer for pfd_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG23_BLE_REG</name>
	
	<addressOffset>0x0000002e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>gauss_en_ble_dcf_tx</name>
	<description>DCF timer for gauss_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>gauss_en_ble_dcf_rx</name>
	<description>DCF timer for gauss_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG23_FTDF_REG</name>
	
	<addressOffset>0x000000ae</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>gauss_en_ftdf_dcf_tx</name>
	<description>DCF timer for gauss_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>gauss_en_ftdf_dcf_rx</name>
	<description>DCF timer for gauss_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG24_BLE_REG</name>
	
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001a0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>rfio_txrx_ble_dcf_tx</name>
	<description>DCF timer for rfio_txrx in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>rfio_txrx_ble_dcf_rx</name>
	<description>DCF timer for rfio_txrx in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG24_FTDF_REG</name>
	
	<addressOffset>0x000000b0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001a0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>rfio_txrx_ftdf_dcf_tx</name>
	<description>DCF timer for rfio_txrx in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>rfio_txrx_ftdf_dcf_rx</name>
	<description>DCF timer for rfio_txrx in tx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG25_REG</name>
	
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>lobuf_pa_en_dcf_tx</name>
	<description>DCF timer for lobuf_pa_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>lobuf_pa_en_dcf_rx</name>
	<description>DCF timer for lobuf_pa_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG26_REG</name>
	
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>lobuf_rxiq_en_dcf_tx</name>
	<description>DCF timer for lobuf_rxiq_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>lobuf_rxiq_en_dcf_rx</name>
	<description>DCF timer for lobuf_rxiq_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG27_REG</name>
	
	<addressOffset>0x00000036</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000071</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>div2_en_dcf_tx</name>
	<description>DCF timer for div2_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>div2_en_dcf_rx</name>
	<description>DCF timer for div2_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG28_REG</name>
	
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000b2</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>cp_bias_sh_open_dcf_tx</name>
	<description>DCF timer for cp_bias_sh_open in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>cp_bias_sh_open_dcf_rx</name>
	<description>DCF timer for cp_bias_sh_open in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG29_REG</name>
	
	<addressOffset>0x0000003a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000b2</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>vco_bias_sh_open_dcf_tx</name>
	<description>DCF timer for vco_bias_sh_open in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>vco_bias_sh_open_dcf_rx</name>
	<description>DCF timer for vco_bias_sh_open in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG2_REG</name>
	
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000009</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>lna_cgm_en_dcf_tx</name>
	<description>DCF timer for lna_cgm_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>lna_cgm_en_dcf_rx</name>
	<description>DCF timer for lna_cgm_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG30_REG</name>
	
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>iffmix_bias_sh_open_dcf_tx</name>
	<description>DCF timer for iffmix_bias_sh_open in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>iffmix_bias_sh_open_dcf_rx</name>
	<description>DCF timer for iffmix_bias_sh_open in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG31_BLE_REG</name>
	
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000a0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>gauss_bias_sh_ble_dcf_tx</name>
	<description>DCF timer for gauss_bias_sh in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>gauss_bias_sh_ble_dcf_rx</name>
	<description>DCF timer for gauss_bias_sh in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG31_FTDF_REG</name>
	
	<addressOffset>0x000000be</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000a0</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>gauss_bias_sh_ftdf_dcf_tx</name>
	<description>DCF timer for gauss_bias_sh in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>gauss_bias_sh_ftdf_dcf_rx</name>
	<description>DCF timer for gauss_bias_sh in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG32_REG</name>
	
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>mix_bias_sh_dcf_tx</name>
	<description>DCF timer for pa_bias_sh_open in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>mix_bias_sh_dcf_rx</name>
	<description>DCF timer for pa_bias_sh_open in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG33_REG</name>
	
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000071</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>pll_dig_en_dcf_tx</name>
	<description>DCF timer for plldig_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>pll_dig_en_dcf_rx</name>
	<description>DCF timer for pll_dig_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG34_REG</name>
	
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000f3</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>pllclosed_en_dcf_tx</name>
	<description>DCF timer for pllclosed_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>pllclosed_en_dcf_rx</name>
	<description>DCF timer for pllclosed_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG35_BLE_REG</name>
	
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>dem_en_ble_dcf_tx</name>
	<description>DCF timer for dem_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_en_ble_dcf_rx</name>
	<description>DCF timer for dem_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG35_FTDF_REG</name>
	
	<addressOffset>0x000000c6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>dem_en_ftdf_dcf_tx</name>
	<description>DCF timer for dem_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_en_ftdf_dcf_rx</name>
	<description>DCF timer for dem_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG36_REG</name>
	
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000021</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>ldo_zero_en_dcf_tx</name>
	<description>DCF timer for ldo_zero_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>ldo_zero_en_dcf_rx</name>
	<description>DCF timer for ldo_zero_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG37_BLE_REG</name>
	
	<addressOffset>0x0000004a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001ce</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>cal_en_ble_dcf_tx</name>
	<description>DCF timer for cal_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>cal_en_ble_dcf_rx</name>
	<description>DCF timer for cal_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG37_FTDF_REG</name>
	
	<addressOffset>0x000000ca</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000001ce</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>cal_en_ftdf_dcf_tx</name>
	<description>DCF timer for cal_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>cal_en_ftdf_dcf_rx</name>
	<description>DCF timer for cal_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG38_BLE_REG</name>
	
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>tdc_en_ble_dcf_tx</name>
	<description>DCF timer for tdc_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>tdc_en_ble_dcf_rx</name>
	<description>DCF timer for tdc_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG38_FTDF_REG</name>
	
	<addressOffset>0x000000cc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>tdc_en_ftdf_dcf_tx</name>
	<description>DCF timer for tdc_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>tdc_en_ftdf_dcf_rx</name>
	<description>DCF timer for tdc_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG39_REG</name>
	
	<addressOffset>0x0000004e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>ldo_rfio_en_dcf_tx</name>
	<description>DCF timer for ldo_rfio_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>ldo_rfio_en_dcf_rx</name>
	<description>DCF timer for ldo_rfio_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG3_REG</name>
	
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>mix_ldo_en_dcf_tx</name>
	<description>DCF timer for mix_ldo_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>mix_ldo_en_dcf_rx</name>
	<description>DCF timer for mix_ldo_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG40_REG</name>
	
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000140</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>rfio_bias_en_dcf_tx</name>
	<description>DCF timer for rfio_bias_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>rfio_bias_en_dcf_rx</name>
	<description>DCF timer for rfio_bias_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG41_REG</name>
	
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000160</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>rfio_bias_sh_dcf_tx</name>
	<description>DCF timer for rfio_bias_sh_open in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>rfio_bias_sh_dcf_rx</name>
	<description>DCF timer for rfio_bias_sh_open in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG42_REG</name>
	
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000002d6</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>ldo_radio_en_dcf_tx</name>
	<description>DCF timer for ldo_radio_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>ldo_radio_en_dcf_rx</name>
	<description>DCF timer for ldo_radio_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG43_REG</name>
	
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>adc_clk_en_dcf_tx</name>
	<description>DCF timer for adc_clk_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>adc_clk_en_dcf_rx</name>
	<description>DCF timer for adc_clk_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG44_BLE_REG</name>
	
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>tr_pwm_off_en_ble_dcf_tx</name>
	<description>DCF timer for tr_pwm_off_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>tr_pwm_off_en_ble_dcf_rx</name>
	<description>DCF timer for tr_pwm_off_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG44_FTDF_REG</name>
	
	<addressOffset>0x000000d8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>tr_pwm_off_en_ftdf_dcf_tx</name>
	<description>DCF timer for tr_pwm_off_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>tr_pwm_off_en_ftdf_dcf_rx</name>
	<description>DCF timer for tr_pwm_off_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG45_BLE_REG</name>
	
	<addressOffset>0x0000005a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>txdac_en_ble_dcf_tx</name>
	<description>DCF timer for txdac_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>txdac_en_ble_dcf_rx</name>
	<description>DCF timer for txdac_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG45_FTDF_REG</name>
	
	<addressOffset>0x000000da</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>txdac_en_ftdf_dcf_tx</name>
	<description>DCF timer for txdac_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>txdac_en_ftdf_dcf_rx</name>
	<description>DCF timer for txdac_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG46_BLE_REG</name>
	
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>spare2_en_ble_dcf_tx</name>
	<description>DCF timer for spare2_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_dcparcal_en_ble_dcf_rx</name>
	<description>DCF timer for DC partial Calibration enable in rx mode. It is OR'd with the relevant register bit that enables the partial calibration</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG46_FTDF_REG</name>
	
	<addressOffset>0x000000dc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>spare2_en_ftdf_dcf_tx</name>
	<description>DCF timer for spare2_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_dcparcal_en_ftdf_dcf_rx</name>
	<description>DCF timer for DC partial Calibration enable in rx mode. It is OR'd with the relevant register bit that enables the partial calibration
</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG47_BLE_REG</name>
	
	<addressOffset>0x0000005e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>spare3_en_ble_dcf_tx</name>
	<description>DCF timer for spare3_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_agcunfreeze_en_ble_dcf_rx</name>
	<description>DCF timer for unfreezing the AGC in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG47_FTDF_REG</name>
	
	<addressOffset>0x000000de</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>spare3_en_ftdf_dcf_tx</name>
	<description>DCF timer for spare3_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_agcunfreeze_en_ftdf_dcf_rx</name>
	<description>DCF timer for unfreezing the AGC in rx mode </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG48_BLE_REG</name>
	
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>spare4_en_ble_dcf_tx</name>
	<description>DCF timer for spare4_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_sigdetect_en_ble_dcf_rx</name>
	<description>DCF timer for enabling the signal_detect in RX mode </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG48_FTDF_REG</name>
	
	<addressOffset>0x000000e0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>spare4_en_ftdf_dcf_tx</name>
	<description>DCF timer for spare4_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_sigdetect_en_ftdf_dcf_rx</name>
	<description>DCF timer for enabling the signal_detect in rx mode </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG49_BLE_REG</name>
	
	<addressOffset>0x00000062</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>dem_ftdf_en_ble_dcf_tx</name>
	<description>DCF timer for dem_ftdf_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_ftdf_en_ble_dcf_rx</name>
	<description>DCF timer for dem_ftdf_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG49_FTDF_REG</name>
	
	<addressOffset>0x000000e2</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>dem_ftdf_en_ftdf_dcf_tx</name>
	<description>DCF timer for dem_ftdf_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>dem_ftdf_en_ftdf_dcf_rx</name>
	<description>DCF timer for dem_ftdf_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG4_REG</name>
	
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>iff_ldo_en_dcf_tx</name>
	<description>DCF timer for iff_ldo_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>iff_ldo_en_dcf_rx</name>
	<description>DCF timer for iff_ldo_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG5_REG</name>
	
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>iffadc_ldo_en_dcf_tx</name>
	<description>DCF timer for iffadc_ldo_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>iffadc_ldo_en_dcf_rx</name>
	<description>DCF timer for iffadc_ldo_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG6_REG</name>
	
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>vco_ldo_en_dcf_tx</name>
	<description>DCF timer for vco_ldo_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>vco_ldo_en_dcf_rx</name>
	<description>DCF timer for vco_ldo_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG7_REG</name>
	
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>md_ldo_en_dcf_tx</name>
	<description>DCF timer for md_ldo_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>md_ldo_en_dcf_rx</name>
	<description>DCF timer for md_ldo_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG8_REG</name>
	
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>pfd_ldo_en_dcf_tx</name>
	<description>DCF timer for pfd_ldo_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>pfd_ldo_en_dcf_rx</name>
	<description>DCF timer for pfd_ldo_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_ENABLE_CONFIG9_REG</name>
	
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000042</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>pa_ldo_en_dcf_tx</name>
	<description>DCF timer for pfd_ldo_en in tx mode</description>
	<access>read-write</access>
	<bitRange>[9:5]</bitRange>
	
</field><field>
	<name>pa_ldo_en_dcf_rx</name>
	<description>DCF timer for pfd_ldo_en in rx mode</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PORT_EN_BLE_REG</name>
	
	<addressOffset>0x00000188</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>RF_PORT4_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_31_REG</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>RF_PORT4_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_31_REG</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>RF_PORT3_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_30_REG</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>RF_PORT3_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_30_REG</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>RF_PORT2_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_29_REG</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>RF_PORT2_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_29_REG</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RF_PORT1_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_28_REG</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RF_PORT1_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_28_REG</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RF_PORT0_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_27_REG</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RF_PORT0_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_27_REG</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PORT_EN_FTDF_REG</name>
	
	<addressOffset>0x0000018a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields>
	<field>
	<name>RF_PORT4_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_31_REG</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>RF_PORT4_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_31_REG</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>RF_PORT3_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_30_REG</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>RF_PORT3_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_30_REG</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>RF_PORT2_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_29_REG</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>RF_PORT2_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_29_REG</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RF_PORT1_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_28_REG</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RF_PORT1_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_28_REG</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RF_PORT0_TX</name>
	<description>Enable port by TX, timing according RF_CNTRL_TIMER_27_REG</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RF_PORT0_RX</name>
	<description>Enable port by RX, timing according RF_CNTRL_TIMER_27_REG</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RF_PORT_POL_REG</name>
	
	<addressOffset>0x0000018c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>RF_PORT4_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RF_PORT3_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RF_PORT2_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RF_PORT1_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RF_PORT0_POL</name>
	<description>Inverts polarity of RF_PORT</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RFPT</name>
	<version>1.0</version>
	<description>RFPT registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003600</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>RFPT_ADDRH_REG</name>
	<description>AHB master start address (High part)</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RFPT_ADDRH</name>
	<description>It is the base address that is used by the AHB master interface of the controller ( the birs 17:16]). Defines the AHB address from where the controller will start to stores data.</description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RFPT_ADDRL_REG</name>
	<description>AHB master start address (Low part)</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RFPT_ADDRL</name>
	<description>It is the base address that is used by the AHB master interface of the controller (the bits [15:2]). Defines the AHB address from where the controller will start to stores data.</description>
	<access>read-write</access>
	<bitRange>[15:2]</bitRange>
	
</field></fields>
</register><register>
	<name>RFPT_CRV_ADDRH_REG</name>
	<description>AHB master current address (High part)</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RFPT_CRV_ADDRH</name>
	<description>It is the AHB address that will be used by the controller in the next memory access (the bits [17:16]).</description>
	<access>read-only</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RFPT_CRV_ADDRL_REG</name>
	<description>AHB master current address (Low part)</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RFPT_CRV_ADDRL</name>
	<description>It is the AHB address that will be used by the controller in the next memory access (the bits [15:2]). </description>
	<access>read-only</access>
	<bitRange>[15:2]</bitRange>
	
</field></fields>
</register><register>
	<name>RFPT_CRV_LEN_REG</name>
	<description>The remaining data to be transferred</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RFPT_CRV_LEN</name>
	<description>Indicates the number of words (minus 1) that remain to be transfered. It is actually the current value of the RFPT_LEN_REG.</description>
	<access>read-only</access>
	<bitRange>[14:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RFPT_CTRL_REG</name>
	<description>Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RFPT_BREQ_FORCE</name>
	<description>Write this bit with 1, when the required throughput for the transferring of the captured data is close to the capacity of the system bus/memory. The controller will be aggressive in the usage of the bus. The availability of the bus will be affected for the remaining masters. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>RFPT_CIRC_EN</name>
	<description>Write with 1 to enable the circular mode.In circular mode the controller continuously writes data in to the memory until to be disabled by the software. The data are transferred in the circular buffer in the memory, which is defined by the RFPT_ADDRx_REG and RFPT_LEN_REG. The disabling of the controller is realized by writing the RFPT_PACK_EN with 0.</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RFPT_PACK_ADC_TYPE</name>
	<description>Selects the way with which the RFADC I and Q data will be concatenated in order to create the 32 bits data words that are moved to the memory.
0 - {RFADC_I(n+1), RFADC_I(n), RFADC_Q (n+1), RFADC_Q(n)}.
1 - {RFADC_I(n+1), RFADC_Q (n+1), RFADC_I(n) ,RFADC_Q(n)}.
The n represents time moment.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>RFPT_PACK_SEL</name>
	<description>Selects the source of data that will be captured.
0 - Will capture the output of the two RFADC.
1 - Will capture the output of the Phase Detector.
2 - Will capture data from the Testbus.
3 - Reserved</description>
	<access>read-write</access>
	<bitRange>[2:1]</bitRange>
	
</field><field>
	<name>RFPT_PACK_EN</name>
	<description>Starts the capturing of the data from the selected source (RFPT_PACK_SEL).
0 - There is no capturing of data. The packer of data is idle.
1 - The controller captures data. The packing of the data in words, is in progress.
Should be written with 1 in order to start the acquisition of data.
If the controller is not in circular mode (RFPT_CIRC_EN = 0) and after capturing a predefined number of words (RFPT_LEN), this bit will be auto cleared.
In circular mode (RFPT_CIRC_EN = 1) the RFPT_PACK_EN remains 1 until to be cleared by the software.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RFPT_LEN_REG</name>
	<description>Data length register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RFPT_LEN</name>
	<description>The number of words (minus one) that should be transferred.
When the selected source of data is the two ADC (RFPT_PACK_SEL==0), will capture 2*(RFPT_LEN+ 1) samples from each ADC. If the selected source is the phase detector (RFPT_PACK_SEL==1), will capture 4*(RFPT_LEN+ 1) samples. Otherwise, will capture RFPT_LEN+1 samples from the Testbus.</description>
	<access>read-write</access>
	<bitRange>[14:0]</bitRange>
	
</field></fields>
</register><register>
	<name>RFPT_STAT_REG</name>
	<description>Status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RFPT_OFLOW_STK</name>
	<description>Indicates that during the transfer of the data, at least one overflow has detected to the fifo.
0 - The transfer completed without overflows.
1 - At least one overflow occured in the fifo.
Write 1 to clear this bit. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RFPT_ACTIVE</name>
	<description>Indicates the state of the controller.
0 - The controller is idle.
1 - The controller is active. The capturing process and/or the dma activity is in progress.
The controller will activated (RFPT_ACTIVE == 1), when RFPT_PACK_EN will be written with 1. Will return to inactive state, after the end of the capturing process (RFPT_PACK_EN==0) and the transfer of all of the data to the memory. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SPI</name>
	<version>1.0</version>
	<description>SPI registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001200</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>10</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>SPI_CLEAR_INT_REG</name>
	<description>SPI clear interrupt register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_CLEAR_INT</name>
	<description>Writing any value to this register will clear the SPI_CTRL_REG[SPI_INT_BIT]
Reading returns 0. </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SPI_CTRL_REG</name>
	<description>SPI control register 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_EN_CTRL</name>
	<description>0 = SPI_EN pin disabled in slave mode. Pin SPI_EN is don't care.
1 = SPI_EN pin enabled in slave mode. </description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>SPI_MINT</name>
	<description>0 = Disable SPI_INT_BIT to ICU
1 = Enable SPI_INT_BIT to ICU.
Note that the SPI_INT interrupt is shared with AD_INT interrupt </description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>SPI_INT_BIT</name>
	<description>0 = RX Register or FIFO is empty.
1 = SPI interrupt. Data has been transmitted and receivedMust be reset by SW by writing to SPI_CLEAR_INT_REG. </description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>SPI_DI</name>
	<description>Returns the actual value of pin SPI_DIN (delayed with two internal SPI clock cycles) </description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>SPI_TXH</name>
	<description>0 = TX-FIFO is not full, data can be written.
1 = TX-FIFO is full, data can not be written. </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>SPI_FORCE_DO</name>
	<description>0 = normal operation
1 = Force SPIDO output level to value of SPI_DO. </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>SPI_RST</name>
	<description>0 = normal operation
1 = Reset SPI. Same function as SPI_ON except that internal clock remain active. </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>SPI_WORD</name>
	<description>00 = 8 bits mode, only SPI_RX_TX_REG0 used
01 = 16 bit mode, only SPI_RX_TX_REG0 used
10 = 32 bits mode, SPI_RX_TX_REG0 &amp; SPI_RX_TX_REG1 used
11 = 9 bits mode. Only valid in master mode. </description>
	<access>read-write</access>
	<bitRange>[8:7]</bitRange>
	
</field><field>
	<name>SPI_SMN</name>
	<description>Master/slave mode
0 = Master,
1 = Slave(SPI1 only) </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>SPI_DO</name>
	<description>Pin SPI_DO output level when SPI is idle or when SPI_FORCE_DO=1 </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>SPI_CLK</name>
	<description>Select SPI_CLK clock output frequency in master mode:
00 = SPI_CLK / 8
01 = SPI_CLK / 4
10 = SPI_CLK / 2
11 = SPI_CLK / 14 </description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>SPI_POL</name>
	<description>Select SPI_CLK polarity.
0 = SPI_CLK is initially low.
1 = SPI_CLK is initially high. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SPI_PHA</name>
	<description>Select SPI_CLK phase. See functional timing diagrams in SPI chapter</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SPI_ON</name>
	<description>0 = SPI Module switched off (power saving). Everything is reset except SPI_CTRL_REG0 and SPI_CTRL_REG1. When this bit is cleared the SPI will remain active in master mode until the shift register and holding register are both empty.
1 = SPI Module switched on. Should only be set after all control bits have their desired values. So two writes are needed! </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SPI_CTRL_REG1</name>
	<description>SPI control register 1</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_9BIT_VAL</name>
	<description>Determines the value of the first bit in 9 bits SPI mode. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>SPI_BUSY</name>
	<description>0 = The SPI is not busy with a transfer. This means that either no TX-data is available or that the transfers have been suspended due to a full RX-FIFO. The SPIx_CTRL_REG0[SPI_INT_BIT] can be used to distinguish between these situations.
1 = The SPI is busy with a transfer. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SPI_PRIORITY</name>
	<description>0 = The SPI has low priority, the DMA request signals are reset after the corresponding acknowledge.
1 = The SPI has high priority, DMA request signals remain
active until the FIFOS are filled/emptied, so the DMA holds the AHB bus. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SPI_FIFO_MODE</name>
	<description>0: TX-FIFO and RX-FIFO used (Bidirectional mode).
1: RX-FIFO used (Read Only Mode) TX-FIFO single depth, no flow control
2: TX-FIFO used (Write Only Mode), RX-FIFO single depth, no flow control
3: No FIFOs used (backwards compatible mode) </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SPI_RX_TX_REG0</name>
	<description>SPI RX/TX register0</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_DATA0</name>
	<description>Write: SPI_TX_REG0 output register 0 (TX-FIFO)
Read: SPI_RX_REG0 input register 0 (RX-FIFO)
In 8 or 9 bits mode bits 15 to 8 are not used, they contain old data. </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SPI_RX_TX_REG1</name>
	<description>SPI RX/TX register1</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_DATA1</name>
	<description>Write: SPI_TX_REG1 output register 1 (MSB's of TX-FIFO)
Read: SPI_RX_REG1 input register 1 (MSB's of RX-FIFO)
In 8 or 9 or 16 bits mode bits this register is not used. </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SPI2</name>
	<version>1.0</version>
	<description>SPI2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001300</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>10</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>SPI2_CLEAR_INT_REG</name>
	<description>SPI clear interrupt register</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_CLEAR_INT</name>
	<description>Writing any value to this register will clear the SPI_CTRL_REG[SPI_INT_BIT]
Reading returns 0. </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SPI2_CTRL_REG</name>
	<description>SPI control register 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_EN_CTRL</name>
	<description>0 = SPI_EN pin disabled in slave mode. Pin SPI_EN is don't care.
1 = SPI_EN pin enabled in slave mode. </description>
	<access>read-write</access>
	<bitRange>[15:15]</bitRange>
	
</field><field>
	<name>SPI_MINT</name>
	<description>0 = Disable SPI_INT_BIT to ICU
1 = Enable SPI_INT_BIT to ICU.
Note that the SPI_INT interrupt is shared with AD_INT interrupt </description>
	<access>read-write</access>
	<bitRange>[14:14]</bitRange>
	
</field><field>
	<name>SPI_INT_BIT</name>
	<description>0 = RX Register or FIFO is empty.
1 = SPI interrupt. Data has been transmitted and receivedMust be reset by SW by writing to SPI_CLEAR_INT_REG. </description>
	<access>read-only</access>
	<bitRange>[13:13]</bitRange>
	
</field><field>
	<name>SPI_DI</name>
	<description>Returns the actual value of pin SPI_DIN (delayed with two internal SPI clock cycles) </description>
	<access>read-only</access>
	<bitRange>[12:12]</bitRange>
	
</field><field>
	<name>SPI_TXH</name>
	<description>0 = TX-FIFO is not full, data can be written.
1 = TX-FIFO is full, data can not be written. </description>
	<access>read-only</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>SPI_FORCE_DO</name>
	<description>0 = normal operation
1 = Force SPIDO output level to value of SPI_DO. </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>SPI_RST</name>
	<description>0 = normal operation
1 = Reset SPI. Same function as SPI_ON except that internal clock remain active. </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>SPI_WORD</name>
	<description>00 = 8 bits mode, only SPI_RX_TX_REG0 used
01 = 16 bit mode, only SPI_RX_TX_REG0 used
10 = 32 bits mode, SPI_RX_TX_REG0 &amp; SPI_RX_TX_REG1 used
11 = 9 bits mode. Only valid in master mode. </description>
	<access>read-write</access>
	<bitRange>[8:7]</bitRange>
	
</field><field>
	<name>SPI_SMN</name>
	<description>Master/slave mode
0 = Master,
1 = Slave(SPI1 only) </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>SPI_DO</name>
	<description>Pin SPI_DO output level when SPI is idle or when SPI_FORCE_DO=1 </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>SPI_CLK</name>
	<description>Select SPI_CLK clock output frequency in master mode:
00 = SPI_CLK / 8
01 = SPI_CLK / 4
10 = SPI_CLK / 2
11 = SPI_CLK / 14 </description>
	<access>read-write</access>
	<bitRange>[4:3]</bitRange>
	
</field><field>
	<name>SPI_POL</name>
	<description>Select SPI_CLK polarity.
0 = SPI_CLK is initially low.
1 = SPI_CLK is initially high. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SPI_PHA</name>
	<description>Select SPI_CLK phase. See functional timing diagrams in SPI chapter</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>SPI_ON</name>
	<description>0 = SPI Module switched off (power saving). Everything is reset except SPI_CTRL_REG0 and SPI_CTRL_REG1. When this bit is cleared the SPI will remain active in master mode until the shift register and holding register are both empty.
1 = SPI Module switched on. Should only be set after all control bits have their desired values. So two writes are needed! </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SPI2_CTRL_REG1</name>
	<description>SPI control register 1</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_9BIT_VAL</name>
	<description>Determines the value of the first bit in 9 bits SPI mode. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>SPI_BUSY</name>
	<description>0 = The SPI is not busy with a transfer. This means that either no TX-data is available or that the transfers have been suspended due to a full RX-FIFO. The SPIx_CTRL_REG0[SPI_INT_BIT] can be used to distinguish between these situations.
1 = The SPI is busy with a transfer. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>SPI_PRIORITY</name>
	<description>0 = The SPI has low priority, the DMA request signals are reset after the corresponding acknowledge.
1 = The SPI has high priority, DMA request signals remain
active until the FIFOS are filled/emptied, so the DMA holds the AHB bus. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>SPI_FIFO_MODE</name>
	<description>0: TX-FIFO and RX-FIFO used (Bidirectional mode).
1: RX-FIFO used (Read Only Mode) TX-FIFO single depth, no flow control
2: TX-FIFO used (Write Only Mode), RX-FIFO single depth, no flow control
3: No FIFOs used (backwards compatible mode) </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SPI2_RX_TX_REG0</name>
	<description>SPI RX/TX register0</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_DATA0</name>
	<description>Write: SPI_TX_REG0 output register 0 (TX-FIFO)
Read: SPI_RX_REG0 input register 0 (RX-FIFO)
In 8 or 9 bits mode bits 15 to 8 are not used, they contain old data. </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>SPI2_RX_TX_REG1</name>
	<description>SPI RX/TX register1</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SPI_DATA1</name>
	<description>Write: SPI_TX_REG1 output register 1 (MSB's of TX-FIFO)
Read: SPI_RX_REG1 input register 1 (MSB's of RX-FIFO)
In 8 or 9 or 16 bits mode bits this register is not used. </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER1</name>
	<version>1.0</version>
	<description>TIMER1 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000200</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>36</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>CAPTIM_CAPTURE_GPIO1_REG</name>
	<description>Capture Timer value for event on GPIO1</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_CAPTURE_GPIO1</name>
	<description>Gives the Capture time for event on GPIO1</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_CAPTURE_GPIO2_REG</name>
	<description>Capture Timer value for event on GPIO2</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_CAPTURE_GPIO2</name>
	<description>Gives the Capture time for event on GPIO2</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_CAPTURE_HIGH_GPIO1_REG</name>
	<description>Capture Timer high value for event on GPIO01</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_CAPTURE_HIGH_GPIO1</name>
	<description>Gives the Capture high time for event on GPIO1</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_CAPTURE_HIGH_GPIO2_REG</name>
	<description>Capture Timer high value for event on GPIO02</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_CAPTURE_HIGH_GPIO2</name>
	<description>Gives the Capture high time for event on GPIO2</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_CTRL_REG</name>
	<description>Capture Timer control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_SYS_CLK_EN</name>
	<description>'1' Capture Timer uses the system clock
'0' Capture Timer uses the 32KHz clock</description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>CAPTIM_FREE_RUN_MODE_EN</name>
	<description>Valid when timer counts up, if it is '1' timer does not zero when reaches to reload value. it becomes zero only when it reaches the max value.</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>CAPTIM_IRQ_EN</name>
	<description>'1' Capture timer IRQ is unmasked, '0' masked</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>CAPTIM_IN2_EVENT_FALL_EN</name>
	<description>'1' input1 event type is falling edge, '0' rising edge</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>CAPTIM_IN1_EVENT_FALL_EN</name>
	<description>'1' input2 event type is falling edge, '0' rising edge</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>CAPTIM_COUNT_DOWN_EN</name>
	<description>'1' timer counts down, '0' count up</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>CAPTIM_ONESHOT_MODE_EN</name>
	<description>'1' OneShot mode enabled, '0' Capture/Timer mode enabled</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>CAPTIM_EN</name>
	<description>'1' Capture Timer enabled, else disabled</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_GPIO1_CONF_REG</name>
	<description>Capture Timer gpio1 selection</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>CAPTIM_GPIO1_CONF</name>
	<description>Select one of the 37 GPIOs as IN1, Valid value 0-37. 1 for P00 .. 37 for P47. 0 Disable input</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_GPIO2_CONF_REG</name>
	<description>Capture Timer gpio2 selection</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields>
	<field>
	<name>CAPTIM_GPIO2_CONF</name>
	<description>Select one of the 37 GPIOs as IN2, Valid value 0-37. 1 for P00 .. 37 for P47. 0 Disable input</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_PRESCALER_REG</name>
	<description>Capture Timer prescaler value</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_PRESCALER</name>
	<description>Defines the timer count frequncy. CLOCK frequency / (CAPTIM_PRESCARLER+1)</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_PRESCALER_VAL_REG</name>
	<description>Capture Timer interrupt status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_PRESCALER_VAL</name>
	<description>Gives the current prescaler value</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_PWM_DC_REG</name>
	<description>Capture Timer pwm dc register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_PWM_DC</name>
	<description>Defines the PWM duty cycle. CAPTIM_PWM_DC / ( CAPTIM_PWM_FREQ+1)</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_PWM_FREQ_REG</name>
	<description>Capture Timer pwm frequency register</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_PWM_FREQ</name>
	<description>Defines the PWM frequency. Timer clock frequency / (CAPTIM_PWM_FREQ+1)</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_RELOAD_HIGH_REG</name>
	<description>Capture Timer reload high value and Delay in shot mode</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_RELOAD_HIGH</name>
	<description>Reload high value or max high value in timer mode, Delay phase duration in oneshot mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_RELOAD_REG</name>
	<description>Capture Timer reload value and Delay in shot mode</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_RELOAD</name>
	<description>Reload or max value in timer mode, Delay phase duration in oneshot mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_SHOTWIDTH_HIGH_REG</name>
	<description>Capture Timer Shot high duration in shot mode</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_SHOTWIDTH_HIGH</name>
	<description>Shot phase high duration in oneshot mode</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_SHOTWIDTH_REG</name>
	<description>Capture Timer Shot duration in shot mode</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_SHOTWIDTH</name>
	<description>Shot phase duration in oneshot mode</description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_STATUS_REG</name>
	<description>Capture Timer status register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>CAPTIM_ONESHOT_PHASE</name>
	<description>0 : Wait for event, 1 : Delay phase, 2 : Start Shot, 3 : Shot phase</description>
	<access>read-only</access>
	<bitRange>[3:2]</bitRange>
	
</field><field>
	<name>CAPTIM_IN2_STATE</name>
	<description>Gives the logic level of the IN1</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>CAPTIM_IN1_STATE</name>
	<description>Gives the logic level of the IN2</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_TIMER_HVAL_REG</name>
	<description>Capture Timer counter high value</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_TIMER_HVALUE</name>
	<description>Gives the current timer high value</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>CAPTIM_TIMER_VAL_REG</name>
	<description>Capture Timer counter value</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CAPTIM_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TRNG</name>
	<version>1.0</version>
	<description>TRNG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50005000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>12</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>TRNG_CTRL_REG</name>
	<description>TRNG control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TRNG_MODE</name>
	<description>0: select the TRNG with asynchronous free running oscillators (default)
1: select the pseudo-random generator with synchronous oscillators (for simulation purpose only)</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>TRNG_ENABLE</name>
	<description>0: Disable the TRNG
1: Enable the TRNG this signal is ignored when the FIFO is full</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TRNG_FIFOLVL_REG</name>
	<description>TRNG FIFO level register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TRNG_FIFOFULL</name>
	<description>1:FIFO full indication. This bit is cleared if the FIFO is read.</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>TRNG_FIFOLVL</name>
	<description>Number of 32 bit words of random data in the FIFO (max 31) until the FIFO is full. When it is 0 and TRNG_FIFOFULL is 1, it means the FIFO is full.</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>TRNG_VER_REG</name>
	<description>TRNG Version register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000103</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields>
	<field>
	<name>TRNG_MAJ</name>
	<description>Major version number </description>
	<access>read-only</access>
	<bitRange>[31:24]</bitRange>
	
</field><field>
	<name>TRNG_MIN</name>
	<description>Minor version number </description>
	<access>read-only</access>
	<bitRange>[23:16]</bitRange>
	
</field><field>
	<name>TRNG_SVN</name>
	<description>SVN revision number </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART</name>
	<version>1.0</version>
	<description>UART registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001000</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>254</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>UART_CPR_REG</name>
	<description>Component Parameter Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003941</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CPR</name>
	<description>Component Parameter Register </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x44570110</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is determined by (Divisor Fraction value)/(2^DLF_SIZE).</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_IER_DLH_REG</name>
	<description>Interrupt Enable Register/Divisor Latch High</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PTIME_dlh7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled. 
Divisor Latch (High): DLH7, Bit 7 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>dlh6_4</name>
	<description>Divisor Latch (High): DLH6 to DLH4, Bits 6 to 4 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set, otherwise, this field is reserved. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>EDSSI_dlh3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH3, Bit 3 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>ELSI_dhl2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH2, Bit 2 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>ETBEI_dlh1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): DLH1, Bit 1 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ERBFI_dlh0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): DLH0, Bit 0 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IIR_FCR</name>
	<description>Interrupt Identification Register: Bits[7:6], returns 00. Bits[3:0], Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types: 0001 = no interrupt pending. 0010 = THR empty. 0100 = received data available. 0110 = receiver line status. 0111 = busy detect. 1100 = character timeout.
</description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. If active (MCR[6] set to one) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver and the sir_out_n line is forced low. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero).
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
This bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero), this bit indicates that the THR.
This bit is set whenever data is transferred from the THR to the transmitter shift register and no new data has been written to the THR. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled.</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
If in infrared mode (SIR_MODE == Enabled), it is set whenever the serial input, sir_in, is continuously pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop bits. A break condition on serial input causes one and only one character, consisting of all zeros, to be received by the UART.
Reading the LSR clears the BI bit. The BI indication occurs immediately and persists until the LSR is read. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
The OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SIRE</name>
	<description>SIR Mode Enable.
This is used to enable/disable the IrDA SIR Mode features as described in "IrDA 1.0 SIR Protocol".
0 = IrDA SIR Mode disabled
1 = IrDA SIR Mode enabled </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>UART_OUT2</name>
	<description>OUT2.
This is used to directly control the user-designated Output2 (out2_n) output. The value written to this location is inverted and driven out on out2_n, that is:
0 = out2_n de-asserted (logic 1)
1 = out2_n asserted (logic 0)
Note that in Loopback mode (MCR[4] set to one), the out2_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>UART_OUT1</name>
	<description>OUT1.
This is used to directly control the user-designated Output1 (out1_n) output. The value written to this location is inverted and driven out on out1_n, that is:
0 = out1_n de-asserted (logic 1)
1 = out1_n asserted (logic 0)
Note that in Loopback mode (MCR[4] set to one), the out1_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register/Transmit Holding Register/Divisor Latch Low</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the Divisor Latch is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.
For the Divisor Latch (High) bits, see register UART_IER_DLH_REG.</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.
If SIR_MODE active (MCR[6] = 1) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0331352a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UCV</name>
	<description>Component Version </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART_USR_REG</name>
	<description>UART Status register.</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive. 0 - DW_apb_uart is idle or inactive 1 - DW_apb_uart is busy (actively transferring data) Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the DW_apb_uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the DW_apb_uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART2</name>
	<version>1.0</version>
	<description>UART2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001100</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>254</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>UART2_CPR_REG</name>
	<description>Component Parameter Register</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00003d71</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CPR</name>
	<description>Component Parameter Register </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x44570110</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>CTR</name>
	<description>Component Type Register </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields>
	<field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_FAR_REG</name>
	<description>FIFO Access Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields>
	<field>
	<name>UART_FAR</name>
	<description>Description: Writes will have no effect when FIFO_ACCESS == No, always readable. This register is use to enable a FIFO access mode for testing, so that the receive FIFO can be written by the master and the transmit FIFO can be read by the master when FIFO's are implemented and enabled. When FIFO's are not implemented or not enabled it allows the RBR to be written by the master and the THR to be read by the master. 0 = FIFO access mode disabled 1 = FIFO access mode enabled Note, that when the FIFO access mode is enabled/disabled, the control portion of the receive FIFO and transmit FIFO is reset and the FIFO's are treated as empty.</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are implemented and not enabled, the setting of the halt TX register has no effect on operation. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_IER_DLH_REG</name>
	<description>Interrupt Enable Register/Divisor Latch High</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>PTIME_dlh7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled. 
Divisor Latch (High): DLH7, Bit 7 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>dlh6_4</name>
	<description>Divisor Latch (High): DLH6 to DLH4, Bits 6 to 4 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set, otherwise, this field is reserved. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>EDSSI_dlh3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH3, Bit 3 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>ELSI_dhl2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): DLH2, Bit 2 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>ETBEI_dlh1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled 
Divisor Latch (High): DLH1, Bit 1 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>ERBFI_dlh0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): DLH0, Bit 0 of the upper part of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. See register UART_RBR_THR_DLL_REG. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IIR_FCR</name>
	<description>Interrupt Identification Register, reading this register; FIFO Control Register, writing to this register.
Interrupt Identification Register: Bits[7:6], FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled. Bits[3:0], Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:0001 = no interrupt pending. 0010 = THR empty. 0100 = received data available. 0110 = receiver line status. 0111 = busy detect. 1100 = character timeout.
FIFO Control Register Bits[7:6], RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full Bits[5:4], TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full Bit[3], DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1 Bit[2], XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit. Bit[1], RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit. Bit[0], FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset. </description>
	<access>read-write</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. If active (MCR[6] set to one) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver and the sir_out_n line is forced low. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
If in infrared mode (SIR_MODE == Enabled), it is set whenever the serial input, sir_in, is continuously pulsed to logic '0' for longer than the sum of start time + data bits + parity + stop bits. A break condition on serial input causes one and only one character, consisting of all zeros, to be received by the UART.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SIRE</name>
	<description>SIR Mode Enable.
This is used to enable/disable the IrDA SIR Mode features as described in "IrDA 1.0 SIR Protocol".
0 = IrDA SIR Mode disabled
1 = IrDA SIR Mode enabled </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>UART_AFCE</name>
	<description>Auto Flow Control Enable.
Writeable only when AFCE_MODE == Enabled, always readable. When FIFOs are enabled and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow Control features are enabled as described in "Auto Flow Control".
0 = Auto Flow Control Mode disabled
1 = Auto Flow Control Mode enabled </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>UART_OUT2</name>
	<description>OUT2.
This is used to directly control the user-designated Output2 (out2_n) output. The value written to this location is inverted and driven out on out2_n, that is:
0 = out2_n de-asserted (logic 1)
1 = out2_n asserted (logic 0)
Note that in Loopback mode (MCR[4] set to one), the out2_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>UART_OUT1</name>
	<description>OUT1.
This is used to directly control the user-designated Output1 (out1_n) output. The value written to this location is inverted and driven out on out1_n, that is:
0 = out1_n de-asserted (logic 1)
1 = out1_n asserted (logic 0)
Note that in Loopback mode (MCR[4] set to one), the out1_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>UART_RTS</name>
	<description>Request to Send.
This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal is set low by programming MCR[1] (RTS) to a high.In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] set to one) and FIFOs enable (FCR[0] set to one), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). The rts_n signal is de-asserted when MCR[1] is set low.
Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_MSR_REG</name>
	<description>Modem Status Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_CTS</name>
	<description>Clear to Send.
This is used to indicate the current state of the modem control line cts_n. This bit is the complement of cts_n. When the Clear to Send input (cts_n) is asserted it is an indication that the modem or data set is ready to exchange data with the UART Ctrl.
0 = cts_n input is de-asserted (logic 1)
1 = cts_n input is asserted (logic 0)
In Loopback Mode (MCR[4] = 1), CTS is the same as MCR[1] (RTS). </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>UART_DCTS</name>
	<description>Delta Clear to Send.
This is used to indicate that the modem control line cts_n has changed since the last time the MSR was read.
0 = no change on cts_n since last read of MSR
1 = change on cts_n since last read of MSR
Reading the MSR clears the DCTS bit. In Loopback Mode (MCR[4] = 1), DCTS reflects changes on MCR[1] (RTS).
Note, if the DCTS bit is not set and the cts_n signal is asserted (low) and a reset occurs (software or otherwise), then the DCTS bit is set when the reset is removed if the cts_n signal remains asserted. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register/Transmit Holding Register/Divisor Latch Low</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the Divisor Latch is set, at least 8 clock cycles of the slowest UART clock should be allowed to pass before transmitting or receiving data.
For the Divisor Latch (High) bits, see register UART_IER_DLH_REG.</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_RFL_REG</name>
	<description>Receive FIFO Level</description>
	<addressOffset>0x00000084</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.
If SIR_MODE active (MCR[6] = 1) the sir_out_n line is continuously pulsed. When in Loopback Mode, the break condition is internally looped back to the receiver. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<access>write-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<access>write-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<access>write-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRTS_REG</name>
	<description>Shadow Request to Send</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SHADOW_REQUEST_TO_SEND</name>
	<description>Shadow Request to Send.
This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the burden of having to
performing a read-modify-write on the MCR. This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART Ctrl is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] = 0), the rts_n signal is set low by programming MCR[1] (RTS) to a high.
In Auto Flow Control, AFCE_MODE == Enabled and active (MCR[5] = 1) and FIFOs enable (FCR[0] = 1), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold).
Note that in Loopback mode (MCR[4] = 1), the rts_n output is held inactive-high while the value of this location is internally looped back to an input. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x3331352a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UCV</name>
	<description>Component Version </description>
	<access>read-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>UART2_USR_REG</name>
	<description>UART Status Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive. 0 - DW_apb_uart is idle or inactive 1 - DW_apb_uart is busy (actively transferring data) Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the DW_apb_uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the DW_apb_uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>USB</name>
	<version>1.0</version>
	<description>USB registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50001800</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>216</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>USB_ALTEV_REG</name>
	<description>Alternate Event Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RESUME</name>
	<description>Resume
Resume signalling is detected on the USB when the device is in Suspend state (NFS in the NFSR register is set to SUSPEND), and a non IDLE signal is present on the USB, indicating that this device should begin it's wake-up sequence and enter Operational state. This bit is cleared when the register is read. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_RESET</name>
	<description>Reset
This bit is set to 1, when 2.5 us of SEO have been detected on the upstream port. In response, the functional state should be reset (NFS in the NFSR register is set to RESET), where it must remain for at least 100 us. The functional state can then return to Operational state. This bit is cleared when the register is read </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_SD5</name>
	<description>Suspend Detect 5 ms
This bit is set to 1 after 5 ms of IDLE have been detected on the upstream port, indicating that this device is permitted to perform a remote wake-up operation. The resume may be initiated under firmware control by writing the resume value to the NFSR register. This bit is cleared when the register is read. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_SD3</name>
	<description>Suspend Detect 3 ms
This bit is set to 1 after 3 ms of IDLE have been detected on the upstream port, indicating that the device should be suspended. The suspend occurs under firmware control by writing the suspend value to the Node Functional State (NFSR) register. This bit is cleared when the register is read. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_EOP</name>
	<description>End of Packet
A valid EOP sequence was been detected on the USB. It is used when this device has initiated a Remote wake-up sequence to indicate that the Resume sequence has been acknowledged and completed by the host. This bit is cleared when the register is read. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_ALTMSK_REG</name>
	<description>Alternate Mask Register</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_M_RESUME</name>
	<description>A bit set to 1 in this register enables automatic setting of the ALT bit in the MAEV register when the respective event in the ALTEV register occurs. Otherwise, setting MAEV.ALT bit is disabled.
Same Bit Definition as ALTEV Register </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_M_RESET</name>
	<description>Same Bit Definition as ALTEV Register</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_M_SD5</name>
	<description>Same Bit Definition as ALTEV Register</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_M_SD3</name>
	<description>Same Bit Definition as ALTEV Register</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_M_EOP</name>
	<description>Same Bit Definition as ALTEV Register</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_CHARGER_CTRL_REG</name>
	<description>USB Charger Control Register</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>IDM_SINK_ON</name>
	<description>0 = Disable
1 = Enable the Idm_sink to USBm</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>IDP_SINK_ON</name>
	<description>0 = Disable
1 = Enable the Idp_sink to USBp</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>VDM_SRC_ON</name>
	<description>0 = Disable
1 = Enable Vdm_src to USBm and USB_DCP_DET status bit.</description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>VDP_SRC_ON</name>
	<description>0 = Disable
1 = Enable the Vdp_src to USB_CHG_DET status bit.</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>IDP_SRC_ON</name>
	<description>0 = Disable
1 = Enable the Idp_src and Rdm_dwn.</description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_CHARGE_ON</name>
	<description>0 = Disable USB charger detect circuit.
1 = Enable USB charger detect circuit.</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_CHARGER_STAT_REG</name>
	<description>USB Charger Status Register</description>
	<addressOffset>0x000000d6</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_DM_VAL2</name>
	<description>0 = USBm &lt;2.3V
1 = USBm &gt;2.5V</description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_DP_VAL2</name>
	<description>0: USBp &lt; 2.3V
1: USBp &gt; 2.5V</description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_DM_VAL</name>
	<description>0 = USBm &lt; 0.8V
1 = USBm &gt; 1.5V (PS2 or Proprietary Charger)</description>
	<access>read-only</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_DP_VAL</name>
	<description>0 = USBp &lt; 0.8V
1 = USBp &gt; 1.5V</description>
	<access>read-only</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_CHG_DET</name>
	<description>0 = Standard downstream or nothing connected.
1 = Charging Downstream Port (CDP) or Dedicated Charging.</description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_DCP_DET</name>
	<description>0 = Charging downstream port is detected.
1 = Dedicated charger is detected.
Control bit VDM_SRC_ON must be set to validate this status bit.
Note: This register shows the actual status.</description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_DMA_CTRL_REG</name>
	<description>USB DMA control register</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields>
	<field>
	<name>USB_DMA_EN</name>
	<description>0 = USB DMA control off. (Normal operation)
1 = USB_DMA on. DMA channels 0 and 1 are connected by
USB Endpoint according bits USB_DMA_TX and USB_DMA_RX</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_DMA_TX</name>
	<description>000 = DMA channels 1 is connected Tx USB Endpoint 1
001 = DMA channels 1 is connected Tx USB Endpoint 3
010 = DMA channels 1 is connected Tx USB Endpoint 5
100, 1xx = Reserved</description>
	<access>read-write</access>
	<bitRange>[5:3]</bitRange>
	
</field><field>
	<name>USB_DMA_RX</name>
	<description>000 = DMA channels 0 is connected Rx USB Endpoint 2
001 = DMA channels 0 is connected Rx USB Endpoint 4
010 = DMA channels 0 is connected Rx USB Endpoint 6
100, 1xx = Reserved</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_EP0_NAK_REG</name>
	<description>EP0 INNAK and OUTNAK Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_EP0_OUTNAK</name>
	<description>End point 0 OUT NAK
This bit n is set to 1 when a NAK handshake is generated for an enabled address/endpoint combination (AD_EN in the FAR register is set to 1) in response to an OUT token. This bit is not set if NAK is generated as result of an overrun condition. It is cleared when the register is read. </description>
	<access>read-only</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_EP0_INNAK</name>
	<description>End point 0 IN NAK
This bit is set to 1 when a NAK handshake is generated for an enabled address/endpoint combination (AD_EN in the FAR register is set to 1) in response to an IN token. This bit is cleared when the register is read. </description>
	<access>read-only</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_EPC0_REG</name>
	<description>Endpoint Control 0 Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
- The transmit FIFO is enabled and an IN token is received.
- The receive FIFO is enabled and an OUT token is received.
Note: A SETUP token does not cause a STALL handshake to be generated when this bit is set.
Upon transmitting the STALL handshake, the RX_LAST and the TX_DONE bits in the respective Receive/Transmit Status registers are set to 1. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_DEF</name>
	<description>Default Address
When set to 1, the device responds to the default address regardless of the contents of FAR6-0/EP03-0 fields. When an IN packet is transmitted for the endpoint, the DEF bit is automatically cleared to 0.
This bit aids in the transition from default address to assigned address. The transition from the default address 00000000000b to an address assigned during bus enumeration may not occur in the middle of the SET_ADDRESS control sequence. This is necessary to complete the control sequence. However, the address must change immediately after this sequence finishes in order to avoid errors when another control sequence immediately follows the SET_ADDRESS command.
On USB reset, the firmware has 10 ms for set-up, and should write 8016 to the FAR register and 0016 to the EPC0 register. On receipt of a SET_ADDRESS command, the firmware must write 4016 to the EPC0 register and (8016 or &lt;assigned_function_address&gt;) to the FAR register. It must then queue a zero length IN packet to complete the status phase of the SET_ADDRESS control sequence. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This field holds the 4-bit Endpoint address. For Endpoint 0, these bits are hardwired to 0000b. Writing a 1 to any of the EP bits is ignored. </description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_EPC1_REG</name>
	<description>Endpoint Control Register 1</description>
	<addressOffset>0x00000050</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_EPC2_REG</name>
	<description>Endpoint Control Register 2</description>
	<addressOffset>0x00000058</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_EPC3_REG</name>
	<description>Endpoint Control Register 3</description>
	<addressOffset>0x00000060</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_EPC4_REG</name>
	<description>Endpoint Control Register 4</description>
	<addressOffset>0x00000068</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_EPC5_REG</name>
	<description>Endpoint Control Register 5</description>
	<addressOffset>0x00000070</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_EPC6_REG</name>
	<description>Endpoint Control Register 6</description>
	<addressOffset>0x00000078</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_STALL</name>
	<description>Stall
Setting this bit to 1 causes the chip to generate STALL handshakes under the following conditions:
The transmit FIFO is enabled and an IN token is received.
The receive FIFO is enabled and an OUT token is received.
Setting this bit to 1 does not generate a STALL handshake in response to a SETUP token </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_ISO</name>
	<description>Isochronous
When this bit is set to 1, the endpoint is isochronous. This implies that no NAK is sent if the endpoint is not ready but enabled; i.e. If an IN token is received and no data is available in the FIFO to transmit, or if an OUT token is received and the FIFO is full since there is no USB handshake for isochronous transfers. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_EP_EN</name>
	<description>Endpoint Enable
When this bit is set to 1, the EP[3:0] field is used in address comparison, together with the AD[6:0] field in the FAR register. When cleared to 0, the endpoint does not respond to any token on the USB bus. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_EP</name>
	<description>Endpoint Address
This 4-bit field holds the endpoint address. </description>
	<access>read-write</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_FAR_REG</name>
	<description>Function Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_AD_EN</name>
	<description>Address Enable
When set to 1, USB address field bits 6-0 are used in address comparison
When cleared to 0, the device does not respond to any token on the USB bus.
Note: If the DEF bit in the Endpoint Control 0 register is set, Endpoint 0 responds to the default address. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_AD</name>
	<description>Address
This field holds the 7-bit function address used to transmit and receive all tokens addressed to this device. </description>
	<access>read-write</access>
	<bitRange>[6:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_FNH_REG</name>
	<description>Frame Number High Byte Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000c0</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_MF</name>
	<description>Missed SOF Flag
This flag is set to 1, when the frame number in a valid received SOF does not match the expected next value, or when an SOF is not received within 12060 bit times. This bit is set by the hardware and is cleared by reading the FNH register. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_UL</name>
	<description>Unlock Flag
This bit indicates that at least two frames were received without an expected frame number, or that no valid SOF was received within 12060 bit times. If this bit is set, the frame number from the next valid SOF packet is loaded in FN. This bit is set by the hardware and is cleared by reading the FNH register. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_RFC</name>
	<description>Reset Frame Count
Writing a 1 to this bit resets the frame number to 00016, after which this bit clears itself to 0 again. This bit always reads 0. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_FN_10_8</name>
	<description>Frame Number
This 3-bit field contains the three most significant bits (MSB) of the current frame number, received in the last SOF packet. If a valid frame number is not received within 12060 bit times (Frame Length Maximum, FLMAX, with tolerance) of the previous change, the frame number is incremented artificially. If two successive frames are missed or are incorrect, the current FN is frozen and loaded with the next frame number from a valid SOF packet.
If the frame number low byte was read by firmware before reading the FNH register, the user actually reads the contents of a buffer register which holds the value of the three frame number bits of this register when the low byte was read. Therefore, the correct sequence to read the frame number is: FNL, FNH. Read operations to the FNH register, without first reading the Frame Number Low Byte (FNL) register directly, read the actual value of the three MSBs of the frame number. </description>
	<access>read-only</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_FNL_REG</name>
	<description>Frame Number Low Byte Register</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_FN</name>
	<description>The Frame Number Low Byte Register holds the low byte of the frame number. To ensure consistency, reading this low byte causes the three frame number bits in the FNH register to be locked until this register is read. The correct sequence to read the frame number is: FNL, FNH. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_FWEV_REG</name>
	<description>FIFO Warning Event Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RXWARN31</name>
	<description>Receive Warning n: 3:1
The bit n is set to 1 when the respective receive endpoint FIFO reaches the warning limit, as specified by the RFWL bits of the respective EPCx register. This bit is cleared when the warning condition is cleared by either reading data from the FIFO or when the FIFO is flushed. </description>
	<access>read-only</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>USB_TXWARN31</name>
	<description>Transmit Warning n: 3:1
The bit n is set to 1 when the respective transmit endpoint FIFO reaches the warning limit, as specified by the TFWL bits of the respective TXCn register, and transmission from the respective endpoint is enabled. This bit is cleared when the warning condition is cleared by either writing new data to the FIFO when the FIFO is flushed, or when transmission is done, as indicated by the TX_DONE bit in the TXSn register. </description>
	<access>read-only</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_FWMSK_REG</name>
	<description>FIFO Warning Mask Register</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_M_RXWARN31</name>
	<description>The FIFO Warning Mask Register selects, which FWEV bits are reported in the MAEV register. A bit set to 1 and the corresponding bit in the FWEV register is set 1, causes the WARN bit in the MAEV register to be set to 1. When cleared to 0, the corresponding bit in the FWEV register does not cause WARN to be set to 1. Same Bit Definition as FWEV Register </description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>USB_M_TXWARN31</name>
	<description>The FIFO Warning Mask Register selects, which FWEV bits are reported in the MAEV register. A bit set to 1 and the corresponding bit in the FWEV register is set 1, causes the WARN bit in the MAEV register to be set to 1. When cleared to 0, the corresponding bit in the FWEV register does not cause WARN to be set to 1. Same Bit Definition as FWEV Register </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_MAEV_REG</name>
	<description>Main Event Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_CH_EV</name>
	<description>USB Charger event
This bit is set if one of the bits in USB_CHARGER_STAT_REG[2-0] change. This bit is cleared to 0 when if USB_CHARGER_STAT_REG is read. </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>USB_EP0_NAK</name>
	<description>Endpoint 0 NAK Event
This bit is an OR of EP0_NAK_REG[EP0_OUTNAK] and EP0_NAK_REG[EP0_INNAK] bits. USB_EP0_NAK is cleared to 0 when EP0_NAK_REG is read. </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>USB_EP0_RX</name>
	<description>Endpoint 0 Receive Event
This bit is a copy of the RXS0[RX_LAST] and is cleared to 0 when this RXS0 register is read.
Note: Since Endpoint 0 implements a store and forward principle, an overrun condition for FIFO0 cannot occur </description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>USB_EP0_TX</name>
	<description>Endpoint 0 Transmit Event
This bit is a copy of the TXS0[TX_DONE] bit and is cleared to 0 when the TXS0 register is read.
Note: Since Endpoint 0 implements a store and forward principle, an underrun condition for FIFO0 cannot occur. </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>USB_INTR</name>
	<description>Master Interrupt Enable
This bit is hardwired to 0 in the Main Event (MAEV) register; bit 7 in the Main Mask (MAMSK) register is the Master Interrupt Enable. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_RX_EV</name>
	<description>Receive Event
This bit is set to 1 if any of the unmasked bits in the Receive Event (RXEV) register is set to 1. It indicates that a SETUP or OUT transaction has been completed. This bit is cleared to 0 when all of the RX_LAST bits in each Receive Status (RXSn) register and all RXOVRRN bits in the RXEV register are cleared to 0. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_ULD</name>
	<description>Unlocked/Locked Detected
This bit is set to 1, when the frame timer has either entered unlocked condition from a locked condition, or has re-entered a locked condition from an unlocked condition as determined by the UL bit in the Frame Number (FNH or FNL) register. This bit is cleared to 0 when the register is read. </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_NAK</name>
	<description>Negative Acknowledge Event
This bit indicates that one of the unmasked NAK Event (NAKEV) register bits has been set to 1. This bit is cleared to 0 when the NAKEV register is read. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_FRAME</name>
	<description>Frame Event
This bit is set to 1, if the frame counter is updated with a new value. This can be due to the receipt of a valid SOF packet on the USB or to an artificial update if the frame counter was unlocked or a frame was missed. This bit is cleared to 0 when the register is read. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_TX_EV</name>
	<description>Transmit Event
This bit is set to 1, if any of the unmasked bits in the Transmit Event (TXEV) register (TXFIFOn or TXUNDRNn) is set to 1. Therefore, it indicates that an IN transaction has been completed. This bit is cleared to 0 when all the TX_DONE bits and the TXUNDRN bits in each Transmit Status (TXSn) register are cleared to 0. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_ALT</name>
	<description>Alternate Event
This bit indicates that one of the unmasked ALTEV register bits has been set to 1. This bit is cleared to 0 by reading the ALTEV register. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_WARN</name>
	<description>Warning Event
This bit indicates that one of the unmasked bits in the FIFO Warning Event (FWEV) register has been set to 1. This bit is cleared to 0 by reading the FWEV register. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_MAMSK_REG</name>
	<description>Main Mask Register</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_M_CH_EV</name>
	<description>The Main Mask Register masks out events reported in the MAEV registers. A bit set to 1, enables the interrupts for the respective event in the MAEV register. If the corresponding bit is cleared to 0, interrupt generation for this event is disabled. Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[11:11]</bitRange>
	
</field><field>
	<name>USB_M_EP0_NAK</name>
	<description>Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[10:10]</bitRange>
	
</field><field>
	<name>USB_M_EP0_RX</name>
	<description>Same Bit Definition as MAEV Register</description>
	<access>read-write</access>
	<bitRange>[9:9]</bitRange>
	
</field><field>
	<name>USB_M_EP0_TX</name>
	<description>Same Bit Definition as MAEV Register</description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>USB_M_INTR</name>
	<description>Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_M_RX_EV</name>
	<description>Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_M_ULD</name>
	<description>Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_M_NAK</name>
	<description>Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_M_FRAME</name>
	<description>Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_M_TX_EV</name>
	<description>Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_M_ALT</name>
	<description>Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_M_WARN</name>
	<description>Same Bit Definition as MAEV Register </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_MCTRL_REG</name>
	<description>Main Control Register)</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>LSMODE</name>
	<description>Low Speed Mode
This bit enables USB 1.5 Mbit/s low speed and swaps D+ and D- pull-up resistors. Changing speed may only be done if USBEN is set to 0.
Also D+ and D- rise and fall times are adjusted according to the USB specification. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_NAT</name>
	<description>Node Attached
This bit indicates that this node is ready to be detected as attached to USB. When cleared to 0 the transceiver forces SE0 on the USB port to prevent the hub (to which this node is connected to) from detecting an attach event. After reset or when the USB node is disabled, this bit is cleared to 0 to give the device time before it must respond to commands. After this bit has been set to 1, the device no longer drives the USB and should be ready to receive Reset signalling from the hub.
Note: This bit can only be set is USBEN is '1' </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_DBG</name>
	<description>Debug Mode.
When this bit is set, the following registers are writable: Main Event (MAEV), Alternate Event (ALTEV), NAK Event (NAKEV), Transmit Status and Receive Status. Setting the DBG bit forces the node into a locked state. The node states can be read out of the transceiver diagnostic register (XCVDIAG) at location 0xFF6802 by setting the DIAG bit in the Test Control register (UTR).
Note: The operation of CoR bits is not effected by entering Debug mode) Note: This bit can only be set is USBEN is '1' </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USBEN</name>
	<description>USB EnableSetting this bit to 1 enables the Full/Low Speed USB node. If the USBEN bit is cleared to 0, the USB is disabled and the 48 MHz clock within the USB node is stopped. In addition, all USB registers are set to their reset state.
Note that the transceiver forces SE0 on the bus to prevent the hub to detected the USB node, when it is disabled (not attached).
The USBEN bit is cleared to 0 after reset </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_NAKEV_REG</name>
	<description>NAK Event Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_OUT31</name>
	<description>OUT n: 3:1
The bit n is set to 1 when a NAK handshake is generated for an enabled address/endpoint combination (AD_EN in the FAR register is set to 1 and EP_EN in the EPCx register is set to 1) in response to an OUT token. This bit is not set if NAK is generated as result of an overrun condition. It is cleared when the register is read. </description>
	<access>read-only</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>USB_IN31</name>
	<description>IN n: 3:1
The bit n is set to 1 when a NAK handshake is generated for an enabled address/endpoint combination (AD_EN in the Function Address, FAR, register is set to 1 and EP_EN in the Endpoint Control, EPCx, register is set to 1) in response to an IN token. This bit is cleared when the register is read. </description>
	<access>read-only</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_NAKMSK_REG</name>
	<description>NAK Mask Register</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_M_OUT31</name>
	<description>When set and the corresponding bit in the NAKEV register is set, the NAK bit in the MAEV register is set. When cleared, the corresponding bit in the NAKEV register does not cause NAK to be set. Same Bit Definition as NAKEV Register </description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>USB_M_IN31</name>
	<description>Same Bit Definition as NAKEV Register </description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_NFSR_REG</name>
	<description>Node Functional State Register</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_NFS</name>
	<description>The Node Functional State Register reports and controls the current functional state of the USB node.
00: NodeReset.
This is the USB Reset state. This is entered upon a module reset or by software upon detection of a USB Reset. Upon entry, all endpoint pipes are disabled. DEF in the Endpoint Control 0 (EPC0) register and AD_EN in the Function Address (FAR) register should be cleared by software on entry to this state. On exit, DEF should be reset so the device responds to the default address.
01: NodeResume
In this state, resume signalling is generated. This state should be entered by firmware to initiate a remote wake-up sequence by the device. The node must remain in this state for at least 1 ms and no more than 15 ms.
10: NodeOperational
This is the normal operational state. In this state the node is configured for operation on the USB bus.
11: NodeSuspend
Suspend state should be entered by firmware on detection of a Suspend event while in Operational state. While in Suspend state, the transceivers operate in their low-power suspend mode. All endpoint controllers and the bits TX_EN, LAST and RX_EN are reset, while all other internal states are frozen. On detection of bus activity, the RESUME bit in the ALTEV register is set. In response, software can cause entry to NodeOperational state. </description>
	<access>read-write</access>
	<bitRange>[1:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXC0_REG</name>
	<description>Receive Command 0 Register</description>
	<addressOffset>0x0000004e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_FLUSH</name>
	<description>Flush
Writing a 1 to this bit flushes all data from the control endpoint FIFOs, resets the endpoint to Idle state, clears the FIFO read and write pointer, and then clears itself. If the endpoint is currently using FIFO0 to transfer data on USB, flushing is delayed until after the transfer is done. This bit is cleared to 0 on reset. This bit is equivalent to FLUSH in the TXC0 register. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_IGN_SETUP</name>
	<description>Ignore SETUP Tokens
When this bit is set to 1, the endpoint ignores any SETUP tokens directed to its configured address. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_IGN_OUT</name>
	<description>Ignore OUT Tokens
When this bit is set to 1, the endpoint ignores any OUT tokens directed to its configured address. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_RX_EN</name>
	<description>Receive Enable
OUT packet reception is disabled after every data packet is received, or when a STALL handshake is returned in response to an OUT token. A 1 must be written to this bit to re-enable data reception. Reception of SETUP packets is always enabled. In the case of back-to-back SETUP packets (for a given endpoint) where a valid SETUP packet is received with no other intervening non-SETUP tokens, the Endpoint Controller discards the new SETUP packet and returns an ACK handshake. If any other reasons prevent the Endpoint Controller from accepting the SETUP packet, it must not generate a handshake. This allows recovery from a condition where the ACK of the first SETUP token was lost by the host. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXC1_REG</name>
	<description>Receive Command Register 1</description>
	<addressOffset>0x0000005e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RFWL</name>
	<description>Receive FIFO Warning Limit
These bits specify how many more bytes can be received to the respective FIFO before an overrun condition occurs. If the number of empty bytes remaining in the FIFO is equal to or less than the selected warning limit, the RXWARN bit in the FWEV register is set to 1.RFWL[1:0] :
00: RFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<access>read-write</access>
	<bitRange>[6:5]</bitRange>
	
</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding receive FIFO, resets the endpoint to Idle state, and resets both the FIFO read and write pointers. If the MAC is currently using the FIFO to receive data, flushing is delayed until after receiving is completed. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_IGN_SETUP</name>
	<description>Ignore SETUP Tokens
When this bit is set to 1, the endpoint ignores any SETUP tokens directed to its configured address. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_RX_EN</name>
	<description>Receive Enable
OUT packet cannot be received after every data packet is received, or when a STALL handshake is returned in response to an OUT token. This bit must be written with a 1 to re-enable data reception. SETUP packets can always be received. In the case of back-to-back SETUP packets (for a given endpoint) where a valid SETUP packet has been received with no other intervening non-SETUP tokens, the receive state machine discards the new SETUP packet and returns an ACK handshake. If, for any other reason, the receive state machine cannot accept the SETUP packet, no HANDSHAKE should be generated. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXC2_REG</name>
	<description>Receive Command Register 2</description>
	<addressOffset>0x0000006e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RFWL</name>
	<description>Receive FIFO Warning Limit
These bits specify how many more bytes can be received to the respective FIFO before an overrun condition occurs. If the number of empty bytes remaining in the FIFO is equal to or less than the selected warning limit, the RXWARN bit in the FWEV register is set to 1.RFWL[1:0] :
00: RFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<access>read-write</access>
	<bitRange>[6:5]</bitRange>
	
</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding receive FIFO, resets the endpoint to Idle state, and resets both the FIFO read and write pointers. If the MAC is currently using the FIFO to receive data, flushing is delayed until after receiving is completed. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_IGN_SETUP</name>
	<description>Ignore SETUP Tokens
When this bit is set to 1, the endpoint ignores any SETUP tokens directed to its configured address. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_RX_EN</name>
	<description>Receive Enable
OUT packet cannot be received after every data packet is received, or when a STALL handshake is returned in response to an OUT token. This bit must be written with a 1 to re-enable data reception. SETUP packets can always be received. In the case of back-to-back SETUP packets (for a given endpoint) where a valid SETUP packet has been received with no other intervening non-SETUP tokens, the receive state machine discards the new SETUP packet and returns an ACK handshake. If, for any other reason, the receive state machine cannot accept the SETUP packet, no HANDSHAKE should be generated. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXC3_REG</name>
	<description>Receive Command Register 3</description>
	<addressOffset>0x0000007e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RFWL</name>
	<description>Receive FIFO Warning Limit
These bits specify how many more bytes can be received to the respective FIFO before an overrun condition occurs. If the number of empty bytes remaining in the FIFO is equal to or less than the selected warning limit, the RXWARN bit in the FWEV register is set to 1.RFWL[1:0] :
00: RFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<access>read-write</access>
	<bitRange>[6:5]</bitRange>
	
</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding receive FIFO, resets the endpoint to Idle state, and resets both the FIFO read and write pointers. If the MAC is currently using the FIFO to receive data, flushing is delayed until after receiving is completed. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_IGN_SETUP</name>
	<description>Ignore SETUP Tokens
When this bit is set to 1, the endpoint ignores any SETUP tokens directed to its configured address. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_RX_EN</name>
	<description>Receive Enable
OUT packet cannot be received after every data packet is received, or when a STALL handshake is returned in response to an OUT token. This bit must be written with a 1 to re-enable data reception. SETUP packets can always be received. In the case of back-to-back SETUP packets (for a given endpoint) where a valid SETUP packet has been received with no other intervening non-SETUP tokens, the receive state machine discards the new SETUP packet and returns an ACK handshake. If, for any other reason, the receive state machine cannot accept the SETUP packet, no HANDSHAKE should be generated. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXD0_REG</name>
	<description>Receive Data 0 Register</description>
	<addressOffset>0x0000004a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RXFD</name>
	<description>Receive FIFO Data Byte
The firmware should expect to read only the packet payload data. The PID and CRC16 are removed from the incoming data stream automatically.
In TEST mode this register allow read/write access. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXD1_REG</name>
	<description>Receive Data Register,1</description>
	<addressOffset>0x0000005a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RXFD</name>
	<description>Receive FIFO Data Byte
The firmware should expect to read only the packet payload data. The PID and CRC16 are terminated by the receive state machine.
In TEST mode this register allow read/write access via the core bus. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXD2_REG</name>
	<description>Receive Data Register 2</description>
	<addressOffset>0x0000006a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RXFD</name>
	<description>Receive FIFO Data Byte
The firmware should expect to read only the packet payload data. The PID and CRC16 are terminated by the receive state machine.
In TEST mode this register allow read/write access via the core bus. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXD3_REG</name>
	<description>Receive Data Register 3</description>
	<addressOffset>0x0000007a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RXFD</name>
	<description>Receive FIFO Data Byte
The firmware should expect to read only the packet payload data. The PID and CRC16 are terminated by the receive state machine.
In TEST mode this register allow read/write access via the core bus. </description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXEV_REG</name>
	<description>Receive Event Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RXOVRRN31</name>
	<description>Receive Overrun n: 3:1
The bit n is set to 1 in the event of an overrun condition in the corresponding receive FIFO n. They are cleared to 0 when the register is read. The firmware must check the respective RX_ERR bits that packets received for the other receive endpoints (EP2, EP4 and EP6, ) are not corrupted by errors, as these endpoints support data streaming (packets which are longer than the actual FIFO depth). </description>
	<access>read-only</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>USB_RXFIFO31</name>
	<description>Receive FIFO n: 3:1
The bit n is set to 1 whenever either RX_ERR or RX_LAST in the respective Receive Status register (RXSn) is set to 1. Reading the corresponding RXSn register automatically clears these bits.The CoR function is disabled, when the Freeze signal is asserted.The USB node discards all packets for Endpoint 0 received with errors. This is necessary in case of retransmission due to media errors, ensuring that a good copy of a SETUP packet is captured. Otherwise, the FIFO may potentially be tied up, holding corrupted data and unable to receive a retransmission of the same packet.
If data streaming is used for the receive endpoints (EP2, EP4 and EP6, EP8) the firmware must check the respective RX_ERR bits to ensure the packets received are not corrupted by errors. </description>
	<access>read-only</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXMSK_REG</name>
	<description>Receive Mask Register</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_M_RXOVRRN31</name>
	<description>The Receive Mask Register is used to select the bits of the RXEV registers, which causes the RX_EV bit in the MAEV register to be set to 1. When set to 1 and the corresponding bit in the RXEV register is set to 1, RX_EV bit in the MAEV register is set to1. When cleared to 0, the corresponding bit in the RXEV register does not cause RX_EV to be set to1. Same Bit Definition as RXEV Register </description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>USB_M_RXFIFO31</name>
	<description>Same Bit Definition as RXEV Register</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXS0_REG</name>
	<description>Receive Status 0 Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_SETUP</name>
	<description>Setup
This bit indicates that the setup packet has been received. This bit is unchanged for zero length packets. It is cleared to 0 when this register is read. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_TOGGLE_RX0</name>
	<description>Toggle
This bit specified the PID used when receiving the packet. A value of 0 indicates that the last successfully received packet had a DATA0 PID, while a value of 1 indicates that this packet had a DATA1 PID. This bit is unchanged for zero length packets. It is cleared to 0 when this register is read. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_RX_LAST</name>
	<description>Receive Last Bytes
This bit indicates that an ACK was sent upon completion of a successful receive operation. This bit is unchanged for zero length packets. It is cleared to 0 when this register is read. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_RCOUNT</name>
	<description>Receive Count
This 4-bit field contains the number of bytes presently in the RX FIFO. This number is never larger than 8 for Endpoint 0. </description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXS1_REG</name>
	<description>Receive Status Register 1</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RX_ERR</name>
	<description>Receive Error
When set to 1, this bit indicates a media error, such as bit-stuffing or CRC. If this bit is set to 1, the firmware must flush the respective FIFO. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_SETUP</name>
	<description>Setup
This bit indicates that the setup packet has been received. It is cleared when this register is read. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_TOGGLE_RX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO in the EPCn register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, a value of 0 indicates that the last successfully received packet had a DATA0 PID, while a value of 1 indicates that this packet had a DATA1 PID.
For ISO operation, this bit reflects the LSB of the frame number (FNL0) after a packet was successfully received for this endpoint.
This bit is reset to 0 by reading the RXSn register. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_RX_LAST</name>
	<description>Receive Last
This bit indicates that an ACK was sent upon completion of a successful receive operation. This bit is cleared to 0 when this register is read. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_RCOUNT</name>
	<description>Receive Counter
This 4-bit field contains the number of bytes presently in the endpoint receive FIFO. If this number is greater than 15, a value of 15 is actually reported. </description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXS2_REG</name>
	<description>Receive Status Register 2</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RX_ERR</name>
	<description>Receive Error
When set to 1, this bit indicates a media error, such as bit-stuffing or CRC. If this bit is set to 1, the firmware must flush the respective FIFO. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_SETUP</name>
	<description>Setup
This bit indicates that the setup packet has been received. It is cleared when this register is read. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_TOGGLE_RX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO in the EPCn register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, a value of 0 indicates that the last successfully received packet had a DATA0 PID, while a value of 1 indicates that this packet had a DATA1 PID.
For ISO operation, this bit reflects the LSB of the frame number (FNL0) after a packet was successfully received for this endpoint.
This bit is reset to 0 by reading the RXSn register. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_RX_LAST</name>
	<description>Receive Last
This bit indicates that an ACK was sent upon completion of a successful receive operation. This bit is cleared to 0 when this register is read. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_RCOUNT</name>
	<description>Receive Counter
This 4-bit field contains the number of bytes presently in the endpoint receive FIFO. If this number is greater than 15, a value of 15 is actually reported. </description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_RXS3_REG</name>
	<description>Receive Status Register 3</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_RX_ERR</name>
	<description>Receive Error
When set to 1, this bit indicates a media error, such as bit-stuffing or CRC. If this bit is set to 1, the firmware must flush the respective FIFO. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_SETUP</name>
	<description>Setup
This bit indicates that the setup packet has been received. It is cleared when this register is read. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_TOGGLE_RX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO in the EPCn register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, a value of 0 indicates that the last successfully received packet had a DATA0 PID, while a value of 1 indicates that this packet had a DATA1 PID.
For ISO operation, this bit reflects the LSB of the frame number (FNL0) after a packet was successfully received for this endpoint.
This bit is reset to 0 by reading the RXSn register. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_RX_LAST</name>
	<description>Receive Last
This bit indicates that an ACK was sent upon completion of a successful receive operation. This bit is cleared to 0 when this register is read. </description>
	<access>read-only</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_RCOUNT</name>
	<description>Receive Counter
This 4-bit field contains the number of bytes presently in the endpoint receive FIFO. If this number is greater than 15, a value of 15 is actually reported. </description>
	<access>read-only</access>
	<bitRange>[3:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TCR_REG</name>
	<description>Transceiver configuration Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000090</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_VADJ</name>
	<description>Reference Voltage/ Threshold voltage AdjustControls the single-ended receiver threshold.
Shall not be modified unless instructed by Dialog Semiconductor
Only enabled if USB_UTR_REG[7] = 1 </description>
	<access>read-write</access>
	<bitRange>[7:5]</bitRange>
	
</field><field>
	<name>USB_CADJ</name>
	<description>Transmitter Current Adjust
Controls the driver edge rate control current.
Shall not be modified unless instructed by Dialog Semiconductor
Only enabled if USB_UTR_REG[7] = 1 </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXC0_REG</name>
	<description>Transmit command 0 Register</description>
	<addressOffset>0x00000046</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_IGN_IN</name>
	<description>Ignore IN Tokens
When this bit is set to 1, the endpoint will ignore any IN tokens directed to its configured address. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the control endpoint FIFOs, resets the endpoint to Idle state, clears the FIFO read and write pointer, and then clears itself. If the endpoint is currently using the FIFO0 to transfer data on USB, flushing is delayed until after the transfer is done. It is equivalent to the FLUSH bit in the RXC0 register. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_TOGGLE_TX0</name>
	<description>Toggle
This bit specifies the PID used when transmitting the packet. A value of 0 causes a DATA0 PID to be generated, while a value of 1 causes a DATA1 PID to be generated. This bit is not altered by the hardware. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_TX_EN</name>
	<description>Transmission Enable
This bit enables data transmission from the FIFO. It is cleared to 0 by hardware after transmitting a single packet, or a STALL handshake, in response to an IN token. It must be set to 1 by firmware to start packet transmission. The RX_EN bit in the Receive Command 0 (RXC0) register takes precedence over this bit; i.e. if RX_EN is set, TX_EN bit is ignored until RX_EN is reset.
Zero length packets are indicated by setting this bit without writing any data to the FIFO. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXC1_REG</name>
	<description>Transmit Command Register 1</description>
	<addressOffset>0x00000056</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_IGN_ISOMSK</name>
	<description>Ignore ISO Mask
This bit has an effect only if the endpoint is set to be isochronous. If set to 1, this bit disables locking of specific frame numbers with the alternate function of the TOGGLE bit. Thus data is transmitted upon reception of the next IN token. If cleared to 0, data is only transmitted when FNL0 matches TOGGLE. This bit is cleared to 0 after reset. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_TFWL</name>
	<description>Transmit FIFO Warning Limit
These bits specify how many more bytes can be transmitted from the respective FIFO before an underrun condition occurs. If the number of bytes remaining in the FIFO is equal to or less than the selected warning limit, the TXWARN bit in the FWEV register is set. To avoid interrupts caused by setting this bit while the FIFO is being filled before a transmission begins, TXWARN is only set when transmission from the endpoint is enabled (TX_ENn in the TXCn register is set).
TFWL[1:0] :
00: TFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<access>read-write</access>
	<bitRange>[6:5]</bitRange>
	
</field><field>
	<name>USB_RFF</name>
	<description>Refill FIFO
Setting the LAST bit to 1 automatically saves the Transmit Read Pointer (TXRP) to a buffer. When the RFF bit is set to 1, the buffered TXRP is reloaded into the TXRP. This allows the user to repeat the last transaction if no ACK was received from the host. If the MAC is currently using the FIFO to transmit, TXRP is reloaded only after the transmission is complete. After reload, this bit is cleared to 0 by hardware. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding transmit FIFO, resets the endpoint to Idle state, and clears both the FIFO read and write pointers. If the MAC is currently using the FIFO to transmit, data is flushed after the transmission is complete. After data flushing, this bit is cleared to 0 by hardware. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_TOGGLE_TX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO bit in the EPCn register is set to 1) or non-ISO operation (ISO bit is cleared to 0) is used.
For non-ISO operation, it specifies the PID used when transmitting the packet. A value of 0 causes a DATA0 PID to be generated, while a value of 1 causes a DATA1 PID to be generated.
For ISO operation, this bit and the LSB of the frame counter (FNL0) act as a mask for the TX_EN bit to allow pre-queuing of packets to specific frame numbers; I.e. transmission is enabled only if bit 0 in the FNL register is set to TOGGLE. If an IN token is not received while this condition is true, the contents of the FIFO are flushed with the next SOF. If the endpoint is set to ISO, data is always transferred with a DATA0 PID. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_LAST</name>
	<description>Last Byte
Setting this bit to 1 indicates that the entire packet has been written into the FIFO. This is used especially for streaming data to the FIFO while the actual transmission occurs. If the LAST bit is not set to 1 and the transmit FIFO becomes empty during a transmission, a stuff error followed by an EOP is forced on the bus. Zero length packets are indicated by setting this bit without writing any data to the FIFO.
The transmit state machine transmits the payload data, CRC16 and the EOP signal before clearing this bit. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_TX_EN</name>
	<description>Transmission Enable
This bit enables data transmission from the FIFO. It is cleared to 0 by hardware after transmitting a single packet or after a STALL handshake in response to an IN token. It must be set to 1 by firmware to start packet transmission. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXC2_REG</name>
	<description>Transmit Command Register 2</description>
	<addressOffset>0x00000066</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_IGN_ISOMSK</name>
	<description>Ignore ISO Mask
This bit has an effect only if the endpoint is set to be isochronous. If set to 1, this bit disables locking of specific frame numbers with the alternate function of the TOGGLE bit. Thus data is transmitted upon reception of the next IN token. If cleared to 0, data is only transmitted when FNL0 matches TOGGLE. This bit is cleared to 0 after reset. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_TFWL</name>
	<description>Transmit FIFO Warning Limit
These bits specify how many more bytes can be transmitted from the respective FIFO before an underrun condition occurs. If the number of bytes remaining in the FIFO is equal to or less than the selected warning limit, the TXWARN bit in the FWEV register is set. To avoid interrupts caused by setting this bit while the FIFO is being filled before a transmission begins, TXWARN is only set when transmission from the endpoint is enabled (TX_ENn in the TXCn register is set).
TFWL[1:0] :
00: TFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<access>read-write</access>
	<bitRange>[6:5]</bitRange>
	
</field><field>
	<name>USB_RFF</name>
	<description>Refill FIFO
Setting the LAST bit to 1 automatically saves the Transmit Read Pointer (TXRP) to a buffer. When the RFF bit is set to 1, the buffered TXRP is reloaded into the TXRP. This allows the user to repeat the last transaction if no ACK was received from the host. If the MAC is currently using the FIFO to transmit, TXRP is reloaded only after the transmission is complete. After reload, this bit is cleared to 0 by hardware. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding transmit FIFO, resets the endpoint to Idle state, and clears both the FIFO read and write pointers. If the MAC is currently using the FIFO to transmit, data is flushed after the transmission is complete. After data flushing, this bit is cleared to 0 by hardware. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_TOGGLE_TX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO bit in the EPCn register is set to 1) or non-ISO operation (ISO bit is cleared to 0) is used.
For non-ISO operation, it specifies the PID used when transmitting the packet. A value of 0 causes a DATA0 PID to be generated, while a value of 1 causes a DATA1 PID to be generated.
For ISO operation, this bit and the LSB of the frame counter (FNL0) act as a mask for the TX_EN bit to allow pre-queuing of packets to specific frame numbers; I.e. transmission is enabled only if bit 0 in the FNL register is set to TOGGLE. If an IN token is not received while this condition is true, the contents of the FIFO are flushed with the next SOF. If the endpoint is set to ISO, data is always transferred with a DATA0 PID. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_LAST</name>
	<description>Last Byte
Setting this bit to 1 indicates that the entire packet has been written into the FIFO. This is used especially for streaming data to the FIFO while the actual transmission occurs. If the LAST bit is not set to 1 and the transmit FIFO becomes empty during a transmission, a stuff error followed by an EOP is forced on the bus. Zero length packets are indicated by setting this bit without writing any data to the FIFO.
The transmit state machine transmits the payload data, CRC16 and the EOP signal before clearing this bit. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_TX_EN</name>
	<description>Transmission Enable
This bit enables data transmission from the FIFO. It is cleared to 0 by hardware after transmitting a single packet or after a STALL handshake in response to an IN token. It must be set to 1 by firmware to start packet transmission. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXC3_REG</name>
	<description>Transmit Command Register 3</description>
	<addressOffset>0x00000076</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_IGN_ISOMSK</name>
	<description>Ignore ISO Mask
This bit has an effect only if the endpoint is set to be isochronous. If set to 1, this bit disables locking of specific frame numbers with the alternate function of the TOGGLE bit. Thus data is transmitted upon reception of the next IN token. If cleared to 0, data is only transmitted when FNL0 matches TOGGLE. This bit is cleared to 0 after reset. </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_TFWL</name>
	<description>Transmit FIFO Warning Limit
These bits specify how many more bytes can be transmitted from the respective FIFO before an underrun condition occurs. If the number of bytes remaining in the FIFO is equal to or less than the selected warning limit, the TXWARN bit in the FWEV register is set. To avoid interrupts caused by setting this bit while the FIFO is being filled before a transmission begins, TXWARN is only set when transmission from the endpoint is enabled (TX_ENn in the TXCn register is set).
TFWL[1:0] :
00: TFWL disabled
01: Less than 5 bytes remaining in FIFO
10: Less than 9 bytes remaining in FIFO
11: Less than 17 bytes remaining in FIFO </description>
	<access>read-write</access>
	<bitRange>[6:5]</bitRange>
	
</field><field>
	<name>USB_RFF</name>
	<description>Refill FIFO
Setting the LAST bit to 1 automatically saves the Transmit Read Pointer (TXRP) to a buffer. When the RFF bit is set to 1, the buffered TXRP is reloaded into the TXRP. This allows the user to repeat the last transaction if no ACK was received from the host. If the MAC is currently using the FIFO to transmit, TXRP is reloaded only after the transmission is complete. After reload, this bit is cleared to 0 by hardware. </description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>USB_FLUSH</name>
	<description>Flush FIFO
Writing a 1 to this bit flushes all data from the corresponding transmit FIFO, resets the endpoint to Idle state, and clears both the FIFO read and write pointers. If the MAC is currently using the FIFO to transmit, data is flushed after the transmission is complete. After data flushing, this bit is cleared to 0 by hardware. </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_TOGGLE_TX</name>
	<description>Toggle
The function of this bit differs depending on whether ISO (ISO bit in the EPCn register is set to 1) or non-ISO operation (ISO bit is cleared to 0) is used.
For non-ISO operation, it specifies the PID used when transmitting the packet. A value of 0 causes a DATA0 PID to be generated, while a value of 1 causes a DATA1 PID to be generated.
For ISO operation, this bit and the LSB of the frame counter (FNL0) act as a mask for the TX_EN bit to allow pre-queuing of packets to specific frame numbers; I.e. transmission is enabled only if bit 0 in the FNL register is set to TOGGLE. If an IN token is not received while this condition is true, the contents of the FIFO are flushed with the next SOF. If the endpoint is set to ISO, data is always transferred with a DATA0 PID. </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_LAST</name>
	<description>Last Byte
Setting this bit to 1 indicates that the entire packet has been written into the FIFO. This is used especially for streaming data to the FIFO while the actual transmission occurs. If the LAST bit is not set to 1 and the transmit FIFO becomes empty during a transmission, a stuff error followed by an EOP is forced on the bus. Zero length packets are indicated by setting this bit without writing any data to the FIFO.
The transmit state machine transmits the payload data, CRC16 and the EOP signal before clearing this bit. </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_TX_EN</name>
	<description>Transmission Enable
This bit enables data transmission from the FIFO. It is cleared to 0 by hardware after transmitting a single packet or after a STALL handshake in response to an IN token. It must be set to 1 by firmware to start packet transmission. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXD0_REG</name>
	<description>Transmit Data 0 Register</description>
	<addressOffset>0x00000042</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_TXFD</name>
	<description>Transmit FIFO Data Byte
The firmware is expected to write only the packet payload data. The PID and CRC16 are created automatically. </description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXD1_REG</name>
	<description>Transmit Data Register 1</description>
	<addressOffset>0x00000052</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_TXFD</name>
	<description>Transmit FIFO Data Byte
The firmware is expected to write only the packet payload data. PID and CRC16 are inserted automatically in the transmit data stream.
In TEST mode this register allow read/write access via the core bus. </description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXD2_REG</name>
	<description>Transmit Data Register 2</description>
	<addressOffset>0x00000062</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_TXFD</name>
	<description>Transmit FIFO Data Byte
The firmware is expected to write only the packet payload data. PID and CRC16 are inserted automatically in the transmit data stream.
In TEST mode this register allow read/write access via the core bus. </description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXD3_REG</name>
	<description>Transmit Data Register 3</description>
	<addressOffset>0x00000072</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_TXFD</name>
	<description>Transmit FIFO Data Byte
The firmware is expected to write only the packet payload data. PID and CRC16 are inserted automatically in the transmit data stream.
In TEST mode this register allow read/write access via the core bus. </description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXEV_REG</name>
	<description>Transmit Event Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_TXUDRRN31</name>
	<description>Transmit Underrun n: 3:1
The bit n is a copy of the respective TX_URUN bit from the corresponding Transmit Status register (TXSn). Whenever any of the Transmit FIFOs underflows, the respective TXUDRRN bit is set to 1. These bits are cleared to 0 when the corresponding Transmit Status register is read </description>
	<access>read-only</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>USB_TXFIFO31</name>
	<description>Transmit FIFO n: 3:1
The bit n is a copy of the TX_DONE bit from the corresponding Transmit Status register (TXSn). A bit is set to 1 when the IN transaction for the corresponding transmit endpoint n has been completed. These bits are cleared to 0 when the corresponding TXSn register is read. </description>
	<access>read-only</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXMSK_REG</name>
	<description>Transmit Mask Register</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_M_TXUDRRN31</name>
	<description>The Transmit Mask Register is used to select the bits of the TXEV registers, which causes the TX_EV bit in the MAEV register to be set to 1. When a bit is set to 1 and the corresponding bit in the TXEV register is set to 1, the TX_EV bit in the MAEV register is set to1. When cleared to 0, the corresponding bit in the TXEV register does not cause TX_EV to be set to 1. Same Bit Definition as TXEV Register </description>
	<access>read-write</access>
	<bitRange>[6:4]</bitRange>
	
</field><field>
	<name>USB_M_TXFIFO31</name>
	<description>Same Bit Definition as TXEV Register</description>
	<access>read-write</access>
	<bitRange>[2:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXS0_REG</name>
	<description>Transmit Status 0 Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_ACK_STAT</name>
	<description>Acknowledge Status
This bit indicates the status, as received from the host, of the ACK for the packet previously sent. This bit is to be interpreted when TX_DONE is set to 1. It is set to 1, when an ACK is received; otherwise, it remains cleared. This bit is also cleared to 0, when this register is read. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_TX_DONE</name>
	<description>Transmission Done
When set to 1, this bit indicates that a packet has completed transmission. It is cleared to 0, when this register is read. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_TCOUNT</name>
	<description>Transmission Count
This 5-bit field indicates the number of empty bytes available in the FIFO. This field is never larger than 8 for Endpoint 0. </description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXS1_REG</name>
	<description>Transmit Status Register 1</description>
	<addressOffset>0x00000054</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000001f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_TX_URUN</name>
	<description>Transmit FIFO Underrun
This bit is set to 1, if the transmit FIFO becomes empty during a transmission, and no new data is written to the FIFO. If so, the Media Access Controller (MAC) forces a bit stuff error followed by an EOP. This bit is cleared to 0, when this register is read. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_ACK_STAT</name>
	<description>Acknowledge Status
This bit is interpreted when TX_DONE is set. It's function differs depending on whether ISO (ISO in the EPCx register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, this bit indicates the acknowledge status (from the host) about the ACK for the previously sent packet. This bit itself is set to 1, when an ACK is received; otherwise, it is cleared to 0.
For ISO operation, this bit is set if a frame number LSB match (see IGN_ISOMSK bit in the USB_TXCx_REG) occurs, and data was sent in response to an IN token. Otherwise, this bit is cleared to 0, the FIFO is flushed and TX_DONE is set.
This bit is also cleared to 0, when this register is read. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_TX_DONE</name>
	<description>Transmission Done
When set to 1, this bit indicates that the endpoint responded to a USB packet. Three conditions can cause this bit to be set:
A data packet completed transmission in response to an IN token with non-ISO operation.
The endpoint sent a STALL handshake in response to an IN token
A scheduled ISO frame was transmitted or discarded.
This bit is cleared to 0 when this register is read. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_TCOUNT</name>
	<description>Transmission Count
This 5-bit field holds the number of empty bytes available in the FIFO. If this number is greater than 31, a value of 31 is actually reported. </description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXS2_REG</name>
	<description>Transmit Status Register 2</description>
	<addressOffset>0x00000064</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000001f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_TX_URUN</name>
	<description>Transmit FIFO Underrun
This bit is set to 1, if the transmit FIFO becomes empty during a transmission, and no new data is written to the FIFO. If so, the Media Access Controller (MAC) forces a bit stuff error followed by an EOP. This bit is cleared to 0, when this register is read. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_ACK_STAT</name>
	<description>Acknowledge Status
This bit is interpreted when TX_DONE is set. It's function differs depending on whether ISO (ISO in the EPCx register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, this bit indicates the acknowledge status (from the host) about the ACK for the previously sent packet. This bit itself is set to 1, when an ACK is received; otherwise, it is cleared to 0.
For ISO operation, this bit is set if a frame number LSB match (see IGN_ISOMSK bit in the USB_TXCx_REG) occurs, and data was sent in response to an IN token. Otherwise, this bit is cleared to 0, the FIFO is flushed and TX_DONE is set.
This bit is also cleared to 0, when this register is read. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_TX_DONE</name>
	<description>Transmission Done
When set to 1, this bit indicates that the endpoint responded to a USB packet. Three conditions can cause this bit to be set:
A data packet completed transmission in response to an IN token with non-ISO operation.
The endpoint sent a STALL handshake in response to an IN token
A scheduled ISO frame was transmitted or discarded.
This bit is cleared to 0 when this register is read. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_TCOUNT</name>
	<description>Transmission Count
This 5-bit field holds the number of empty bytes available in the FIFO. If this number is greater than 31, a value of 31 is actually reported. </description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_TXS3_REG</name>
	<description>Transmit Status Register 3</description>
	<addressOffset>0x00000074</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x0000001f</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_TX_URUN</name>
	<description>Transmit FIFO Underrun
This bit is set to 1, if the transmit FIFO becomes empty during a transmission, and no new data is written to the FIFO. If so, the Media Access Controller (MAC) forces a bit stuff error followed by an EOP. This bit is cleared to 0, when this register is read. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_ACK_STAT</name>
	<description>Acknowledge Status
This bit is interpreted when TX_DONE is set. It's function differs depending on whether ISO (ISO in the EPCx register is set) or non-ISO operation (ISO is reset) is used.
For non-ISO operation, this bit indicates the acknowledge status (from the host) about the ACK for the previously sent packet. This bit itself is set to 1, when an ACK is received; otherwise, it is cleared to 0.
For ISO operation, this bit is set if a frame number LSB match (see IGN_ISOMSK bit in the USB_TXCx_REG) occurs, and data was sent in response to an IN token. Otherwise, this bit is cleared to 0, the FIFO is flushed and TX_DONE is set.
This bit is also cleared to 0, when this register is read. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_TX_DONE</name>
	<description>Transmission Done
When set to 1, this bit indicates that the endpoint responded to a USB packet. Three conditions can cause this bit to be set:
A data packet completed transmission in response to an IN token with non-ISO operation.
The endpoint sent a STALL handshake in response to an IN token
A scheduled ISO frame was transmitted or discarded.
This bit is cleared to 0 when this register is read. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_TCOUNT</name>
	<description>Transmission Count
This 5-bit field holds the number of empty bytes available in the FIFO. If this number is greater than 31, a value of 31 is actually reported. </description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_UTR_REG</name>
	<description>USB test Register (for test purpose only)</description>
	<addressOffset>0x00000006</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_DIAG</name>
	<description>Diagnostic enable
'0': Normal operational.
'1': Access to the USB_XCVDIAG_REG and USB_TCR_REG enabled. For diagnostic purposes only </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_NCRC</name>
	<description>No CRC16
When this bit is set to 1, all packets transmitted by the Full/Low Speed USB node are sent without a trailing CRC16. Receive operations are unaffected. This mode is used to check that CRC errors can be detected by other nodes. For diagnostic purposes only </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_SF</name>
	<description>Short Frame
Enables the Frame timer to lock and track, short, non-compliant USB frame sizes. The Short Frame bit should not be set during normal operation. For test purposes only </description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_UTR_RES</name>
	<description>Reserved. Must be kept to '0' </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_UX20CDR_REG</name>
	<description>Transceiver 2.0 Configuration and Diagnostics Register(for test purpose only)</description>
	<addressOffset>0x0000003e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>RPU_TEST7</name>
	<description>Test bit </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>RPU_TEST_SW2</name>
	<description>0: Closes SW2 switch to reduced pull-up resistor connected to the USB_Dp and USB_Dm.
1: Opens SW2 switch resistor connected to the USB_Dp and USB_Dm (independent of the VBus state).</description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>RPU_TEST_SW1</name>
	<description>0: Enable the pull-up resistor on USB_Dp (SW1 closed)
1: Disable the pull-up resistor on USB_Dp (SW1 open) (Independent of the VBus state).</description>
	<access>read-write</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>RPU_TEST_EN</name>
	<description>Pull-Up Resistor Test Enable
0: Normal operation
1: Enables the test features controlled by RPU_TEST_SW1, RPU_TEST_SW1DM and RPU_TEST_SW2</description>
	<access>read-write</access>
	<bitRange>[4:4]</bitRange>
	
</field><field>
	<name>RPU_TEST_SW1DM</name>
	<description>0: Enable the pull-up resistor on USB_Dm (SW1DM closed)
1: Disable the pull-up resistor on USB_Dm (SW1DM open) (Independent of the VBus state).</description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>RPU_RCDELAY</name>
	<description>Test bit, must be kept 0 </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>RPU_SSPROTEN</name>
	<description>Test bit, must be kept 0 </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>USB_XCVDIAG_REG</name>
	<description>Transceiver diagnostic Register (for test purpose only)</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>USB_VPIN</name>
	<description>With Bit0 = 1 this bit shows the level of the USB_Dp receive data from transceiver; i.e. D+ &lt;= VSE. </description>
	<access>read-only</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>USB_VMIN</name>
	<description>With Bit0 = 1 this bit shows the level USB_Dm receive data from transceiver; i.e. D- &lt;= VSE. </description>
	<access>read-only</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>USB_RCV</name>
	<description>With Bit0 = 1 this bit shows the differential level of the receive comparator. </description>
	<access>read-only</access>
	<bitRange>[5:5]</bitRange>
	
</field><field>
	<name>USB_XCV_TXEN</name>
	<description>With Bit0 = 1, this bit enables test Bits 2,1. Must be kept to '0' for normal operation </description>
	<access>read-write</access>
	<bitRange>[3:3]</bitRange>
	
</field><field>
	<name>USB_XCV_TXn</name>
	<description>With Bit3,0 = 1, this bit sets USB_Dm to a high level, independent of LSMODE selection </description>
	<access>read-write</access>
	<bitRange>[2:2]</bitRange>
	
</field><field>
	<name>USB_XCV_TXp</name>
	<description>With Bit3,0 = 1, this bit sets USB_Dp to a high level, independent of LSMODE selection </description>
	<access>read-write</access>
	<bitRange>[1:1]</bitRange>
	
</field><field>
	<name>USB_XCV_TEST</name>
	<description>Enable USB_XCVDIAG_REG
0: Normal operation, test bits disabled
1: Enable test bits 7,6,5,3,2,1</description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>WAKEUP</name>
	<version>1.0</version>
	<description>WAKEUP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000100</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>52</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>WKUP_CLEAR_0_REG</name>
	<description>Clear event register for P0 and P1</description>
	<addressOffset>0x00000024</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>WKUP_CLEAR_P1</name>
	<description>Clear latched value of the GPIOs P1 when corresponding bit is 1</description>
	<access>write-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>WKUP_CLEAR_P0</name>
	<description>Clear latched value of the GPIOs P0 when corresponding bit is 1</description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_CLEAR_1_REG</name>
	<description>Clear event register for P2</description>
	<addressOffset>0x00000026</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>WKUP_CLEAR_P2</name>
	<description>Clear latched value of the GPIOs P2 when corresponding bit is 1</description>
	<access>write-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_CLEAR_2_REG</name>
	<description>Clear event register for P3 and P4</description>
	<addressOffset>0x00000028</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>WKUP_CLEAR_P4</name>
	<description>Clear latched value of the GPIOs P4 when corresponding bit is 1</description>
	<access>write-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>WKUP_CLEAR_P3</name>
	<description>Clear latched value of the GPIOs P3 when corresponding bit is 1</description>
	<access>write-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_CTRL_REG</name>
	<description>Control register for the wakeup counter</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>WKUP_ENABLE_IRQ</name>
	<description>0: no interrupt will be enabled
1: if you have an event an IRQ will be generated </description>
	<access>read-write</access>
	<bitRange>[7:7]</bitRange>
	
</field><field>
	<name>WKUP_SFT_KEYHIT</name>
	<description>0 = no effect
1 = emulate key hit. First make this bit 0 before any new key hit can be sensed. </description>
	<access>read-write</access>
	<bitRange>[6:6]</bitRange>
	
</field><field>
	<name>WKUP_DEB_VALUE</name>
	<description>Wakeup debounce time. If set to 0, no debouncing will be done.
Debounce time: N*1 ms. N =1..63</description>
	<access>read-write</access>
	<bitRange>[5:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_POL_P0_REG</name>
	<description>select the sesitivity polarity for each P0 input</description>
	<addressOffset>0x00000014</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_POL_P0</name>
	<description>0: enabled input P0x will give an event if that input goes high
1: enabled input P0x will give an event if that input goes low</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_POL_P1_REG</name>
	<description>select the sesitivity polarity for each P1 input</description>
	<addressOffset>0x00000016</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_POL_P1</name>
	<description>0: enabled input P1x will give an event if that input goes high
1: enabled input P1x will give an event if that input goes low</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_POL_P2_REG</name>
	<description>select the sesitivity polarity for each P2 input</description>
	<addressOffset>0x00000018</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>WKUP_POL_P2</name>
	<description>0: enabled input P2x will give an event if that input goes high
1: enabled input P2x will give an event if that input goes low</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_POL_P3_REG</name>
	<description>select the sesitivity polarity for each P3 input</description>
	<addressOffset>0x0000001a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_POL_P3</name>
	<description>0: enabled input P3x will give an event if that input goes high
1: enabled input P3x will give an event if that input goes low</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_POL_P4_REG</name>
	<description>select the sesitivity polarity for each P3 input</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_POL_P4</name>
	<description>0: enabled input P4x will give an event if that input goes high
1: enabled input P4x will give an event if that input goes low</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_RESET_IRQ_REG</name>
	<description>Reset wakeup interrupt</description>
	<addressOffset>0x00000004</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>WKUP_IRQ_RST</name>
	<description>writing any value to this register will reset the interrupt. reading always returns 0. </description>
	<access>write-only</access>
	<bitRange>[15:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SELECT_P0_REG</name>
	<description>select which inputs from P0 port can trigger wkup counter</description>
	<addressOffset>0x0000000a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_SELECT_P0</name>
	<description>0: input P0x is not enabled for wakeup event
1: input P0x is enabled for wakeup event</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SELECT_P1_REG</name>
	<description>select which inputs from P1 port can trigger wkup counter</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_SELECT_P1</name>
	<description>0: input P1x is not enabled for wakeup event
1: input P1x is enabled for wakeup event </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SELECT_P2_REG</name>
	<description>select which inputs from P2 port can trigger wkup counter</description>
	<addressOffset>0x0000000e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>WKUP_SELECT_P2</name>
	<description>0: input P2x is not enabled for wakeup event
1: input P2x is enabled for wakeup event </description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SELECT_P3_REG</name>
	<description>select which inputs from P3 port can trigger wkup counter</description>
	<addressOffset>0x00000010</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_SELECT_P3</name>
	<description>0: input P3x is not enabled for wakeup event
1: input P3x is enabled for wakeup event </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SELECT_P4_REG</name>
	<description>select which inputs from P3 port can trigger wkup counter</description>
	<addressOffset>0x00000012</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_SELECT_P4</name>
	<description>0: input P4x is not enabled for wakeup event
1: input P4x is enabled for wakeup event </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SEL_GPIO_P0_REG</name>
	<description>select which inputs from P0 port can trigger interrupt</description>
	<addressOffset>0x0000002a</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_SEL_GPIO_P0</name>
	<description>0: input P0x is not enabled for GPIO interrupt
1: input P0x is enabled for GPIO interrupt</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SEL_GPIO_P1_REG</name>
	<description>select which inputs from P1 port can trigger interrupt</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_SEL_GPIO_P1</name>
	<description>0: input P1x is not enabled for GPIO interrupt
1: input P1x is enabled for GPIO interrupt</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SEL_GPIO_P2_REG</name>
	<description>select which inputs from P2 port can trigger interrupt</description>
	<addressOffset>0x0000002e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>WKUP_SEL_GPIO_P2</name>
	<description>0: input P2x is not enabled for GPIO interrupt
1: input P2x is enabled for GPIO interrupt</description>
	<access>read-write</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SEL_GPIO_P3_REG</name>
	<description>select which inputs from P3 port can trigger interrupt</description>
	<addressOffset>0x00000030</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_SEL_GPIO_P3</name>
	<description>0: input P3x is not enabled for GPIO interrupt
1: input P3x is enabled for GPIO interrupt</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_SEL_GPIO_P4_REG</name>
	<description>select which inputs from P3 port can trigger interrupt</description>
	<addressOffset>0x00000032</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields>
	<field>
	<name>WKUP_SEL_GPIO_P4</name>
	<description>0: input P4x is not enabled for GPIO interrupt
1: input P4x is enabled for GPIO interrupt</description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_STATUS_0_REG</name>
	<description>Event status register for P0 and P1</description>
	<addressOffset>0x0000001e</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>WKUP_STAT_P1</name>
	<description>Contains the latched value of any toggle of the GPIOs Port P1. WKUP_STAT_P0[8] -&gt; P1_0.</description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>WKUP_STAT_P0</name>
	<description>Contains the latched value of any toggle of the GPIOs Port P0. WKUP_STAT_P0[0] -&gt; P0_0.</description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_STATUS_1_REG</name>
	<description>Event status register for P2</description>
	<addressOffset>0x00000020</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields>
	<field>
	<name>WKUP_STAT_P2</name>
	<description>Contains the latched value of any toggle of the GPIOs Port P2 WKUP_STATUS_1[0] -&gt; P2_0.</description>
	<access>read-only</access>
	<bitRange>[4:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WKUP_STATUS_2_REG</name>
	<description>Event status register for P3 and P4</description>
	<addressOffset>0x00000022</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>WKUP_STAT_P4</name>
	<description>Contains the latched value of any toggle of the GPIOs Port P4. WKUP_STATUS_2[8] -&gt; P4_0.</description>
	<access>read-only</access>
	<bitRange>[15:8]</bitRange>
	
</field><field>
	<name>WKUP_STAT_P3</name>
	<description>Contains the latched value of any toggle of the GPIOs Port P3. WKUP_STATUS_2[0] -&gt; P3_0.</description>
	<access>read-only</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>WDOG</name>
	<version>1.0</version>
	<description>WDOG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50003100</baseAddress>
	<size>0</size>
	<access>ACCESS</access>
	<addressBlock>
	<offset>0</offset>
	<size>4</size>
	<usage>registers</usage>
</addressBlock>
	<registers>
	<register>
	<name>WATCHDOG_CTRL_REG</name>
	<description>Watchdog control register.</description>
	<addressOffset>0x00000002</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>NMI_RST</name>
	<description>0 = Watchdog timer generates NMI at value 0, and WDOG (SYS) reset at &lt;=-16. Timer can be frozen /resumed using
SET_FREEZE_REG[FRZ_WDOG]/
RESET_FREEZE_REG[FRZ_WDOG].
1 = Watchdog timer generates a WDOG (SYS) reset at value 0 and can not be frozen by Software.
Note that this bit can only be set to 1 by SW and only be reset with a WDOG (SYS) reset or SW reset.
The watchdog is always frozen when the Cortex-M0 is halted in DEBUG State. </description>
	<access>read-write</access>
	<bitRange>[0:0]</bitRange>
	
</field></fields>
</register><register>
	<name>WATCHDOG_REG</name>
	<description>Watchdog timer register.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>16</size>
	<access>read-write</access>
	<resetValue>0x000000ff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields>
	<field>
	<name>WDOG_WEN</name>
	<description>0000.000 = Write enable for Watchdog timer
else Write disable. This filter prevents unintentional presetting the watchdog with a SW run-away. </description>
	<access>write-only</access>
	<bitRange>[15:9]</bitRange>
	
</field><field>
	<name>WDOG_VAL_NEG</name>
	<description>0 = Watchdog timer value is positive.
1 = Watchdog timer value is negative. </description>
	<access>read-write</access>
	<bitRange>[8:8]</bitRange>
	
</field><field>
	<name>WDOG_VAL</name>
	<description>Write: Watchdog timer reload value. Note that all bits 15-9 must be 0 to reload this register.
Read: Actual Watchdog timer value. Decremented by 1 every 10.24 msec. Bit 8 indicates a negative counter value. 2, 1, 0, 1FF16, 1FE16 etc. An NMI or WDOG (SYS) reset is generated under the following conditions:
If WATCHDOG_CTRL_REG[NMI_RST] = 0 then
    If WDOG_VAL = 0 -&gt; NMI (Non Maskable Interrupt)
    if WDOG_VAL = 1F016 -&gt; WDOG reset -&gt; reload FF16
If WATCHDOG_CTRL_REG[NMI_RST] = 1 then
    if WDOG_VAL &lt;= 0 -&gt; WDOG reset -&gt; reload FF16 </description>
	<access>read-write</access>
	<bitRange>[7:0]</bitRange>
	
</field></fields>
</register></registers>
</peripheral></peripherals>
</device>
